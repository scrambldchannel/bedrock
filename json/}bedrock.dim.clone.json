{
    "DataProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n#################################################################################################\r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock Ver 4.0.0~~##\r\n#################################################################################################\r\n\r\n\r\n### Check for errors in prolog ###\r\n\r\nIf( nErrors <> 0 );\r\n  If( pStrictErrorHandling = 1 );\r\n      ProcessQuit;\r\n  Else;\r\n      ProcessBreak;\r\n  EndIf;\r\nEndIf;\r\n\r\n### Replicate Attributes ###\r\n# Note: DTYPE on Attr dim returns \"AS\", \"AN\" or \"AA\" need to strip off leading \"A\"\r\n\r\nIf( pAttr = 1 & DimensionExists( sAttrDim ) = 1 );\r\n\r\n    nAttr = 1;\r\n    While( nAttr <= nNumAttrs );\r\n        sAttrName = DimNm( sAttrDim, nAttr );\r\n        sAttCheck = SubSt( DTYPE( sAttrDim, sAttrName ), 1, 1 );\r\n        IF (sAttCheck @= 'A');\r\n        sAttrType = SubSt( DTYPE( sAttrDim, sAttrName ), 2, 1 );\r\n        Else;\r\n        sAttrType = sAttcheck;\r\n        sMessage = pSrcDim | ' dimension contains invalid attribute - ' | sAttrName ;\r\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n        If( pStrictErrorHandling = 1 );\r\n          ItemReject(Expand( cMsgErrorContent ));\r\n        EndIf;\r\n        EndIf;\r\n        If( CellIsUpdateable( sAttrTargetDim, vEle, sAttrName ) = 1 );\r\n            If( sAttrType @= 'S' % sAttrType @= 'A' );\r\n                #sAttrVal = AttrS( pSrcDim, vEle, sAttrName );\r\n                sAttrVal = CellgetS('}ElementAttributes_'| pSrcDim, vEle, sAttrName);\r\n                If( sAttrVal @<> '' );\r\n                    If( sAttrType @= 'A' );\r\n                        AttrPutS( sAttrVal, pTgtDim, vEle, sAttrName, 1 );\r\n                    Else;\r\n                        AttrPutS( sAttrVal, pTgtDim, vEle, sAttrName );\r\n                    EndIf;\r\n                EndIf;\r\n            Else;\r\n                #nAttrVal = AttrN( pSrcDim, vEle, sAttrName );\r\n                nAttrVal = CellgetN('}ElementAttributes_'| pSrcDim, vEle, sAttrName);\r\n                If( nAttrVal <> 0 );\r\n                    AttrPutN( nAttrVal, pTgtDim, vEle, sAttrName );\r\n                EndIf;\r\n            EndIf;\r\n        EndIf;\r\n        # check for localized attributes\r\n        If( CubeExists( sAttrLoc ) = 1 );\r\n            nLang = 1;\r\n            While( nLang <= nNumLang );\r\n                sLang       = DimNm( cLangDim, nLang );\r\n                If( sAttrType @= 'A' % sAttrType @= 'S' );\r\n                    sAttrVal    = AttrS( pSrcDim, vEle, sAttrName );\r\n                    sAttrValLoc = AttrSL( pSrcDim, vEle, sAttrName, sLang );\r\n                    If( sAttrValLoc @= sAttrVal ); sAttrValLoc = ''; EndIf;\r\n                Else;\r\n                    nAttrVal    = AttrN( pSrcDim, vEle, sAttrName );\r\n                    nAttrValLoc = AttrNL( pSrcDim, vEle, sAttrName, sLang );\r\n                EndIf;\r\n                If( CubeExists( sAttrLocTarget ) = 0 );\r\n                    If( sAttrType @= 'A' );\r\n                        AttrPutS( sAttrValLoc, pTgtDim, vEle, sAttrName, sLang, 1 );\r\n                    ElseIf( sAttrType @= 'N' );\r\n                        If( nAttrValLoc <> nAttrVal );\r\n                            AttrPutN( nAttrValLoc, pTgtDim, vEle, sAttrName, sLang );\r\n                        EndIf;\r\n                    Else;\r\n                        AttrPutS( sAttrValLoc, pTgtDim, vEle, sAttrName, sLang );\r\n                    EndIf;\r\n                ElseIf( CubeExists( sAttrLocTarget ) = 1 );\r\n                    If( CellIsUpdateable( sAttrLocTarget, vEle, sLang, sAttrName ) = 1 );\r\n                        If( sAttrType @= 'A' );\r\n                            AttrPutS( sAttrValLoc, pTgtDim, vEle, sAttrName, sLang, 1 );\r\n                        ElseIf( sAttrType @= 'N' );\r\n                            If( nAttrValLoc <> nAttrVal );\r\n                                AttrPutN( nAttrValLoc, pTgtDim, vEle, sAttrName, sLang );\r\n                            EndIf;\r\n                        Else;\r\n                            AttrPutS( sAttrValLoc, pTgtDim, vEle, sAttrName, sLang );\r\n                        EndIf;\r\n                    EndIf;\r\n                EndIf;\r\n                nLang   = nLang + 1;\r\n            End;\r\n        EndIf;\r\n        nAttr = nAttr + 1;\r\n    End;\r\n\r\nEndIf;\r\n\r\n### End Data ###",
    "DataSource": {
        "Type": "?",
        "asciiDecimalSeparator": ".",
        "asciiDelimiterChar": ",",
        "asciiHeaderRecords": 0,
        "asciiQuoteCharacter": "\"",
        "asciiThousandSeparator": ",",
        "dataSourceNameForClient": "}Cubes",
        "dataSourceNameForServer": "}Cubes"
    },
    "EpilogProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n#################################################################################################\r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock Ver 4.0.0~~##\r\n#################################################################################################\r\n\r\n\r\n### Set the target Sort Order ###\r\n  CELLPUTS( sSortElementsType, '}DimensionProperties', pTgtDim, 'SORTELEMENTSTYPE');\r\n  CELLPUTS( sSortElementsSense, '}DimensionProperties', pTgtDim, 'SORTELEMENTSSENSE');\r\n  CELLPUTS( sSortComponentsType, '}DimensionProperties', pTgtDim, 'SORTCOMPONENTSTYPE');\r\n  CELLPUTS( sSortComponentsSense, '}DimensionProperties', pTgtDim, 'SORTCOMPONENTSSENSE');\r\n\r\n### Destroy Source Subset ###\r\n\r\n  If( SubsetExists( pSrcDim, cSubset ) = 1 );\r\n    SubsetDestroy( pSrcDim, cSubset );\r\n  EndIf;\r\n\r\n##Clone all the Hierarchies except default hierarchy & Leaves\r\nIf( pHier @= '*' );\r\n    sDim = pSrcDim;\r\n    sHierDim = '}Hierarchies_' | sDim;\r\n    sTargetHierarchy = '';\r\n    nMax = DimSiz( sHierDim );\r\n    nCtr = 1;\r\n    While( nCtr <= nMax );\r\n        sEle = DimNm( sHierDim, nCtr );\r\n        nElength = Long(sEle);\r\n        nElestart  = 0;\r\n        nElestart = SCAN(':', sEle) + 1;\r\n        If(nElestart > 1);\r\n          vSourceHierarchy = SUBST(sEle,nElestart,nElength);\r\n         If ( vSourceHierarchy @<> 'Leaves');\r\n             nRet = EXECUTEPROCESS('}bedrock.hier.clone',\r\n               'pLogOutput', pLogOutput,\r\n               'pStrictErrorHandling', pStrictErrorHandling,\r\n               'pSrcDim', sDim,\r\n               'pSrcHier', vSourceHierarchy,\r\n               'pTgtDim', pTgtDim,\r\n               'pTgtHier', vSourceHierarchy,\r\n               'pAttr', pAttr,\r\n               'pUnwind',pUnwind\r\n               );\r\n         Endif;\r\n         sTargetHierarchy = sTargetHierarchy |':'|vSourceHierarchy;\r\n        Endif;\r\n        nCtr = nCtr + 1;\r\n    End;\r\n### Just one hierarchy specified in parameter\r\nElseIf( Scan( '*', pHier )=0 &  Scan( '?', pHier )=0 & Scan( pDelim, pHier )=0 & Trim( pHier ) @<> '' );\r\n    sDim = pSrcDim;\r\n    sHierDim = '}Hierarchies_' | sDim;\r\n    sCurrHier = pHier;\r\n    sCurrHierName = Subst( sCurrHier, Scan(':', sCurrHier)+1, Long(sCurrHier) );\r\n    # Validate hierarchy name in sHierDim\r\n    If( Dimix( sHierDim , sDim |':'| sCurrHier ) = 0 );\r\n        sMessage = Expand('The \"%sCurrHier%\" hierarchy does NOT exist in the \"%sDim%\" dimension.');\r\n        LogOutput( 'INFO' , Expand( cMsgInfoContent ) );\r\n    ElseIf( sCurrHierName @= 'Leaves' );\r\n        sMessage = 'Invalid  Hierarchy: ' | sCurrHier | ' will be skipped....';\r\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n    ElseIf( sCurrHierName @<> sDim );\r\n      If( pLogOutput = 1 );\r\n        sMessage = Expand( 'Hierarchy \"%sCurrHierName%\" in Dimension \"%sDim%\" being processed....' );\r\n        LogOutput( 'INFO', Expand( cMsgInfoContent ) );\r\n      EndIf;\r\n      nRet = EXECUTEPROCESS('}bedrock.hier.clone',\r\n       'pLogOutput', pLogOutput,\r\n       'pStrictErrorHandling', pStrictErrorHandling,\r\n       'pSrcDim', sDim,\r\n       'pSrcHier', sCurrHierName,\r\n       'pTgtDim', pTgtDim,\r\n       'pTgtHier', sCurrHierName,\r\n       'pAttr', pAttr,\r\n       'pUnwind',pUnwind\r\n      );\r\n    Endif;\r\n### Hierachy is a delimited list with no wildcards\r\nElseIf( Scan( '*', pHier )=0 &  Scan( '?', pHier )=0 & Trim( pHier ) @<> '' );\r\n\r\n      # Loop through hierarchies in pHier\r\n    sDim = pSrcDim;\r\n    sHierarchies              = pHier;\r\n    nDelimiterIndexA    = 1;\r\n    sHierDim            = '}Hierarchies_'| sDim ;\r\n    sMdxHier = '';\r\n    While( nDelimiterIndexA <> 0 );\r\n\r\n        nDelimiterIndexA = Scan( pDelim, sHierarchies );\r\n        If( nDelimiterIndexA = 0 );\r\n            sHierarchy   = sHierarchies;\r\n        Else;\r\n            sHierarchy   = Trim( SubSt( sHierarchies, 1, nDelimiterIndexA - 1 ) );\r\n            sHierarchies  = Trim( Subst( sHierarchies, nDelimiterIndexA + Long(pDelim), Long( sHierarchies ) ) );\r\n        EndIf;\r\n        sCurrHier = sHierarchy;\r\n        sCurrHierName = Subst( sCurrHier, Scan(':', sCurrHier)+1, Long(sCurrHier) );\r\n        # Validate hierarchy name in sHierDim\r\n        If( Dimix( sHierDim , sDim |':'| sCurrHier ) = 0 );\r\n            sMessage = Expand('The \"%sCurrHier%\" hierarchy does NOT exist in the \"%sDim%\" dimension.');\r\n            LogOutput( 'INFO' , Expand( cMsgInfoContent ) );\r\n        ElseIf( sCurrHierName @= 'Leaves' );\r\n            sMessage = 'Invalid  Hierarchy: ' | sCurrHier | ' will be skipped....';\r\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n        ElseIf( sCurrHierName @<> sDim );\r\n          If( pLogOutput = 1 );\r\n            sMessage = Expand( 'Hierarchy \"%sCurrHierName%\" in Dimension \"%sDim%\" being processed....' );\r\n            LogOutput( 'INFO', Expand( cMsgInfoContent ) );\r\n          EndIf;\r\n          nRet = EXECUTEPROCESS('}bedrock.hier.clone',\r\n           'pLogOutput', pLogOutput,\r\n           'pStrictErrorHandling', pStrictErrorHandling,\r\n           'pSrcDim', sDim,\r\n           'pSrcHier', sCurrHierName,\r\n           'pTgtDim', pTgtDim,\r\n           'pTgtHier', sCurrHierName,\r\n           'pAttr', pAttr,\r\n           'pUnwind',pUnwind\r\n          );\r\n        Endif;\r\n    End;\r\n\r\n### Hierachy has wildcards inside\r\nElseIf( Trim( pHier ) @<> '' );\r\n\r\n      # Loop through hierarchies in pHier\r\n    sDim = pSrcDim;\r\n    sHierarchies              = pHier;\r\n    nDelimiterIndexA    = 1;\r\n    sHierDim            = '}Hierarchies_'| sDim ;\r\n    sMdxHier = '';\r\n    While( nDelimiterIndexA <> 0 );\r\n\r\n        nDelimiterIndexA = Scan( pDelim, sHierarchies );\r\n        If( nDelimiterIndexA = 0 );\r\n            sHierarchy   = sHierarchies;\r\n        Else;\r\n            sHierarchy   = Trim( SubSt( sHierarchies, 1, nDelimiterIndexA - 1 ) );\r\n            sHierarchies  = Trim( Subst( sHierarchies, nDelimiterIndexA + Long(pDelim), Long( sHierarchies ) ) );\r\n        EndIf;\r\n\r\n        # Create subset of Hierarchies using Wildcard\r\n        sHierExp = '\"'| sDim | ':' | sHierarchy|'\"';\r\n        sMdxHierPart = '{TM1FILTERBYPATTERN( {TM1SUBSETALL([ ' |sHierDim| '])},'| sHierExp | ')}';\r\n        IF( sMdxHier @= '');\r\n          sMdxHier = sMdxHierPart;\r\n        ELSE;\r\n          sMdxHier = sMdxHier | ' + ' | sMdxHierPart;\r\n        ENDIF;\r\n    End;\r\n\r\n    If( SubsetExists( sHierDim, cSubset ) = 1 );\r\n        # If a delimited list of attr names includes wildcards then we may have to re-use the subset multiple times\r\n        SubsetMDXSet( sHierDim, cSubset, sMdxHier );\r\n    Else;\r\n        # temp subset, therefore no need to destroy in epilog\r\n        SubsetCreatebyMDX( cSubset, sMdxHier, sHierDim, 1 );\r\n    EndIf;\r\n\r\n    # Loop through subset of hierarchies created based on wildcard\r\n    nCountHier = SubsetGetSize( sHierDim, cSubset  );\r\n    While( nCountHier >= 1 );\r\n        sCurrHier = SubsetGetElementName( sHierDim, cSubset , nCountHier );\r\n        sCurrHierName = Subst( sCurrHier, Scan(':', sCurrHier)+1, Long(sCurrHier) );\r\n        # Validate hierarchy name in sHierDim\r\n        If( Dimix( sHierDim , sCurrHier ) = 0 );\r\n            sMessage = Expand('The \"%sCurrHier%\" hierarchy does NOT exist in the \"%sDim%\" dimension.');\r\n            LogOutput( 'INFO' , Expand( cMsgInfoContent ) );\r\n        ElseIf( sCurrHierName @= 'Leaves' );\r\n            sMessage = 'Invalid  Hierarchy: ' | sCurrHier | ' will be skipped....';\r\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n        ElseIf( sCurrHierName @<> sDim );\r\n          If( pLogOutput = 1 );\r\n            sMessage = Expand( 'Hierarchy \"%sCurrHierName%\" in Dimension \"%sDim%\" being processed....' );\r\n            LogOutput( 'INFO', Expand( cMsgInfoContent ) );\r\n          EndIf;\r\n          nRet = EXECUTEPROCESS('}bedrock.hier.clone',\r\n           'pLogOutput', pLogOutput,\r\n           'pStrictErrorHandling', pStrictErrorHandling,\r\n           'pSrcDim', sDim,\r\n           'pSrcHier', sCurrHierName,\r\n           'pTgtDim', pTgtDim,\r\n           'pTgtHier', sCurrHierName,\r\n           'pAttr', pAttr,\r\n           'pUnwind',pUnwind\r\n          );\r\n        Endif;\r\n\r\n        nCountHier = nCountHier - 1;\r\n    End;\r\nEndif;\r\n\r\n### Clone dimension subsets\r\nIf( pSub = 1);\r\n  nCountSubs = DimSiz ('}Subsets_' | sDim);\r\n  While ( nCountSubs >= 1 );\r\n    sCurrSub = If( Scan( ':', DimNm ('}Subsets_' | sDim, nCountSubs)) = 0, DimNm ('}Subsets_' | sDim, nCountSubs), Subst( DimNm ('}Subsets_' | sDim, nCountSubs), Scan( ':', DimNm ('}Subsets_' | sDim, nCountSubs))+1, Long(DimNm ('}Subsets_' | sDim, nCountSubs))-Scan( ':', DimNm ('}Subsets_' | sDim, nCountSubs))));\r\n    sCurrHier = If( Scan( ':', DimNm ('}Subsets_' | sDim, nCountSubs)) = 0, '', Subst(DimNm ('}Subsets_' | sDim, nCountSubs), 1, Scan( ':', DimNm ('}Subsets_' | sDim, nCountSubs))-1));\r\n\r\n    ExecuteProcess('}bedrock.hier.sub.clone',\r\n      'pLogOutput',0,\r\n      'pStrictErrorHandling',0,\r\n      'pSrcDim',sDim,\r\n      'pSrcHier',sCurrHier,\r\n      'pSrcSub',sCurrSub,\r\n      'pTgtDim', pTgtDim,\r\n      'pTgtHier', sCurrHier,\r\n      'pTgtSub',sCurrSub,\r\n      'pTemp',0,\r\n      'pAlias','');\r\n    nCountSubs = nCountSubs - 1;\r\n  End;\r\nEndif;\r\n\r\n\r\n### Return code & final error message handling\r\nIf( nErrors > 0 );\r\n    sMessage = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\r\n    nProcessReturnCode = 0;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\r\n    If( pStrictErrorHandling = 1 );\r\n        ProcessQuit;\r\n    EndIf;\r\nElse;\r\n    sProcessAction = Expand( 'Process:%cThisProcName% has cloned the %pSrcDim% dimension into %pTgtDim%.' );\r\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\r\n    nProcessReturnCode = 1;\r\n    If( pLogoutput = 1 );\r\n        LogOutput('INFO', Expand( sProcessAction ) );\r\n    EndIf;\r\nEndIf;\r\n\r\n### End Epilog ###",
    "HasSecurityAccess": true,
    "MetadataProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n#################################################################################################\r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock Ver 4.0.0~~##\r\n#################################################################################################\r\n\r\n\r\n### Check for errors in prolog ###\r\n\r\nIf( nErrors <> 0 );\r\n  If( pStrictErrorHandling = 1 );\r\n      ProcessQuit;\r\n  Else;\r\n      ProcessBreak;\r\n  EndIf;\r\nEndIf;\r\n\r\n### Add Elements to target dimension ###\r\n\r\nsElType = DType( pSrcDim, vEle );\r\nIF( sElType @= 'C' & ElCompN( pSrcDim, vEle ) > 0 );\r\n    nChildren = ElCompN( pSrcDim, vEle );\r\n    nCount = 1;\r\n    While( nCount <= nChildren );\r\n      sChildElement = ElComp( pSrcDim, vEle, nCount );\r\n      sChildWeight = ElWeight( pSrcDim, vEle, sChildElement );\r\n      DimensionElementComponentAdd( pTgtDim, vEle, sChildElement, sChildWeight );\r\n      nCount = nCount + 1;\r\n    End;\r\nEndIf;\r\n\r\n### End MetaData ###",
    "Name": "}bedrock.dim.clone",
    "Parameters": [
        {
            "Name": "pLogOutput",
            "Prompt": "OPTIONAL: Write parameters and action summary to server message log (Boolean True = 1)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pStrictErrorHandling",
            "Prompt": "OPTIONAL: On encountering any error exit with major error status by ProcessQuit after writing to the server message log (Boolean True = 1)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pSrcDim",
            "Prompt": "REQUIRED: Source Dimension",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pTgtDim",
            "Prompt": "OPTIONAL: Target Dimension (will default to pSrcDim_clone If blank (or) is same as pSrcDim)",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pHier",
            "Prompt": "REQUIRED: Hierarchies to be included (will use default is left blank) accepts wildcards (if = * then all hierarchies)",
            "Type": "String",
            "Value": "*"
        },
        {
            "Name": "pAttr",
            "Prompt": "REQUIRED: Include Attributes? (Boolean 1=True)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pUnwind",
            "Prompt": "REQUIRED: 0 = Delete all Elements 1 = Unwind Existing Elements 2 = Do not change Existing Elements",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pDelim",
            "Prompt": "OPTIONAL: delimiter character for element list (required if pEle parameter is used) (default value if blank = '&')",
            "Type": "String",
            "Value": "&"
        },
        {
            "Name": "pSub",
            "Prompt": "OPTIONAL: if 1 = Clone subsets",
            "Type": "Numeric",
            "Value": "0"
        }
    ],
    "PrologProcedure": "#Region CallThisProcess\r\n# A snippet of code provided as an example how to call this process should the developer be working on a system without access to an editor with auto-complete.\r\nIf( 1 = 0 );\r\n    ExecuteProcess( '}bedrock.dim.clone', 'pLogOutput', pLogOutput,\r\n      'pStrictErrorHandling', pStrictErrorHandling,\r\n    \t'pSrcDim', '', 'pTgtDim', '', 'pHier', '*',\r\n    \t'pAttr', 0, 'pUnwind', 0, 'pDelim', '&'\r\n\t);\r\nEndIf;\r\n#EndRegion CallThisProcess\r\n\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n#################################################################################################\r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock Ver 4.0~~##\r\n#################################################################################################\r\n\r\n#Region @DOC\r\n# Description:\r\n# This process can clone a source dimension and all the Hierarchies.\r\n\r\n# Use case: Intended for development/prototyping.\r\n# 1/ Replicate a dimension with it's hierarchies for testing.\r\n\r\n# Note:\r\n# If the target dimension:hierarchy already exists then it will be overwritten.\r\n# Naturally, a valid source dimension name (pSrcDim) is mandatory otherwise the process will abort.\r\n#EndRegion @DOC\r\n\r\n### Global Variables\r\nStringGlobalVariable ('sProcessReturnCode');\r\nNumericGlobalVariable('nProcessReturnCode');\r\nnProcessReturnCode = 0;\r\n\r\n### Constants ###\r\ncThisProcName     = GetProcessName();\r\ncUserName         = TM1User();\r\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\r\ncRandomInt        = NumberToString( INT( RAND( ) * 1000 ));\r\ncSubset           = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\r\ncMsgErrorLevel    = 'ERROR';\r\ncMsgErrorContent  = '%cThisProcName% : %sMessage% : %cUserName%';\r\ncMsgInfoContent   = 'User:%cUserName% Process:%cThisProcName% Message:%sMessage%';\r\ncLogInfo          = '***Parameters for Process:%cThisProcName% for pSrcDim:%pSrcDim%, pTgtDim:%pTgtDim%, pHier:%pHier%, pAttr:%pAttr%, pUnwind:%pUnwind%, pDelim:%pDelim%.';\r\ncLangDim          = '}Cultures';\r\nnNumLang          = DimSiz( cLangDim );\r\n\r\n## LogOutput parameters\r\nIF ( pLogoutput = 1 );\r\n  LogOutput('INFO', Expand( cLogInfo ) );\r\nENDIF;\r\n\r\n### Validate Parameters ###\r\nnErrors = 0;\r\n\r\nIf( Scan( '*', pSrcDim )=0 &  Scan( '?', pSrcDim )=0 & Scan( pDelim, pSrcDim )=0 & Scan( ':', pSrcDim ) > 0 & pHier @= '' );\r\n    # A hierarchy has been passed as dimension. Handle the input error by splitting dim:hier into dimension & hierarchy\r\n    pHier       = SubSt( pSrcDim, Scan( ':', pSrcDim ) + 1, Long( pSrcDim ) );\r\n    pSrcDim        = SubSt( pSrcDim, 1, Scan( ':', pSrcDim ) - 1 );\r\nEndIf;\r\n\r\n## Validate dimension\r\nIF( Trim( pSrcDim ) @= '' );\r\n  nErrors = 1;\r\n  sMessage = 'No source dimension specified.';\r\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nElseIF( DimensionExists( pSrcDim ) = 0 );\r\n  nErrors = 1;\r\n  sMessage = 'Invalid source dimension: ' | pSrcDim;\r\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\nIf( pTgtDim @= '' % pTgtDim @= pSrcDim );\r\n  pTgtDim = pSrcDim | '_Clone';\r\nEndIf;\r\n\r\n# Validate hierarchy\r\nIF( Scan( '*', pSrcDim )=0 &  Scan( '?', pSrcDim )=0 & Scan( pDelim, pSrcDim )=0 & pHier @= '');\r\n    pHier = pSrcDim;\r\nElseIf( Scan( '*', pHier )=0 &  Scan( '?', pHier )=0 & Scan( pDelim, pHier )=0 & pHier @<> '' & HierarchyExists(pSrcDim, pHier) = 0 );\r\n    nErrors = 1;\r\n    sMessage = 'Invalid dimension hierarchy: ' | pHier;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndif;\r\n\r\nIf( Trim( pHier ) @= '' );\r\n    ## use same name as Dimension. Since wildcards are allowed, this is managed inside the code below\r\nEndIf;\r\n\r\n## Default delimiter\r\nIf( pDelim     @= '' );\r\n    pDelim     = '&';\r\nEndIf;\r\n\r\n### Check for errors before continuing\r\nIf( nErrors <> 0 );\r\n  If( pStrictErrorHandling = 1 );\r\n      ProcessQuit;\r\n  Else;\r\n      ProcessBreak;\r\n  EndIf;\r\nEndIf;\r\n\r\n### Create target dimension ###\r\n\r\nIf(DimensionExists( pTgtDim ) = 0 );\r\n    DimensionCreate( pTgtDim );\r\nElse;\r\n    IF(pUnwind = 1 );\r\n       nRet = ExecuteProcess('}bedrock.hier.unwind',\r\n        'pLogOutput', pLogOutput,\r\n        'pStrictErrorHandling', pStrictErrorHandling,\r\n        'pDim', pTgtDim,\r\n        'pHier', pTgtDim,\r\n        'pConsol', '*',\r\n        'pRecursive', 1\r\n        );\r\n    ELSEIF(pUnwind = 2 );\r\n      # Do nothing;\r\n    ELSE;\r\n      DimensionDeleteAllElements( pTgtDim );\r\n    EndIf;\r\nEndIf;\r\n\r\n### Set the target Sort Order ###\r\nsSortElementsType     = CELLGETS( '}DimensionProperties', pSrcDim, 'SORTELEMENTSTYPE');\r\nsSortElementsSense    = CELLGETS( '}DimensionProperties', pSrcDim, 'SORTELEMENTSSENSE');\r\nsSortComponentsType   = CELLGETS( '}DimensionProperties', pSrcDim, 'SORTCOMPONENTSTYPE');\r\nsSortComponentsSense  = CELLGETS( '}DimensionProperties', pSrcDim, 'SORTCOMPONENTSSENSE');\r\n\r\nDimensionSortOrder( pTgtDim, sSortComponentsType, sSortComponentsSense, sSortElementsType , sSortElementsSense);\r\n\r\n\r\nnSourceDimSize = DIMSIZ( pSrcDim );\r\nnIndex = 1;\r\nWHILE( nIndex <= nSourceDimSize );\r\n  sElName = DIMNM( pSrcDim, nIndex);\r\n  sElType = DTYPE( pSrcDim, sElName);\r\n\r\n    DimensionElementInsert( pTgtDim, '', sElName, sElType );\r\n\r\n  nIndex = nIndex + 1;\r\nEND;\r\n\r\n### Assign Data Source ###\r\nDatasourceNameForServer   = pSrcDim;\r\nDatasourceNameForClient   = pSrcDim;\r\nDataSourceType            = 'SUBSET';\r\nDatasourceDimensionSubset = 'ALL';\r\n\r\n\r\n### Replicate Attributes ###\r\n# Note: DType on Attr dim returns \"AS\", \"AN\" or \"AA\" need to strip off leading \"A\"\r\nsAttrDim        = '}ElementAttributes_' | pSrcDim;\r\nsAttrLoc        = '}LocalizedElementAttributes_' | pSrcDim;\r\nsAttrTargetDim  = '}ElementAttributes_' | pTgtDim;\r\nsAttrLocTarget  = '}LocalizedElementAttributes_' | pTgtDim;\r\n\r\nIf( pAttr = 1 & DimensionExists( sAttrDim ) = 1 );\r\n  nNumAttrs = DimSiz( sAttrDim );\r\n  nCount = 1;\r\n  While( nCount <= nNumAttrs );\r\n    sAttrName = DimNm( sAttrDim, nCount );\r\n    sAttCheck = SubSt( DTYPE( sAttrDim, sAttrName ), 1, 1 );\r\n    IF (sAttCheck @= 'A');\r\n    sAttrType = SubSt( DTYPE( sAttrDim, sAttrName ), 2, 1 );\r\n    Else;\r\n    sAttrType = sAttcheck;\r\n    EndIf;\r\n\r\n      If ( DimensionExists( sAttrTargetDim ) = 0);\r\n         AttrInsert(pTgtDim,'',sAttrName,sAttrType );\r\n       ElseIF(DimIx(sAttrTargetDim, sAttrName) = 0);\r\n         AttrInsert(pTgtDim,'',sAttrName,sAttrType );\r\n      Endif;\r\n\r\n    nCount = nCount + 1;\r\n  End;\r\nEndIf;\r\n\r\n\r\n### End Prolog ###",
    "UIData": "CubeAction=1511\fDataAction=1503\fCubeLogChanges=0\f",
    "Variables": [
        {
            "EndByte": 0,
            "Name": "vEle",
            "Position": 1,
            "StartByte": 0,
            "Type": "String"
        }
    ],
    "VariablesUIData": []
}