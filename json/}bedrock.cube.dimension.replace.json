{
    "DataProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n",
    "DataSource": {
        "Type": "None"
    },
    "EpilogProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n#################################################################################################\r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock Ver 4.0~~##\r\n#################################################################################################\r\n\r\n### Return code & final error message handling\r\nIf( nErrors > 0 );\r\n    sMessage = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\r\n    nProcessReturnCode = 0;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\r\n    If( pStrictErrorHandling = 1 );\r\n        ProcessQuit;\r\n    EndIf;\r\nElse;\r\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully replaced the %pSrcDim% dimension with the %pTgtDim% in the %pCube% cube. Data was loaded to the %pEle% item.' );\r\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\r\n    nProcessReturnCode = 1;\r\n    If( pLogoutput = 1 );\r\n        LogOutput('INFO', Expand( sProcessAction ) );\r\n    EndIf;\r\nEndIf;\r\n\r\n### End Epilog ###",
    "HasSecurityAccess": true,
    "MetadataProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n",
    "Name": "}bedrock.cube.dimension.replace",
    "Parameters": [
        {
            "Name": "pLogOutput",
            "Prompt": "OPTIONAL: Write parameters and action summary to server message log (Boolean True = 1)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pStrictErrorHandling",
            "Prompt": "OPTIONAL: On encountering any error exit with major error status by ProcessQuit after writing to the server message log (Boolean True = 1)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pCube",
            "Prompt": "REQUIRED: Cube",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pSrcDim",
            "Prompt": "REQUIRED: Dimension to be replaced",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pTgtDim",
            "Prompt": "REQUIRED: Replacement Dimension",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pIncludeData",
            "Prompt": "REQUIRED: If 1 then data is kept (copied through clone cube)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pEle",
            "Prompt": "REQUIRED: If pIncludeData =1: Element in target dimension to load data to",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pIncludeRules",
            "Prompt": "REQUIRED: Unload and reload the rule (0 = do not keep the rule 1 = unload the rule 2 = unload the rule and reload on new cube)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pCtrlObj",
            "Prompt": "REQUIRED: Allow overwrite control cubes",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pTemp",
            "Prompt": "REQUIRED: Delete the clone cube (1 = delete 0 = not delete)",
            "Type": "Numeric",
            "Value": "1"
        }
    ],
    "PrologProcedure": "#Region CallThisProcess\r\n# A snippet of code provided as an example how to call this process should the developer be working on a system without access to an editor with auto-complete.\r\nIf( 1 = 0 );\r\n    ExecuteProcess( '}bedrock.cube.dimension.replace', 'pLogOutput', pLogOutput,\r\n      'pStrictErrorHandling', pStrictErrorHandling,\r\n    \t'pCube', '', 'pSrcDim', '', 'pTgtDim', '',\r\n    \t'pIncludeData', 0, 'pEle', '',\r\n    \t'pIncludeRules', 0,\r\n    \t'pCtrlObj', 0, 'pTemp', 1\r\n\t);\r\nEndIf;\r\n#EndRegion CallThisProcess\r\n\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n#################################################################################################\r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock Ver 4.0~~##\r\n#################################################################################################\r\n\r\n#Region @DOC\r\n# Description:\r\n# This TI deletes a dimension and adds another one to an existing cube with the ability to preserve data.\r\n\r\n# Use case: Intended for development/prototyping.\r\n# 1/ Rebuild existing cube after removal of one dimension and adding anothr one without losing all the data.\r\n\r\n# Note:\r\n# Naturally, a valid cube name (pCube) is mandatory otherwise the process will abort.\r\n# Also, valid dimension names (pSrcDim & pTgtDim) are mandatory otherwise the process will abort.\r\n# When data needs to be kept (using pIncludeData) a valid element (pEle) in new dimension must be specified\r\n# where to store the data. Data is summed from original dimension.\r\n# Rule can be kept as backup file only or reloaded back.\r\n#EndRegion @DOC\r\n\r\n\r\n# This process selects the cube and replaces\r\n# the source dimensions from a specified target dimensions.\r\n# This process should only be run on an EMPTY cube or a cube that\r\n# has already had all data exported to a text file\r\n\r\n# Note:\r\n# - This process does not preserve any cube rules as they would likely no longer be\r\n#   valid if a dimension is replaced\r\n\r\n##Global Variables\r\nStringGlobalVariable('sProcessReturnCode');\r\nNumericGlobalVariable('nProcessReturnCode');\r\n\r\n### Constants ###\r\ncThisProcName     = GetProcessName();\r\ncUserName         = TM1User();\r\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\r\ncRandomInt        = NumberToString( INT( RAND( ) * 1000 ));\r\ncMsgErrorLevel    = 'ERROR';\r\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\r\ncLogInfo          = 'Process:%cThisProcName% run with parameters pCube:%pCube%, pSrcDim:%pSrcDim%, pTgtDim:%pTgtDim%, pIncludeData:%pIncludeData%, pEle:%pEle%, pIncludeRules:%pIncludeRules%, pCtrlObj:%pCtrlObj%, pTemp:%pTemp%.' ;\r\ncDefaultView      = Expand( '%cThisProcName%_%cTimeStamp%_%cRandomInt%' );\r\n\r\n## check operating system\r\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\r\n  sOS = 'Windows';\r\n  sOSDelim = '\\';\r\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0 );\r\n  sOS = 'Linux';\r\n  sOSDelim = '/';\r\nElse;\r\n  sOS = 'Windows';\r\n  sOSDelim = '\\';\r\nEndIf;\r\n\r\n### Validate Parameters ###\r\nnErrors = 0;\r\n# Validate cube\r\nIf( Trim( pCube ) @= '' );\r\n    sMessage = 'No cube specified.';\r\n    nErrors = nErrors + 1;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nElseIf( CubeExists( pCube ) = 0 );\r\n    sMessage = Expand( 'Cube %pCube% does not exist.' );\r\n    nErrors = nErrors + 1;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\n# Don't allow system cubes to be modified\r\nIf( SubSt( pCube, 1, 1 ) @= '}' & pCtrlObj <= 0 );\r\n  nErrors = nErrors + 1;\r\n  sMessage = Expand( 'Do not modify system cubes: %pCube%.');\r\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\n# Validate source dimension\r\nIf( Trim( pSrcDim ) @= '' );\r\n  nErrors = nErrors + 1;\r\n  sMessage = 'No source dimension specified.';\r\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nElseIf( DimensionExists( pSrcDim ) = 0 );\r\n  nErrors = nErrors + 1;\r\n  sMessage = Expand( 'Source dimension %pSrcDim% does not exist.');\r\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\n# Validate target dimension\r\nIf( Trim( pTgtDim ) @= '' );\r\n  nErrors = nErrors + 1;\r\n  sMessage = 'No target dimension specified.';\r\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nElseIf( DimensionExists( pTgtDim ) = 0 );\r\n  nErrors = nErrors + 1;\r\n  sMessage = Expand( 'Target dimension %pTgtDim% does not exist.');\r\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\n# Check that the source and target dimensions are different\r\nIf( pSrcDim @= pTgtDim );\r\n  sMessage = Expand('Source and target dimensions are the same: %pSrcDim%');\r\n  nErrors = nErrors + 1;\r\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\n# check element chosen in new dimension\r\nIf( pIncludeData = 1 & Trim(pEle)@='' );\r\n  nErrors = nErrors + 1;\r\n  sMessage = Expand( 'No element specified in new dimension %pTgtDim% to store cube data.');\r\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\nIf( pIncludeData = 1 & DIMIX(pTgtDim, pEle)=0 );\r\n  nErrors = nErrors + 1;\r\n  sMessage = Expand( 'Invalid element %pEle% specified for the new dimension %pTgtDim% to store cube data.');\r\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\nIF(pIncludeRules = 1 % pIncludeRules = 2);\r\n  cCubeRuleFileName = '.' | sOSDelim | pCube | '.RUX';\r\n  If(FileExists(cCubeRuleFileName) = 0);\r\n    pIncludeRules = 0;\r\n    LogOutput( 'INFO', Expand( 'No rule found for %pCube%.' ) );\r\n  Endif;\r\nEndif;\r\n\r\n### Determine number of dims in source cube & create strings to check and recreate ###\r\nnCount = 1;\r\nsDimString = '';\r\nsDimCheck = '';\r\nsDelim = '+';\r\nWhile( TabDim( pCube, nCount ) @<> '' );\r\n  sDim = TabDim( pCube, nCount );\r\n  IF(sDim@=pSrcDim);\r\n    sNewDim=pTgtDim;\r\n  else;\r\n    sNewDim=sDim;\r\n  Endif;\r\n  IF(nCount = 1);\r\n    sDimCheck = '+'|sDim|'+';\r\n    sDimString = sNewDim;\r\n  elseif(nCount > 1);\r\n    sDimCheck = sDimCheck|'+'|sDim|'+';\r\n    sDimString = sDimString|'+'|sNewDim;\r\n  Endif;\r\n  nCount = nCount + 1;\r\nEnd;\r\nnDimensionCount = nCount - 1;\r\n\r\n#Remove any leading +\r\nIF( Subst( sDimString , 1 , 1 ) @= '+' );\r\n    sDimString      = Subst ( sDimString , 2 , 999 );\r\nEndIf;\r\n\r\n#check source dimension\r\nIF(scan('+'|pSrcDim|'+', sDimCheck)=0);\r\n  nErrors = nErrors + 1;\r\n  sMessage = Expand( 'Source Dimension %pSrcDim% does not exist in %pCube%.');\r\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndif;\r\n\r\n#check target dimension\r\nIF(scan('+'|pTgtDim|'+', sDimCheck)>0);\r\n  nErrors = nErrors + 1;\r\n  sMessage = Expand( 'Target Dimension %pTgtDim% already exists in %pCube%.');\r\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndif;\r\n\r\n# Check if cube exceeds current max dimenions\r\nIf( nDimensionCount > 27 );\r\n  sMessage = 'Process needs to be modified to handle cubes with more than 27 dimensions';\r\n  nErrors = nErrors + 1;\r\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\n### Check for errors before continuing\r\nIf( nErrors <> 0 );\r\n  If( pStrictErrorHandling = 1 );\r\n      ProcessQuit;\r\n  Else;\r\n      ProcessBreak;\r\n  EndIf;\r\nEndIf;\r\n\r\n######  CALLING THE STEP PROCESSES #####\r\n# Keep the rule\r\nIF(pIncludeRules = 1 % pIncludeRules = 2);\r\n    sProc = '}bedrock.cube.rule.manage';\r\n\r\n    nRet = EXECUTEPROCESS( sProc,\r\n        'pLogOutput', pLogOutput,\r\n        'pStrictErrorHandling', pStrictErrorHandling,\r\n        'pCube', pCube,\r\n        'pMode', 'UNLOAD'\r\n        );\r\n\r\n    IF(nRet <> 0);\r\n        sMessage = 'Error unloading the rule for %pCube%.';\r\n        nErrors = nErrors + 1;\r\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n        If( pStrictErrorHandling = 1 );\r\n            ProcessQuit;\r\n        Else;\r\n            ProcessBreak;\r\n        EndIf;\r\n    ENDIF;\r\n\r\nEndif;\r\n\r\n# create clone cube with data\r\nIF(pIncludeData = 1);\r\n\r\n    pCloneCube = pCube | '_Clone';\r\n    nIncludeRules = IF(pIncludeRules = 1 % pIncludeRules = 2, 1, 0);\r\n     nSuppressRules = IF(nIncludeRules = 1,  1, 0);\r\n\r\n    sProc = '}bedrock.cube.clone';\r\n    nRet = EXECUTEPROCESS( sProc,\r\n        'pLogOutput', pLogOutput,\r\n        'pStrictErrorHandling', pStrictErrorHandling,\r\n        'pSrcCube', pCube,\r\n        'pTgtCube', pCloneCube,\r\n        'pIncludeRules', nIncludeRules,\r\n        'pIncludeData', pIncludeData,\r\n        'pSuppressRules', nSuppressRules,\r\n        'pTemp', pTemp,\r\n        'pCubeLogging', 0\r\n        );\r\n\r\n    IF(nRet <> 0);\r\n        sMessage = 'Error creating cloned cube for keeping data.';\r\n        nErrors = nErrors + 1;\r\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n        If( pStrictErrorHandling = 1 );\r\n            ProcessQuit;\r\n        Else;\r\n            ProcessBreak;\r\n        EndIf;\r\n    ENDIF;\r\n\r\nEndif;\r\n\r\n# recreate the cube\r\nsProc = '}bedrock.cube.create';\r\nnRet = ExecuteProcess( sProc,\r\n        'pLogOutput', pLogOutput,\r\n        'pStrictErrorHandling', pStrictErrorHandling,\r\n        'pCube', pCube,\r\n        'pDims', sDimString,\r\n        'pRecreate', 1,\r\n        'pDelim', sDelim\r\n        );\r\n\r\nIF(nRet <> 0);\r\n    sMessage = Expand('Error recreating the cube: %pCube%.');\r\n    nErrors = nErrors + 1;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n    If( pStrictErrorHandling = 1 );\r\n        ProcessQuit;\r\n    Else;\r\n        ProcessBreak;\r\n    EndIf;\r\nENDIF;\r\n\r\n\r\n# copy back the data\r\nIF(pIncludeData = 1);\r\n    sEleStartDelim = '\u00a6';\r\n    sMappingToNewDims = pTgtDim|sEleStartDelim|pEle;\r\n\r\n    nRet = ExecuteProcess('}bedrock.cube.data.copy.intercube',\r\n\t    'pLogOutput',pLogOutput,\r\n\t    'pStrictErrorHandling', pStrictErrorHandling,\r\n\t    'pSrcCube',pCloneCube,\r\n\t    'pFilter','',\r\n\t    'pTgtCube',pCube,\r\n\t    'pMappingToNewDims',sMappingToNewDims,\r\n        'pSuppressConsol', 1,\r\n        'pSuppressRules', nSuppressRules,\r\n\t    'pZeroTarget',0,\r\n\t    'pZeroSource',0,\r\n\t    'pFactor',1,\r\n\t    'pDimDelim','&',\r\n\t    'pEleStartDelim',sEleStartDelim,\r\n\t    'pEleDelim','+',\r\n\t    'pTemp',pTemp,\r\n\t    'pCubeLogging',0);\r\n\r\n    IF(nRet <> 0);\r\n        sMessage = Expand('Error copying back the data from clone cube: %pCloneCube%.');\r\n        nErrors = nErrors + 1;\r\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n        If( pStrictErrorHandling = 1 );\r\n            ProcessQuit;\r\n        Else;\r\n            ProcessBreak;\r\n        EndIf;\r\n    ENDIF;\r\n\r\n    # destroy clone cube\r\n    IF(pTemp=1);\r\n        sProc = '}bedrock.cube.delete';\r\n        nRet = EXECUTEPROCESS( sProc,\r\n            'pLogOutput', pLogOutput,\r\n            'pStrictErrorHandling', pStrictErrorHandling,\r\n            'pCube', pCloneCube,\r\n            'pCtrlObj', 0\r\n            );\r\n\r\n        IF(nRet <> 0);\r\n            sMessage = Expand('Error deleting the clone cube: %pCloneCube%.');\r\n            nErrors = nErrors + 1;\r\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n            If( pStrictErrorHandling = 1 );\r\n                ProcessQuit;\r\n            Else;\r\n                ProcessBreak;\r\n            EndIf;\r\n        ENDIF;\r\n    Endif;\r\n\r\nEndif;\r\n\r\n# reload the rule\r\nIF(pIncludeRules = 2);\r\n\r\n    sProc = '}bedrock.cube.rule.manage';\r\n\r\n    nRet = EXECUTEPROCESS( sProc,\r\n        'pLogOutput', pLogOutput,\r\n        'pStrictErrorHandling', pStrictErrorHandling,\r\n        'pCube', pCube,\r\n        'pMode', 'LOAD'\r\n        );\r\n\r\n    IF(nRet <> 0);\r\n      sMessage = Expand('Error reloading the rule for %pCube%.');\r\n      nErrors = nErrors + 1;\r\n      LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n      # Create error rule file\r\n      cErrorRuleName = 'ErrorRuleFile.rux';\r\n\r\n      IF(FileExists( cErrorRuleName ) = 0 );\r\n        sFile = '.' | sOSDelim | cErrorRuleName;\r\n        LogOutput(cMsgErrorLevel, 'Rule could not be attached due to invalid !Dimension references. Please recover from the backup and fix manually.');\r\n      ENDIF;\r\n\r\n      EXECUTEPROCESS( sProc,\r\n      'pLogOutput', pLogOutput,\r\n      'pStrictErrorHandling', pStrictErrorHandling,\r\n      'pCube', pCube,\r\n      'pFileName', cErrorRuleName,\r\n      'pMode', 'LOAD'\r\n      );\r\n      If( pStrictErrorHandling = 1 );\r\n          ProcessQuit;\r\n      Else;\r\n          ProcessBreak;\r\n      EndIf;\r\n    ENDIF;\r\n\r\nEndif;\r\n\r\n### End Prolog ###",
    "Variables": []
}