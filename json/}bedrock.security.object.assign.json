{
    "DataProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n",
    "DataSource": {
        "Type": "None"
    },
    "EpilogProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n#################################################################################################\r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock Ver 4.0~~##\r\n#################################################################################################\r\n\r\n### Return code & final error message handling\r\nIf( nErrors > 0 );\r\n    sMessage = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\r\n    nProcessReturnCode = 0;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\r\n    If( pStrictErrorHandling = 1 );\r\n        ProcessQuit;\r\n    EndIf;\r\nElse;\r\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully assigned object %pObject% of type %pObjectType% security level %pSecurityLevel% for group %pGroup%.' );\r\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\r\n    nProcessReturnCode = 1;\r\n    If( pLogoutput = 1 );\r\n        LogOutput('INFO', Expand( sProcessAction ) );\r\n    EndIf;\r\nEndIf;\r\n\r\n### End Epilog ###",
    "HasSecurityAccess": true,
    "MetadataProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n",
    "Name": "}bedrock.security.object.assign",
    "Parameters": [
        {
            "Name": "pLogOutput",
            "Prompt": "OPTIONAL: Write parameters and action summary to server message log (Boolean True = 1)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pStrictErrorHandling",
            "Prompt": "OPTIONAL: On encountering any error exit with major error status by ProcessQuit after writing to the server message log (Boolean True = 1)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pGroup",
            "Prompt": "REQUIRED: List of Groups Separated by Delimiter",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pObjectType",
            "Prompt": "REQUIRED: Type of Object to Assign Security To (Application/Cube/Dimension/Process/Chore)",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pObject",
            "Prompt": "REQUIRED: List of Objects Separated by Delimiter",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pSecurityLevel",
            "Prompt": "REQUIRED: Security Level (Read/Write/Admin/None)",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pSecurityRefresh",
            "Prompt": "OPTIONAL: Refresh Security? (Default = No)",
            "Type": "String",
            "Value": "No"
        },
        {
            "Name": "pDelim",
            "Prompt": "OPTIONAL: Delimiter (default value if blank = '&')",
            "Type": "String",
            "Value": "&"
        }
    ],
    "PrologProcedure": "#Region CallThisProcess\r\n# A snippet of code provided as an example how to call this process should the developer be working on a system without access to an editor with auto-complete.\r\nIf( 1 = 0 );\r\n    ExecuteProcess( '}bedrock.security.object.assign', 'pLogOutput', pLogOutput,\r\n      'pStrictErrorHandling', pStrictErrorHandling,\r\n    \t'pGroup', '', 'pObjectType', '', 'pObject', '',\r\n    \t'pSecurityLevel', '', 'pSecurityRefresh', 'No', 'pDelim', '&'\r\n\t);\r\nEndIf;\r\n#EndRegion CallThisProcess\r\n\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n#################################################################################################\r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock Ver 4.0~~##\r\n#################################################################################################\r\n\r\n#Region @DOC\r\n# Description:\r\n# This process will assign security to specified object(s) for specified group(s). Both pGroup\r\n# and pObject parameters support delimited lists and wildcards.\r\n\r\n# Use case: Intended for develpment or production.\r\n# 1. Set up initial security assignments.\r\n# 2. Update security assignments a business needs change.\r\n\r\n# Note:\r\n# Naturally, group (pGroup), object type (pObjectType) and security level (pSecurityLevel) are mandatory otherwise the process will abort:\r\n# - Multiple groups can be specified separated by delimiter.\r\n# Object names (pObject) can be listed with delimiters but need to be valid as well.\r\n# - Before using this process, you must first initialise object security.\r\n# - For Applications, in Server Explorer go to Applications -> Security Assignments and assign an access security for an Application.\r\n# - For other object types follow a similar process but for that object type.\r\n# - Then from the Server Explorer go to your ServerName -> Security -> Refresh Security.\r\n# - Multiple objects can be specified separated by delimiter.\r\n# - If groups and/or objects that don't exist are specified, then they will be skipped but valid groups and ojects will still be processed.\r\n#EndRegion @DOC\r\n\r\n##Global Variables\r\nStringGlobalVariable('sProcessReturnCode');\r\nNumericGlobalVariable('nProcessReturnCode');\r\nnProcessReturnCode= 0;\r\n\r\n### Constants ###\r\ncThisProcName       = GetProcessName();\r\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\r\ncRandomInt          = NumberToString( INT( RAND( ) * 1000 ));\r\ncSecurityCube       = '}' | pObjectType | 'Security';\r\ncTempSub            = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\r\ncUserName           = TM1User();\r\ncMsgErrorLevel      = 'ERROR';\r\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\r\ncLogInfo            = 'Process:%cThisProcName% run with parameters pGroup:%pGroup%, pObjectType:%pObjectType%, pObject:%pObject%, pSecurityLevel:%pSecurityLevel%, pSecurityRefresh:%pSecurityRefresh%, pDelim:%pDelim%.' ;\r\n\r\n## LogOutput parameters\r\nIF( pLogoutput = 1 );\r\n    LogOutput('INFO', Expand( cLogInfo ) );\r\nENDIF;\r\n\r\n### Validate Parameters ###\r\nnErrors             = 0;\r\n# If no groups have been specified then terminate process\r\nIf( Trim( pGroup ) @= '' );\r\n    nErrors         = 1;\r\n    sMessage        = 'No groups specified.';\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\n# Validate Object Type\r\nIf( pObjectType @<> 'Application' & pObjectType @<> 'Cube' & pObjectType @<> 'Dimension' & pObjectType @<> 'Process' & pObjectType @<> 'Chore' );\r\n    nErrors         = 1;\r\n    sMessage        = 'Invalid object type specified: ' | pObjectType | '. Valid object types are: Application, Cube, Dimension, Process and Chore';\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\n# If no objects have been specified then terminate process\r\nIf( Trim( pObject ) @= '' );\r\n    nErrors         = 1;\r\n    sMessage        = 'No objects specified.';\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\n# Validate that object type has object security enabled\r\nIf( CubeExists( cSecurityCube ) = 0 );\r\n    sObjectTypePlural = pObjectType;\r\n    If( pObjectType @= 'Process');\r\n        sObjectTypePlural = sObjectTypePlural | 'es';\r\n    Else;\r\n        sObjectTypePlural = sObjectTypePlural | 's';\r\n    EndIf;\r\n    nErrors = 1;\r\n    sMessage = 'You must first initialise ' | pObjectType | ' Security. In the Server Explorer go to ' |\r\n               sObjectTypePlural | ' -> Security Assignments, and assign an access security to a ' |\r\n               pObjectType | '. Then from the Server Explorer go to your ServerName -> Security -> Refresh Security';\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\n# Set Object Type Dimension\r\nsObjectTypeDimension = '}' | pObjectType;\r\nIf( pObjectType @= 'Application' );\r\n    sObjectTypeDimension = sObjectTypeDimension | 'Entries';\r\nElseIf( pObjectType @= 'Process' );\r\n    sObjectTypeDimension = sObjectTypeDimension | 'es';\r\nElse;\r\n    sObjectTypeDimension = sObjectTypeDimension | 's';\r\nEndIf;\r\n\r\n# Validate Security Level\r\n# Allowable Security Levels by Object Type (excluding RESERVE and LOCK):\r\n#   Cube        : NONE, READ, ADMIN, WRITE\r\n#   Dimension   : NONE, READ, ADMIN, WRITE\r\n#   Application : NONE, READ, ADMIN\r\n#   Process     : NONE, READ\r\n#   Chore       : NONE, READ\r\npSecurityLevel = Upper( pSecurityLevel );\r\nIf( pSecurityLevel @= 'NONE' % pSecurityLevel @= 'READ' %\r\n  ( pSecurityLevel @= 'ADMIN' & ( pObjectType @= 'Cube' % pObjectType @= 'Dimension' % pObjectType @= 'Application' ) ) %\r\n  ( pSecurityLevel @= 'WRITE' & ( pObjectType @= 'Cube' % pObjectType @= 'Dimension' ) ) );\r\n  # Valid Security Levels\r\nElse;\r\n    nErrors = 1;\r\n    sMessage = 'Invalid security level parameter: ' | pSecurityLevel | ' for object type: ' | pObjectType;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\n# If pSecurityRefresh is blank then default to yes\r\nIf( Trim( pSecurityRefresh ) @= '' );\r\n    pSecurityRefresh = 'Yes';\r\nEndIf;\r\n\r\n# If pSecurityRefresh has not been specified correctly then terminate process\r\nIf( Upper( pSecurityRefresh ) @<> 'YES' & Upper( pSecurityRefresh ) @<> 'NO' );\r\n    nErrors = 1;\r\n    sMessage = 'Incorrect value for pSecurityRefresh: ' | pSecurityRefresh | '. Valid values are Yes or No';\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\n# If blank delimiter specified then convert to default\r\nIf( pDelim @= '' );\r\n    pDelim = '&';\r\nEndIf;\r\n\r\n### Check for errors before continuing\r\nIf( nErrors <> 0 );\r\n  If( pStrictErrorHandling = 1 );\r\n      ProcessQuit;\r\n  Else;\r\n      ProcessBreak;\r\n  EndIf;\r\nEndIf;\r\n\r\n### Assign Application Security ###\r\n# Loop through list of groups\r\nsGroups = pGroup;\r\nnGroupDelimIndex = 1;\r\n\r\nWhile( nGroupDelimIndex <> 0 );\r\n  nGroupDelimIndex = Scan( pDelim, sGroups );\r\n  If( nGroupDelimIndex = 0 );\r\n    sGroup = sGroups;\r\n  Else;\r\n    sGroup = Trim( SubSt( sGroups, 1, nGroupDelimIndex - 1 ) );\r\n    sGroups = Trim( Subst( sGroups, nGroupDelimIndex + Long(pDelim), Long( sGroups ) ) );\r\n  EndIf;\r\n\r\n\r\n If(Scan('*',sGroup) = 0);\r\n\r\n\r\n  # Don't attempt to process a blank group or ADMIN\r\n  If( sGroup @<> '' & sGroup @<> 'ADMIN' );\r\n    # Check that Group exists\r\n    If( DimIx( '}Groups', sGroup ) = 0 );\r\n        nErrors = 1;\r\n        sMessage = 'Group: ' | sGroup | ' does not exists';\r\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n     ELSE;\r\n\r\n      # Loop through list of objects\r\n      sObjects = pObject;\r\n      nObjectDelimIndex = 1;\r\n\r\n      While( nObjectDelimIndex <> 0 );\r\n        nObjectDelimIndex = Scan( pDelim, sObjects );\r\n        If( nObjectDelimIndex = 0 );\r\n          sObject = sObjects;\r\n        Else;\r\n          sObject = Trim( SubSt( sObjects, 1, nObjectDelimIndex - 1 ) );\r\n          sObjects = Trim( Subst( sObjects, nObjectDelimIndex + Long(pDelim), Long( sObjects ) ) );\r\n        EndIf;\r\n        If( Scan( '*', sObject ) = 0);\r\n         # Don't attempt to process a blank object\r\n         If( sObject @<> '' );\r\n           # Check that object exists\r\n           If( DimIx( sObjectTypeDimension, sObject ) = 0 );\r\n                nErrors = 1;\r\n                sMessage = 'Object: ' | sObject | ' does not exists';\r\n                LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n          ELSE;\r\n             # Assign Security\r\n             If( CellIsUpdateable( cSecurityCube, sObject, sGroup ) = 1 );\r\n               If( nErrors = 0);\r\n                 CellPutS( pSecurityLevel, cSecurityCube, sObject, sGroup );\r\n               EndIf;\r\n             EndIf;\r\n           EndIf;\r\n         EndIf;\r\n        ELSE;\r\n          # Wildcard search string\r\n         sObject = '\"'|sObject|'\"';\r\n         sMdx = '{TM1FILTERBYPATTERN( {TM1SUBSETALL([ ' |sObjectTypeDimension| '])},'| sObject| ')}';\r\n         If( SubsetExists( sObjectTypeDimension, cTempSub ) = 1 );\r\n            # If a delimited list of objects includes wildcards then we may have to re-use the subset multiple times\r\n            SubsetMDXSet( sObjectTypeDimension, cTempSub, sMDX );\r\n         Else;\r\n            # temp subset, therefore no need to destroy in epilog\r\n            SubsetCreatebyMDX( cTempSub, sMDX, sObjectTypeDimension, 1 );\r\n         EndIf;\r\n         nCountObj = SubsetGetSize( sObjectTypeDimension, cTempSub );\r\n         While( nCountObj >= 1 );\r\n            sObject = SubsetGetElementName( sObjectTypeDimension, cTempSub, nCountObj );\r\n            # Assign Security\r\n             If( CellIsUpdateable( cSecurityCube, sObject, sGroup ) = 1 );\r\n               If( nErrors = 0);\r\n                 CellPutS( pSecurityLevel, cSecurityCube, sObject, sGroup );\r\n               EndIf;\r\n             EndIf;\r\n            nCountObj = nCountObj - 1;\r\n         End;\r\n        EndIf;\r\n      End;\r\n    EndIf;\r\n  EndIf;\r\n ELSE;\r\n# Wildcard search string\r\n        sGroupDim = '}Groups';\r\n        sGroup = '\"'|sGroup|'\"';\r\n        sMdx = '{TM1FILTERBYPATTERN( {TM1SUBSETALL([ ' |sGroupDim| '])},'| sGroup| ')}';\r\n        If( SubsetExists( sGroupDim, cTempSub ) = 1 );\r\n            # If a delimited list of groups includes wildcards then we may have to re-use the subset multiple times\r\n            SubsetMDXSet( sGroupDim, cTempSub, sMDX );\r\n        Else;\r\n            # temp subset, therefore no need to destroy in epilog\r\n            SubsetCreatebyMDX( cTempSub, sMDX, sGroupDim, 1 );\r\n        EndIf;\r\n        # Loop through dimensions in groups with wildcard\r\n        nCountGroup = SubsetGetSize( '}Groups' , cTempSub );\r\n        While( nCountGroup >= 1 );\r\n\r\n            sGroup = SubsetGetElementName( '}Groups' , cTempSub, nCountGroup );\r\n            # Validate group name\r\n            If( Dimix('}Groups', sGroup) = 0 );\r\n                nErrors = 1;\r\n                sMessage = Expand( 'Group \"%sGroup%\" does not exist.' );\r\n                LogOutput( 'ERROR', Expand( cMsgErrorContent ) );\r\n            Else;\r\n              # Loop through list of objects\r\n              sObjects = pObject;\r\n              nObjectDelimIndex = 1;\r\n\r\n              While( nObjectDelimIndex <> 0 );\r\n                nObjectDelimIndex = Scan( pDelim, sObjects );\r\n                If( nObjectDelimIndex = 0 );\r\n                  sObject = sObjects;\r\n                Else;\r\n                  sObject = Trim( SubSt( sObjects, 1, nObjectDelimIndex - 1 ) );\r\n                  sObjects = Trim( Subst( sObjects, nObjectDelimIndex + Long(pDelim), Long( sObjects ) ) );\r\n                EndIf;\r\n                If( Scan( '*', sObject ) = 0);\r\n                # Don't attempt to process a blank object\r\n                  If( sObject @<> '' );\r\n                    # Check that object exists\r\n                    If( DimIx( sObjectTypeDimension, sObject ) = 0 );\r\n                        nErrors = 1;\r\n                        sMessage = 'Object: ' | sObject | ' does not exists';\r\n                        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n                    ELSE;\r\n                      # Assign Security\r\n                      If( CellIsUpdateable( cSecurityCube, sObject, sGroup ) = 1 );\r\n                        If( nErrors = 0);\r\n                          CellPutS( pSecurityLevel, cSecurityCube, sObject, sGroup );\r\n                        EndIf;\r\n                      EndIf;\r\n                    EndIf;\r\n                  EndIf;\r\n                ELSE;\r\n                # Wildcard search string\r\n                sObject = '\"'|sObject|'\"';\r\n                sMdx = '{TM1FILTERBYPATTERN( {TM1SUBSETALL([ ' |sObjectTypeDimension| '])},'| sObject| ')}';\r\n                If( SubsetExists( sObjectTypeDimension, cTempSub ) = 1 );\r\n                    # If a delimited list of objects includes wildcards then we may have to re-use the subset multiple times\r\n                    SubsetMDXSet( sObjectTypeDimension, cTempSub, sMDX );\r\n                Else;\r\n                    # temp subset, therefore no need to destroy in epilog\r\n                    SubsetCreatebyMDX( cTempSub, sMDX, sObjectTypeDimension, 1 );\r\n                EndIf;\r\n                  nCountObj = SubsetGetSize( sObjectTypeDimension, cTempSub );\r\n                  While( nCountObj >= 1 );\r\n                      sObject = SubsetGetElementName( sObjectTypeDimension, cTempSub, nCountObj );\r\n                      # Assign Security\r\n                      If( CellIsUpdateable( cSecurityCube, sObject, sGroup ) = 1 );\r\n                        If( nErrors = 0);\r\n                          CellPutS( pSecurityLevel, cSecurityCube, sObject, sGroup );\r\n                        EndIf;\r\n                      EndIf;\r\n                      nCountObj = nCountObj - 1;\r\n                  End;\r\n                EndIf;\r\n              End;\r\n            Endif;\r\n            nCountGroup = nCountGroup - 1;\r\n        End;\r\n  Endif;\r\nEnd;\r\n\r\n\r\n### Refresh Security ###\r\n\r\nIf( Upper( pSecurityRefresh ) @= 'YES' );\r\n  SecurityRefresh;\r\nEndIf;\r\n\r\n\r\n### End Prolog ###",
    "Variables": []
}