{
    "DataProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n",
    "DataSource": {
        "Type": "None"
    },
    "EpilogProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n#################################################################################################\r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock Ver 4.0~~##\r\n#################################################################################################\r\n\r\n### Return code & final error message handling\r\nIf( nErrors > 0 );\r\n    sMessage = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\r\n    nProcessReturnCode = 0;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\r\n    If( pStrictErrorHandling = 1 );\r\n        ProcessQuit;\r\n    EndIf;\r\nElse;\r\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully deleted dimension %pDim% from the %pCube% cube.' );\r\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\r\n    nProcessReturnCode = 1;\r\n    If( pLogoutput = 1 );\r\n        LogOutput('INFO', Expand( sProcessAction ) );\r\n    EndIf;\r\nEndIf;\r\n\r\n### End Epilog ###",
    "HasSecurityAccess": true,
    "MetadataProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n",
    "Name": "}bedrock.cube.dimension.delete",
    "Parameters": [
        {
            "Name": "pLogOutput",
            "Prompt": "REQUIRED: Optional: write parameters and action summary to server message log (Boolean True = 1)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pStrictErrorHandling",
            "Prompt": "OPTIONAL: On encountering any error exit with major error status by ProcessQuit after writing to the server message log (Boolean True = 1)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pCube",
            "Prompt": "REQUIRED: Cube",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pDim",
            "Prompt": "REQUIRED: Dimension to be deleted",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pIncludeData",
            "Prompt": "REQUIRED: If 1 then data is kept (copied through clone cube)",
            "Type": "Numeric",
            "Value": "1"
        },
        {
            "Name": "pIncludeRules",
            "Prompt": "REQUIRED: Unload and reload the rule (0 = do not keep the rule 1 = unload the rule 2 = unload the rule and reload on new cube)",
            "Type": "Numeric",
            "Value": "2"
        },
        {
            "Name": "pCtrlObj",
            "Prompt": "REQUIRED: Allow overwrite control cubes",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pTemp",
            "Prompt": "REQUIRED: Delete the clone cube (1 = delete 0 = not delete)",
            "Type": "Numeric",
            "Value": "1"
        }
    ],
    "PrologProcedure": "#Region CallThisProcess\r\n# A snippet of code provided as an example how to call this process should the developer be working on a system without access to an editor with auto-complete.\r\nIf( 1 = 0 );\r\n    ExecuteProcess( '}bedrock.cube.dimension.delete', 'pLogOutput', pLogOutput,\r\n      'pStrictErrorHandling', pStrictErrorHandling,\r\n    \t'pCube', '', 'pDim', '',\r\n    \t'pIncludeData', 1, 'pIncludeRules', 2,\r\n    \t'pCtrlObj', 0, 'pTemp', 1\r\n\t);\r\nEndIf;\r\n#EndRegion CallThisProcess\r\n\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n#################################################################################################\r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock Ver 4.0~~##\r\n#################################################################################################\r\n\r\n#Region @DOC\r\n# Description:\r\n# This TI deletes a dimension from a cube that has already been built with the ability to preserve data.\r\n\r\n# Use case: Intended for development/prototyping.\r\n# 1/ Rebuild existing cube with the removal of one dimension without losing all the data.\r\n\r\n# Note:\r\n# Naturally, a valid cube name (pCube) is mandatory otherwise the process will abort.\r\n# Also, a valid dimension name (pDim) is mandatory otherwise the process will abort.\r\n# If data needs to be kept (using pIncludeData), data from pDim will be summed.\r\n# Rule can be kept as backup file only or reloaded back.\r\n#EndRegion @DOC\r\n\r\n### Global Variables\r\nStringGlobalVariable('sProcessReturnCode');\r\nNumericGlobalVariable('nProcessReturnCode');\r\nnProcessReturnCode= 0;\r\n\r\n### Constants ###\r\ncThisProcName   = GetProcessName();\r\ncUserName       = TM1User();\r\ncTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\r\ncRandomInt      = NumberToString( INT( RAND( ) * 1000 ));\r\ncTempSub        = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\r\ncMsgErrorLevel  = 'ERROR';\r\ncMsgErrorContent= 'Process:%cThisProcName% ErrorMsg:%sMessage%';\r\ncLogInfo        = 'Process:%cThisProcName% run with parameters pCube:%pCube%, pDim:%pDim%, pIncludeData:%pIncludeData%, pIncludeRules:%pIncludeRules%, pCtrlObj:%pCtrlObj%, pTemp:%pTemp%.';\r\n\r\n## check operating system\r\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\r\n  sOS = 'Windows';\r\n  sOSDelim = '\\';\r\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0 );\r\n  sOS = 'Linux';\r\n  sOSDelim = '/';\r\nElse;\r\n  sOS = 'Windows';\r\n  sOSDelim = '\\';\r\nEndIf;\r\n\r\n## LogOutput parameters\r\nIF( pLogoutput = 1 );\r\n    LogOutput('INFO', Expand( cLogInfo ) );\r\nENDIF;\r\n\r\n### Validate Parameters ###\r\nnErrors = 0;\r\n# Validate cube\r\nIf( Trim( pCube ) @= '' );\r\n    nErrors = nErrors + 1;\r\n    sMessage = 'No cube specified.';\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nElseIf( CubeExists( pCube ) = 0 );\r\n    nErrors = nErrors + 1;\r\n    sMessage = Expand( 'Invalid cube specified: %pCube%.');\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\n# Don't allow system cubes to be modified\r\nIf( SubSt( pCube, 1, 1 ) @= '}' & pCtrlObj <= 0 );\r\n    nErrors = nErrors + 1;\r\n    sMessage = Expand( 'Do not modify system cubes: %pCube%.');\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\n# Validate dimension\r\nIf( Trim( pDim ) @= '' );\r\n    nErrors = nErrors + 1;\r\n    sMessage = 'No dimension specified.';\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nElseIf( DimensionExists( pDim ) = 0 );\r\n    nErrors = nErrors + 1;\r\n    sMessage = Expand( 'New dimension: %pDim% does not exist');\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\n\r\nIF(pIncludeRules = 1 % pIncludeRules = 2);\r\n    cCubeRuleFileName = '.' | sOSDelim | pCube | '.RUX';\r\n    If(FileExists(cCubeRuleFileName) = 0);\r\n        pIncludeRules = 0;\r\n        LogOutput( 'INFO', Expand( 'No rule found for %pCube%.' ) );\r\n    Endif;\r\nEndif;\r\n\r\n### Determine number of dims in source cube & create strings to check and recreate ###\r\nnCount = 1;\r\nsDimString = '';\r\nsDimCheck = '';\r\nsDelim = '+';\r\nnSkip=0;\r\nnIncrement = 1;\r\nWhile( TabDim( pCube, nCount ) @<> '' );\r\n    sDim = TabDim( pCube, nCount );\r\n    IF(sDim@=pDim);\r\n        nSkip = 1;\r\n    else;\r\n        nSkip = 0;\r\n    Endif;\r\n    IF(nCount = 1);\r\n        sDimCheck = '+'|sDim|'+';\r\n    elseif(nCount > 1);\r\n        sDimCheck = sDimCheck|'+'|sDim|'+';\r\n    Endif;\r\n    IF(nCount = 1 & nSkip = 0);\r\n        sDimString = sDim;\r\n    elseif(nCount > 1 & nSkip = 0);\r\n        sDimString = sDimString|'+'|sDim;\r\n    Endif;\r\n    nCount = nCount + 1;\r\nEnd;\r\nnDimensionCount = nCount-1;\r\n\r\n#Remove any leading +\r\nIF( Subst( sDimString , 1 , 1 ) @= '+' );\r\n    sDimString      = Subst ( sDimString , 2 , 999 );\r\nEndIf;\r\n\r\n\r\nIF(scan('+'|pDim|'+',sDimCheck)=0);\r\n    nErrors = nErrors + 1;\r\n    sMessage = Expand( 'The chosen dimension %pDim% does not exists in cube %pCube%.');\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndif;\r\n\r\n# Check if cube exceeds current max dimenions\r\nIf( nDimensionCount > 27 );\r\n    sMessage = 'Process needs to be modified to handle cubes with more than 27 dimensions';\r\n    nErrors = nErrors + 1;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\n### Check for errors before continuing\r\nIf( nErrors <> 0 );\r\n  If( pStrictErrorHandling = 1 );\r\n      ProcessQuit;\r\n  Else;\r\n      ProcessBreak;\r\n  EndIf;\r\nEndIf;\r\n\r\n######  CALLING THE STEP PROCESSES #####\r\n\r\n# Keep the rule\r\nIF(pIncludeRules = 1 % pIncludeRules = 2);\r\n\r\n  sProc = '}bedrock.cube.rule.manage';\r\n\r\n  nRet = EXECUTEPROCESS( sProc,\r\n    'pLogOutput', pLogOutput,\r\n    'pStrictErrorHandling', pStrictErrorHandling,\r\n    'pCube', pCube,\r\n    'pMode', 'UNLOAD'\r\n    );\r\n\r\n  IF(nRet <> 0);\r\n    sMessage = 'Error unloading the rule for %pCube%.';\r\n    nErrors = nErrors + 1;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n    If( pStrictErrorHandling = 1 );\r\n        ProcessQuit;\r\n    Else;\r\n        ProcessBreak;\r\n    EndIf;\r\n  ENDIF;\r\n\r\nEndif;\r\n\r\n# create clone cube with data\r\nIF(pIncludeData = 1);\r\n    pCloneCube = pCube | '_Clone';\r\n    nIncludeRules = IF(pIncludeRules = 1 % pIncludeRules = 2, 1, 0);\r\n    nSuppressRules = IF(nIncludeRules = 1,  1, 0);\r\n\r\n    sProc = '}bedrock.cube.clone';\r\n    nRet = EXECUTEPROCESS( sProc,\r\n        'pLogOutput', pLogOutput,\r\n        'pStrictErrorHandling', pStrictErrorHandling,\r\n        'pSrcCube', pCube,\r\n        'pTgtCube', pCloneCube,\r\n        'pIncludeRules', nIncludeRules,\r\n        'pIncludeData', pIncludeData,\r\n        'pSuppressRules', nSuppressRules,\r\n        'pTemp', pTemp,\r\n        'pCubeLogging', 0\r\n        );\r\n\r\n    IF(nRet <> 0);\r\n        sMessage = 'Error creating cloned cube for keeping data.';\r\n        nErrors = nErrors + 1;\r\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n        If( pStrictErrorHandling = 1 );\r\n            ProcessQuit;\r\n        Else;\r\n            ProcessBreak;\r\n        EndIf;\r\n    ENDIF;\r\n\r\nEndif;\r\n\r\n#Processbreak;\r\n\r\n# recreate the cube\r\nsProc = '}bedrock.cube.create';\r\nnRet = ExecuteProcess( sProc,\r\n    'pLogOutput', pLogOutput,\r\n    'pStrictErrorHandling', pStrictErrorHandling,\r\n    'pCube', pCube,\r\n    'pDims', sDimString,\r\n    'pRecreate', 1,\r\n    'pDelim', sDelim\r\n    );\r\n\r\nIF(nRet <> 0);\r\n    sMessage = Expand('Error recreating the cube: %pCube%.');\r\n    nErrors = nErrors + 1;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n    If( pStrictErrorHandling = 1 );\r\n        ProcessQuit;\r\n    Else;\r\n        ProcessBreak;\r\n    EndIf;\r\nENDIF;\r\n\r\n#Processbreak;\r\n\r\n# copy back the data\r\nIF(pIncludeData = 1);\r\n    sProc = '}bedrock.cube.data.copy.intercube';\r\n    nRet = ExecuteProcess( sProc,\r\n        'pLogOutput', pLogOutput,\r\n        'pStrictErrorHandling', pStrictErrorHandling,\r\n        'pSrcCube', pCloneCube,\r\n        'pFilter', '',\r\n        'pTgtCube', pCube,\r\n        'pMappingToNewDims', '',\r\n        'pSuppressConsol', 1,\r\n        'pSuppressRules', nSuppressRules,\r\n        'pZeroSource', 0,\r\n        'pZeroTarget', 0,\r\n        'pFactor', 1,\r\n        'pTemp', pTemp,\r\n        'pCubeLogging', 0\r\n        );\r\n\r\n    IF(nRet <> 0);\r\n        sMessage = Expand('Error copying back the data from clone cube: %pCloneCube%.');\r\n        nErrors = nErrors + 1;\r\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n        If( pStrictErrorHandling = 1 );\r\n            ProcessQuit;\r\n        Else;\r\n            ProcessBreak;\r\n        EndIf;\r\n    ENDIF;\r\n\r\n    # destroy clone cube\r\n    IF(pTemp=1);\r\n        sProc = '}bedrock.cube.delete';\r\n        nRet = EXECUTEPROCESS( sProc,\r\n        'pLogOutput', pLogOutput,\r\n        'pStrictErrorHandling', pStrictErrorHandling,\r\n        'pCube', pCloneCube,\r\n        'pCtrlObj', 0\r\n        );\r\n\r\n        IF(nRet <> 0);\r\n            sMessage = Expand('Error deleting cloned cube: %pCloneCube%.');\r\n            nErrors = nErrors + 1;\r\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n            If( pStrictErrorHandling = 1 );\r\n                ProcessQuit;\r\n            Else;\r\n                ProcessBreak;\r\n            EndIf;\r\n        ENDIF;\r\n    Endif;\r\n\r\nEndif;\r\n\r\n# reload the rule\r\nIF(pIncludeRules = 2);\r\n\r\n  sProc = '}bedrock.cube.rule.manage';\r\n\r\n  nRet = EXECUTEPROCESS( sProc,\r\n    'pLogOutput', pLogOutput,\r\n    'pStrictErrorHandling', pStrictErrorHandling,\r\n    'pCube', pCube,\r\n    'pMode', 'LOAD'\r\n    );\r\n\r\n  IF(nRet <> 0);\r\n    sMessage = Expand('Error reloading the rule for %pCube%.');\r\n    nErrors = nErrors + 1;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n    # Create error rule file\r\n    cErrorRuleName = 'ErrorRuleFile.rux';\r\n\r\n    IF(FileExists( cErrorRuleName ) = 0 );\r\n      sFile = '.' | sOSDelim | cErrorRuleName;\r\n      LogOutput(cMsgErrorLevel, 'Rule could not be attached due to invalid !Dimension references. Please recover from the backup and fix manually.');\r\n    ENDIF;\r\n\r\n    EXECUTEPROCESS( sProc,\r\n    'pLogOutput', pLogOutput,\r\n    'pStrictErrorHandling', pStrictErrorHandling,\r\n    'pCube', pCube,\r\n    'pFileName', cErrorRuleName,\r\n    'pMode', 'LOAD'\r\n    );\r\n    If( pStrictErrorHandling = 1 );\r\n        ProcessQuit;\r\n    Else;\r\n        ProcessBreak;\r\n    EndIf;\r\n  ENDIF;\r\n\r\nEndif;\r\n\r\n### End Prolog ###",
    "Variables": []
}