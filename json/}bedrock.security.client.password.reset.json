{
    "DataProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n",
    "DataSource": {
        "Type": "None"
    },
    "EpilogProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n#################################################################################################\r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock Ver 4.0~~##\r\n#################################################################################################\r\n\r\n### Return code & final error message handling\r\nIf( nErrors > 0 );\r\n    sMessage = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\r\n    nProcessReturnCode = 0;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\r\n    If( pStrictErrorHandling = 1 );\r\n        ProcessQuit;\r\n    EndIf;\r\nElse;\r\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully reset password for client %pClient% .' );\r\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\r\n    nProcessReturnCode = 1;\r\n    If( pLogoutput = 1 );\r\n        LogOutput('INFO', Expand( sProcessAction ) );\r\n    EndIf;\r\nEndIf;\r\n\r\n### End Epilog ###",
    "HasSecurityAccess": true,
    "MetadataProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n",
    "Name": "}bedrock.security.client.password.reset",
    "Parameters": [
        {
            "Name": "pLogOutput",
            "Prompt": "OPTIONAL: Write parameters and action summary to server message log (Boolean True = 1)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pStrictErrorHandling",
            "Prompt": "OPTIONAL: On encountering any error exit with major error status by ProcessQuit after writing to the server message log (Boolean True = 1)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pClient",
            "Prompt": "REQUIRED: Clients (Separated by delimiter (e.g. Client1&Client2) Accepts Wild card (e.g. *Client*Client* Client*))",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pPassword",
            "Prompt": "REQUIRED: New Password",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pDelim",
            "Prompt": "OPTIONAL: Delimiter character (default value if blank = '&')",
            "Type": "String",
            "Value": "&"
        }
    ],
    "PrologProcedure": "#Region CallThisProcess\r\n# A snippet of code provided as an example how to call this process should the developer be working on a system without access to an editor with auto-complete.\r\nIf( 1 = 0 );\r\n    ExecuteProcess( '}bedrock.security.client.password.reset', 'pLogOutput', pLogOutput,\r\n      'pStrictErrorHandling', pStrictErrorHandling,\r\n\t    'pClient', '', 'pPassword', '', 'pDelim', '&'\r\n\t);\r\nEndIf;\r\n#EndRegion CallThisProcess\r\n\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n#################################################################################################\r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock Ver 4.0~~##\r\n#################################################################################################\r\n\r\n#Region @DOC\r\n# Description:\r\n# This process can be used by admins to reset a client password.\r\n\r\n# Use case: Intended for production.\r\n# 1/ When a user has forgotten his/her password this TI can be used to reset it.\r\n\r\n# Note:\r\n# Naturally, a valid client(s) (pClient) is mandatory otherwise the process will abort.\r\n# Multiple clients can be specified separated by a delimiter.\r\n# It has to be run by an ADMIN person otherwsie it will abort.\r\n#EndRegion @DOC\r\n\r\n##Global Variables\r\nStringGlobalVariable('sProcessReturnCode');\r\nNumericGlobalVariable('nProcessReturnCode');\r\nnProcessReturnCode= 0;\r\n\r\n### Constants ###\r\ncThisProcName       = GetProcessName();\r\ncUserName           = TM1User();\r\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\r\ncRandomInt          = NumberToString( INT( RAND( ) * 1000 ));\r\ncTempSub            = cThisProcName | '_' | cTimeStamp | '_' | cRandomInt;\r\ncTempFile           = GetProcessErrorFileDirectory | cTempSub | '.csv';\r\ncClientDim          = '}Clients';\r\ncClientHier         = cClientDim;\r\ncMsgErrorLevel      = 'ERROR';\r\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\r\ncLogInfo            = 'Process:%cThisProcName% run with parameters pClient:%pClient%, pPassword:******, pDelim:%pDelim%.' ;\r\n\r\n### Validate Parameters ###\r\nnErrors             = 0;\r\n\r\n# If blank delimiter specified then convert to default\r\nIf( pDelim @= '' );\r\n    pDelim = '&';\r\nEndIf;\r\n\r\n# If no clients have been specified then terminate process\r\nIf( Trim( pClient ) @= '' );\r\n    nErrors = 1;\r\n    sMessage = 'No clients specified.';\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\n# Check if the person executing the process has admin rights\r\n\r\nIF( CELLGETS( '}ClientGroups', cUserName, 'Admin' ) @<> 'ADMIN' & CELLGETS( '}ClientGroups', cUserName, 'DataAdmin' ) @<> 'DataAdmin' & cUserName @<> pClient );\r\n    nErrors = 1;\r\n    sMessage = 'No Admin access to change other clients password.';\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nENDIF;\r\n\r\n### Check for errors before continuing\r\nIf( nErrors > 0 );\r\n  If( pStrictErrorHandling = 1 );\r\n      ProcessQuit;\r\n  Else;\r\n      ProcessBreak;\r\n  EndIf;\r\nEndIf;\r\n\r\n### Split pClient into individual clients and reset password ###\r\n\r\nsClients = pClient;\r\nnDelimiterIndex = 1;\r\n\r\nWhile( nDelimiterIndex <> 0 );\r\n  nDelimiterIndex = Scan( pDelim, sClients );\r\n  If( nDelimiterIndex = 0 );\r\n    sClient = sClients;\r\n  Else;\r\n    sClient = Trim( SubSt( sClients, 1, nDelimiterIndex - 1 ) );\r\n    sClients = Trim( Subst( sClients, nDelimiterIndex + Long(pDelim), Long( sClients ) ) );\r\n  EndIf;\r\n\r\n  If(Scan('*',sClient) = 0);\r\n  # Don't attempt to update a blank client\r\n    If( sClient @<> '' );\r\n      If( DimIx( '}Clients', sClient ) <> 0 );\r\n        If( nErrors = 0 );\r\n          sClient = DimensionElementPrincipalName( '}Clients', sClient );\r\n          AssignClientPassword( sClient, pPassword );\r\n        EndIf;\r\n      EndIf;\r\n    EndIf;\r\n  Else;\r\n    # Wildcard search string\r\n    iCount = 0;\r\n    iCheck = 1;\r\n    sChar = sClient;\r\n    While (iCheck > 0);\r\n      iCheck = Scan('*',sChar);\r\n      If( iCheck > 0 );\r\n        iCount = iCount + 1;\r\n        sChar = Subst(sChar,iCheck+1,(long(sChar)-iCheck));\r\n      Endif;\r\n    End;\r\n    If(iCount = 1);\r\n      ##If the wilcardsearch is *String, below code will get executed\r\n      if(Subst(sClient,iCount,1) @= '*');\r\n        sClient1 = '\"'| Subst(sClient,iCount+1,(Long(sClient)- iCount))|'\"';\r\n        sTempCount = NumbertoString(Long(sClient)-iCount);\r\n        sMdx = '{FILTER({TM1SUBSETALL(['|cClientDim|':'|cClientHier|'])},\r\n                (Right( ['|cClientDim|':'|cClientHier|'].[}TM1_DefaultDisplayValue],'| sTempCount|') ='|sClient1|'))}';\r\n        If( SubsetExists( cClientDim, cTempSub ) = 1 );\r\n            # If a delimited list of client names includes wildcards then we may have to re-use the subset multiple times\r\n            SubsetMDXSet( cClientDim, cTempSub, sMDX );\r\n        Else;\r\n            # temp subset, therefore no need to destroy in epilog\r\n            SubsetCreatebyMDX( cTempSub, sMDX, cClientDim, 1 );\r\n        EndIf;\r\n\r\n        nCount = 1;\r\n        nHier_Sub_Size = HierarchySubsetGetSize(cClientDim, cClientHier, cTempSub);\r\n        While (nCount <= nHier_Sub_Size);\r\n          nSubsetIndex = 1;\r\n          sTemp = HierarchySubsetElementGetIndex (cClientDim, cClientHier, cTempSub, '', nSubsetIndex);\r\n          sElement = HierarchySubsetGetElementName(cClientDim, cClientHier, cTempSub, nCount);\r\n          AssignClientPassword(sElement,pPassword);\r\n          nCount = nCount +1;\r\n        End;\r\n        ##If the wilcardsearch is String*, below code will get executed\r\n        ElseIf(Subst(sClient,Long(sClient),1) @= '*');\r\n\r\n        sClient1 = '\"'| Subst(sClient,iCount,(Long(sClient)- iCount))|'\"';\r\n        sMdx = '{FILTER({TM1SUBSETALL(['|cClientDim|':'|cClientHier|'])},\r\n                (INSTR('| NumbertoString(iCount)|', ['|cClientDim|':'|cClientHier|'].[}TM1_DefaultDisplayValue],'|sClient1|') ='| NumbertoString(iCount)|'))}';\r\n        If( SubsetExists( cClientDim, cTempSub ) = 1 );\r\n            # If a delimited list of client names includes wildcards then we may have to re-use the subset multiple times\r\n            SubsetMDXSet( cClientDim, cTempSub, sMDX );\r\n        Else;\r\n            # temp subset, therefore no need to destroy in epilog\r\n            SubsetCreatebyMDX( cTempSub, sMDX, cClientDim, 1 );\r\n        EndIf;\r\n\r\n        nCount = 1;\r\n        nHier_Sub_Size = HierarchySubsetGetSize(cClientDim, cClientHier, cTempSub);\r\n        While (nCount <= nHier_Sub_Size);\r\n          nSubsetIndex = 1;\r\n          sTemp = HierarchySubsetElementGetIndex (cClientDim, cClientHier, cTempSub, '', nSubsetIndex);\r\n          sElement = HierarchySubsetGetElementName(cClientDim, cClientHier, cTempSub, nCount);\r\n          AssignClientPassword(sElement,pPassword);\r\n          nCount = nCount +1;\r\n        End;\r\n      Endif;\r\n    Else;\r\n      ##If the wilcardsearch is *String*, below code will get executed\r\n      sClient1 = '\"'| Subst(sClient,iCount,(Long(sClient)- iCount))|'\"';\r\n      sMdx = '{FILTER({TM1SUBSETALL(['|cClientDim|':'|cClientHier|'])},\r\n              (INSTR(1,['|cClientDim|':'|cClientHier|'].[}TM1_DefaultDisplayValue],'|sClient1|') <> 0))}';\r\n      If( SubsetExists( cClientDim, cTempSub ) = 1 );\r\n            # If a delimited list of Client names includes wildcards then we may have to re-use the subset multiple times\r\n            SubsetMDXSet( cClientDim, cTempSub, sMDX );\r\n      Else;\r\n            # temp subset, therefore no need to destroy in epilog\r\n            SubsetCreatebyMDX( cTempSub, sMDX, cClientDim, 1 );\r\n      EndIf;\r\n\r\n      nCount = 1;\r\n      nHier_Sub_Size = HierarchySubsetGetSize(cClientDim, cClientHier, cTempSub);\r\n      While (nCount <= nHier_Sub_Size);\r\n        nSubsetIndex = 1;\r\n        sTemp = HierarchySubsetElementGetIndex (cClientDim, cClientHier, cTempSub, '', nSubsetIndex);\r\n        sElement = HierarchySubsetGetElementName(cClientDim, cClientHier, cTempSub, nCount);\r\n        AssignClientPassword(sElement,pPassword);\r\n        nCount = nCount +1;\r\n      End;\r\n    Endif;\r\n  EndIf;\r\nEnd;\r\n\r\n\r\n### End Prolog ###",
    "Variables": []
}