{
    "DataProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n\r\n### Check for errors in prolog ###\r\nIf( nErrors <> 0 );\r\n  If( pStrictErrorHandling = 1 );\r\n      ProcessQuit;\r\n  Else;\r\n      ProcessBreak;\r\n  EndIf;\r\nEndIf;\r\n\r\n\r\n### Replicate Attributes ###\r\n\r\n# Note: DTYPE on Attr dim returns \"AS\", \"AN\" or \"AA\" need to strip off leading \"A\"\r\n\r\nIf( pAttr = 1 );\r\n\r\n    nCount = 1;\r\n    While( nCount <= nNumAttrs );\r\n        sAttrName = DimNm( sAttrDim, nCount );\r\n        sAttrType = SubSt( DTYPE( sAttrDim, sAttrName ), 2, 1 );\r\n        If( sAttrType @= 'S' % sAttrType @= 'A' );\r\n            sAttrVal = ElementAttrS(pSrcDim, pSrcHier, vElement, sAttrName);\r\n            If( sAttrVal @<> '' );\r\n                ElementAttrPutS( sAttrVal, pTgtDim,pTgtHier, vElement, sAttrName,1 );\r\n            EndIf;\r\n        Else;\r\n            nAttrVal = ElementAttrN(pSrcDim, pSrcHier, vElement, sAttrName);\r\n            If( nAttrVal <> 0 );\r\n                ElementAttrPutN( nAttrVal, pTgtDim, pTgtHier, vElement, sAttrName );\r\n            EndIf;\r\n        EndIf;\r\n        nCount = nCount + 1;\r\n    End;\r\n\r\n  EndIf;\r\n\r\n### End Data ###",
    "DataSource": {
        "Type": "?",
        "asciiDecimalSeparator": ".",
        "asciiDelimiterChar": ",",
        "asciiHeaderRecords": 0,
        "asciiQuoteCharacter": "\"",
        "asciiThousandSeparator": ",",
        "dataSourceNameForClient": "}Cubes",
        "dataSourceNameForServer": "}Cubes"
    },
    "EpilogProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n### Set Target dimension sort order ###\r\n\r\nIf(pSrcDim @= pSrcHier);\r\n    sSourceElement = pSrcDim;\r\nElse;\r\n    sSourceElement = pSrcDim|':'|pSrcHier;\r\nEndif;\r\nIf(pTgtDim @= pTgtHier);\r\n    sTargetElement = pTgtDim;\r\nElse;\r\n    sTargetElement = pTgtDim|':'|pTgtHier;\r\nEndif;\r\n\r\nsCube = '}DimensionProperties';\r\nIF(CubeExists ( sCube ) = 1 );\r\n  sEleMapping = '}Dimensions' |'\u00a6'|sSourceElement|'->'|sTargetElement;\r\n  ExecuteProcess( '}bedrock.cube.data.copy',\r\n  'pLogOutput', pLogOutput,\r\n  'pStrictErrorHandling', pStrictErrorHandling,\r\n  'pCube', sCube,\r\n  'pSrcView', '',\r\n  'pTgtView', '',\r\n  'pFilter',  '',\r\n  'pEleMapping', sEleMapping,\r\n  'pMappingDelim','->',\r\n  'pFactor', 1,\r\n  'pDimDelim', '&',\r\n  'pEleStartDelim', '\u00a6',\r\n  'pEleDelim', '+',\r\n  'pSuppressRules', 0 ,\r\n  'pCumulate', 0 ,\r\n  'pZeroSource', 0,\r\n  'pZeroTarget', 1,\r\n  'pTemp', 1\r\n   );\r\nENDIF;\r\n\r\nsCube = '}HierarchyProperties';\r\nIF(CubeExists ( sCube ) = 1 );\r\n  sEleMapping = '}Dimensions' |'\u00a6'|sSourceElement|'->'|sTargetElement;\r\n  ExecuteProcess( '}bedrock.cube.data.copy',\r\n  'pLogOutput', pLogOutput,\r\n  'pStrictErrorHandling', pStrictErrorHandling,\r\n  'pCube', sCube,\r\n  'pSrcView', '',\r\n  'pTgtView', '',\r\n  'pFilter',  '',\r\n  'pEleMapping', sEleMapping,\r\n  'pMappingDelim','->',\r\n  'pFactor', 1,\r\n  'pDimDelim', '&',\r\n  'pEleStartDelim', '\u00a6',\r\n  'pEleDelim', '+',\r\n  'pSuppressRules', 0 ,\r\n  'pCumulate', 0 ,\r\n  'pZeroSource', 0,\r\n  'pZeroTarget', 1,\r\n  'pTemp', 1\r\n   );\r\nENDIF;\r\n\r\n\r\n### Set Descendent attribute value\r\nAttrDelete( pSrcDim, cHierAttr );\r\nIf( pAttr = 1 );\r\n    AttrDelete( pTgtDim, cHierAttr );\r\nENDIF;\r\n\r\n### Return code & final error message handling\r\nIf( nErrors > 0 );\r\n    sMessage = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\r\n    nProcessReturnCode = 0;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\r\n    If( pStrictErrorHandling = 1 );\r\n        ProcessQuit;\r\n    EndIf;\r\nElse;\r\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully cloned dimension:hierarchy %pSrcDim%:%pSrcHier% to %pTgtDim%:%pTgtHier% based on the %pSubset% subset.' );\r\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\r\n    nProcessReturnCode = 1;\r\n    If( pLogoutput = 1 );\r\n        LogOutput('INFO', Expand( sProcessAction ) );\r\n    EndIf;\r\nEndIf;\r\n\r\n### End Epilog ###",
    "HasSecurityAccess": true,
    "MetadataProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n### Check for errors in prolog ###\r\nIf( nErrors <> 0 );\r\n  If( pStrictErrorHandling = 1 );\r\n      ProcessQuit;\r\n  Else;\r\n      ProcessBreak;\r\n  EndIf;\r\nEndIf;\r\n\r\nIf (pFlat = 1);\r\n    ##Creating the Flat hierarchy subset in the target dimension\r\n    sElType = ElementType(pSrcDim, pSrcHier, vElement);\r\n    ## Add the element to the target dimension.\r\n    ## 'C' elements can't be inserted as 'N' elements in the same dimension\r\n    IF(pTgtdim @= pSrcDim);\r\n        IF(sElType @<> 'C' );\r\n            HierarchyElementInsert( pTgtDim, pTgtHier, '', vElement, sElType );\r\n        Else;\r\n            If( pLogOutput = 1 );\r\n                sMessage = 'Name conflict! Cannot create leaf element %vElement% in dimension %pTgtDim% as C element with same name already exists.';\r\n                LogOutput( 'WARN', Expand( cMsgErrorContent ) );\r\n            EndIf;\r\n        EndIf;\r\n    Else;\r\n        IF(sElType @= 'C' );\r\n            HierarchyElementInsert( pTgtDim, pTgtHier, '', vElement, 'N' );\r\n        Else;\r\n            HierarchyElementInsert( pTgtDim, pTgtHier, '', vElement, sElType );\r\n        EndIf;\r\n    EndIf;\r\nElse;\r\n    nIndex = 1;\r\n    nLimit = ElementComponentCount( pSrcDim, pSrcHier, vElement );\r\n    WHILE( nIndex <= nLimit );\r\n        sElName = ElementComponent( pSrcDim, pSrcHier, vElement, nIndex );\r\n        sDecendant = ElementAttrS(pSrcDim, pSrcHier, sElName, cHierAttr);\r\n        IF(\r\n            sDecendant @= cAttrVal);\r\n            nElWeight = ElementWeight( pSrcDim, pSrcHier, vElement, sElName );\r\n            HierarchyElementComponentAdd( pTgtDim, pTgtHier, vElement, sElName, nElWeight );\r\n        ENDIF;\r\n        nIndex = nIndex + 1;\r\n    END;\r\nEndif;\r\n\r\n### End MetaData ###",
    "Name": "}bedrock.hier.create.fromsubset",
    "Parameters": [
        {
            "Name": "pLogOutput",
            "Prompt": "OPTIONAL: Write parameters and action summary to server message log (Boolean True = 1)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pStrictErrorHandling",
            "Prompt": "OPTIONAL: On encountering any error exit with major error status by ProcessQuit after writing to the server message log (Boolean True = 1)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pSrcDim",
            "Prompt": "REQUIRED: Source Dimension",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pSrcHier",
            "Prompt": "OPTIONAL: Source Hierarchy (blank = same name as source dimension)",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pSubset",
            "Prompt": "REQUIRED: Source Subset",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pTgtDim",
            "Prompt": "OPTIONAL: Target Dimension (blank = same name as source dimension)",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pTgtHier",
            "Prompt": "OPTIONAL: Target Hierarchy (blank = same name as target dimension)",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pAttr",
            "Prompt": "OPTIONAL: Include Attributes? (Boolean 1=True)",
            "Type": "Numeric",
            "Value": "1"
        },
        {
            "Name": "pUnwind",
            "Prompt": "OPTIONAL: 0 = Delete all Elements 1 = Unwind Existing Elements 2 = Do not change Existing Elements",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pFlat",
            "Prompt": "OPTIONAL: Whether to create flat hierarchy? (1 = Yes 0 = No)",
            "Type": "Numeric",
            "Value": "0"
        }
    ],
    "PrologProcedure": "#Region CallThisProcess\r\n# A snippet of code provided as an example how to call this process should the developer be working on a system without access to an editor with auto-complete.\r\nIf( 1 = 0 );\r\n    ExecuteProcess( '}bedrock.hier.create.fromsubset', 'pLogOutput', pLogOutput,\r\n      'pStrictErrorHandling', pStrictErrorHandling,\r\n    \t'pSrcDim', '', 'pSrcHier', '', 'pSubset', '',\r\n    \t'pTgtDim', '', 'pTgtHier', '',\r\n    \t'pAttr', 1, 'pUnwind', 0, 'pFlat', 0\r\n\t);\r\nEndIf;\r\n#EndRegion CallThisProcess\r\n\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n#################################################################################################\r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock Ver 4~~##\r\n#################################################################################################\r\n\r\n#Region @DOC\r\n# Description:\r\n# This process will make a copy of an existing dimension subset, creating it as a new dimension hierarchy.\r\n\r\n# Use case: Intended for Development but could be used in production too.\r\n# 1. Create a new hierarchy for testing.\r\n# 2. Create a new hierarchy to reflect new business needs.\r\n\r\n# Note:\r\n# Valid source dimension name (pSrcDim) and source subset (pSubset) are mandatory, otherwise the process will abort.\r\n# If a source hierarchy name (pSrcHier) is specified, it needs to be valid, otherwise the process will abort.\r\n\r\n# Caution:\r\n# - Target hierarchy cannot be Leaves.\r\n# - If the target Hierarchy already exists, then it will be overwritten.\r\n#EndRegion @DOC\r\n\r\n### Global Variables\r\nStringGlobalVariable ('sProcessReturnCode');\r\nNumericGlobalVariable('nProcessReturnCode');\r\nnProcessReturnCode = 0;\r\n\r\n### Constants ###\r\ncThisProcName     = GetProcessName();\r\ncUserName         = TM1User();\r\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\r\ncRandomInt        = NumberToString( INT( RAND( ) * 1000 ));\r\ncTempSub          = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\r\ncMsgErrorLevel    = 'ERROR';\r\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\r\ncLogInfo          = 'Process:%cThisProcName% run with parameters pSrcDim:%pSrcDim%, pSrcHier:%pSrcHier%, pSubset:%pSubset%, pTgtDim:%pTgtDim%, pTgtHier:%pTgtHier%, pAttr:%pAttr%, pUnwind:%pUnwind%, pFlat:%pFlat%.';\r\ncHierAttr         = 'Bedrock.Descendant';\r\ncAttrVal          = 'Descendant';\r\n\r\n## LogOutput parameters\r\nIF ( pLogoutput = 1 );\r\n  LogOutput('INFO', Expand( cLogInfo ) );\r\nENDIF;\r\n\r\n### Validate Parameters ###\r\nnErrors = 0;\r\nIf( Scan( ':', pSrcDim ) > 0 & pSrcHier @= '' );\r\n    # A hierarchy has been passed as dimension. Handle the input error by splitting dim:hier into dimension & hierarchy\r\n    pSrcHier       = SubSt( pSrcDim, Scan( ':', pSrcDim ) + 1, Long( pSrcDim ) );\r\n    pSrcDim        = SubSt( pSrcDim, 1, Scan( ':', pSrcDim ) - 1 );\r\nEndIf;\r\n\r\nIf( Scan( ':', pTgtDim ) > 0 & pTgtHier @= '' );\r\n    # A hierarchy has been passed as dimension. Handle the input error by splitting dim:hier into dimension & hierarchy\r\n    pTgtHier       = SubSt( pTgtDim, Scan( ':', pTgtDim ) + 1, Long( pTgtDim ) );\r\n    pTgtDim        = SubSt( pTgtDim, 1, Scan( ':', pTgtDim ) - 1 );\r\nEndIf;\r\n\r\n# Validate source dimension\r\nIF( Trim( pSrcDim ) @= '' );\r\n    nErrors = 1;\r\n    sMessage = 'No source dimension specified.';\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\nIF( DimensionExists( pSrcDim ) = 0 );\r\n    nErrors = 1;\r\n    sMessage = 'Invalid source dimension: ' | pSrcDim;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\n### Check for errors before continuing\r\nIf( nErrors <> 0 );\r\n   If( pStrictErrorHandling = 1 );\r\n      ProcessQuit;\r\n  Else;\r\n      ProcessBreak;\r\n  EndIf;\r\nEndIf;\r\n\r\n# Validate source Hierarchy\r\nIF(pSrcHier @= '');\r\n    pSrcHier = pSrcDim;\r\nElseIf(HierarchyExists(pSrcDim, pSrcHier) = 0);\r\n    nErrors = 1;\r\n    sMessage = 'Invalid source hierarchy: ' | pSrcHier;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndif;\r\n\r\n## Validate Source Subset\r\nIF(HierarchySubsetExists( pSrcDim, pSrcHier, pSubset) = 0 );\r\n    sMessage = 'No valid source subset: ' | pSubset;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nELSE;\r\n    cSubset = pSubset;\r\nENDIF;\r\n\r\n### Check for errors before continuing\r\nIf( nErrors <> 0 );\r\n  If( pStrictErrorHandling = 1 );\r\n      ProcessQuit;\r\n  Else;\r\n      ProcessBreak;\r\n  EndIf;\r\nEndIf;\r\n\r\n## Validate target Dimension\r\nIf(pTgtDim @= '');\r\n    pTgtDim = pSrcDim;\r\nEndif;\r\n\r\nIF( DimensionExists( pTgtDim ) = 0 );\r\n   DimensionCreate(pTgtDim);\r\nEndIf;\r\n\r\n### Create target dimension Hierarchy ###\r\nIF(pTgtHier @= '');\r\n    pTgtHier = pTgtDim;\r\nEndIf;\r\n\r\n\r\nIf( HierarchyExists(pTgtDim, pTgtHier) = 0 );\r\n    HierarchyCreate( pTgtDim, pTgtHier );\r\nElse;\r\n    IF(pUnwind = 1 );\r\n        ExecuteProcess( '}bedrock.hier.unwind', 'pLogOutput', 0,\r\n            'pStrictErrorHandling', pStrictErrorHandling,\r\n            'pDim', pTgtDim, 'pHier', pTgtHier, 'pConsol', '*',\r\n            'pRecursive', 1\r\n        );\r\n    ELSEIF(\r\n        pUnwind = 2 );\r\n        #Do nothing\r\n    ELSE;\r\n        HierarchyDeleteAllElements( pTgtDim, pTgtHier );\r\n    EndIf;\r\nEndIf;\r\n\r\n### Assign Data Source ###\r\nDatasourceNameForServer = pSrcDim|':'|pSrcHier;\r\nDatasourceNameForClient = pSrcDim|':'|pSrcHier;\r\nDataSourceType = 'SUBSET';\r\nDatasourceDimensionSubset = cSubset;\r\n\r\n### Set Descendent attribute value\r\nAttrDelete( pSrcDim, cHierAttr );\r\nAttrInsert( pSrcDim, '', cHierAttr, 'S' );\r\n\r\n# Disable excessive transaction logging of the attributes cube if it is logged\r\nsAttrCube = '}ElementAttributes_' | pSrcDim;\r\nnAttrCubeLogChanges = CubeGetLogChanges(sAttrCube);\r\nIf( nAttrCubeLogChanges = 1 );\r\n   CubeSetLogChanges( sAttrCube, 0 );\r\nEndIf;\r\n\r\nnIndex = 1;\r\nnLimit = HierarchySubsetGetSize( pSrcDim, pSrcHier, pSubset );\r\nWHILE( nIndex <= nLimit);\r\n    sElName = SubsetGetElementName( pSrcDim|':'|pSrcHier, pSubset, nIndex );\r\n    ElementAttrPuts( cAttrVal, pSrcDim, pSrcHier, sElName, cHierAttr );\r\n    sElType = ElementType( pSrcDim, pSrcHier, sElName );\r\n    HierarchyElementInsert(pTgtDim, pTgtHier, '',sElName, sELType);\r\n    nIndex = nIndex + 1;\r\nEND;\r\n\r\n# Re-enable transaction logging setting of the attributes cube if required\r\nIf( nAttrCubeLogChanges = 1 );\r\n   CubeSetLogChanges( sAttrCube, 1 );\r\nEndIf;\r\n\r\n### Replicate Attributes ###\r\n# Note: DType on Attr dim returns \"AS\", \"AN\" or \"AA\" need to strip off leading \"A\"\r\n\r\nsAttrDim = '}ElementAttributes_' | pSrcDim;\r\nsLastAttr = '';\r\nIf( pAttr = 1 & DimensionExists( sAttrDim ) = 1 );\r\n    nNumAttrs = DimSiz( sAttrDim );\r\n    nCount = 1;\r\n    While( nCount <= nNumAttrs );\r\n        sAttrName = DimNm( sAttrDim, nCount );\r\n        sAttrType = SubSt(DType( sAttrDim, sAttrName ), 2, 1 );\r\n        AttrInsert( pTgtDim, sLastAttr, sAttrName, sAttrType );\r\n        sLastAttr = sAttrName;\r\n        nCount = nCount + 1;\r\n    End;\r\nEndIf;\r\n\r\n### End Prolog ###\r\n573,50",
    "UIData": "CubeAction=1511\fDataAction=1503\fCubeLogChanges=0\f",
    "Variables": [
        {
            "EndByte": 0,
            "Name": "vElement",
            "Position": 1,
            "StartByte": 0,
            "Type": "String"
        }
    ],
    "VariablesUIData": []
}