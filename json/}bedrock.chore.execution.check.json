{
    "DataProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****",
    "DataSource": {
        "Type": "None"
    },
    "EpilogProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n### Return code & final error message handling\r\nIf( nErrors > 0 );\r\n    sMessage = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\r\n    nProcessReturnCode = 0;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\r\n    If( pStrictErrorHandling = 1 );\r\n        ProcessQuit;\r\n    EndIf;\r\nElse;\r\n    sProcessAction = Expand( 'Process:%cThisProcName% completed normally' );\r\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\r\n    nProcessReturnCode = 1;\r\n    If( pLogoutput = 1 );\r\n        LogOutput('INFO', Expand( sProcessAction ) );\r\n    EndIf;\r\nEndIf;\r\n\r\n### End Epilog ###",
    "HasSecurityAccess": true,
    "MetadataProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****",
    "Name": "}bedrock.chore.execution.check",
    "Parameters": [
        {
            "Name": "pLogOutput",
            "Prompt": "OPTIONAL: Write parameters and action summary to server message log (Boolean True = 1)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pStrictErrorHandling",
            "Prompt": "OPTIONAL: On encountering any error exit with major error status by ProcessQuit after writing to the server message log (Boolean True = 1)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pMonthDays",
            "Prompt": "OPTIONAL: Delimited string of days in month as dd e.g. 01 & 02 & 30 & 31 (Blank=All)",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pWeekDays",
            "Prompt": "OPTIONAL: Delimited string of days in week as ddd e.g. MON & WED (Blank=All)",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pDelim",
            "Prompt": "OPTIONAL: String array delimiter. Only 1 character allowed (Blank=&)",
            "Type": "String",
            "Value": "&"
        },
        {
            "Name": "pStartTime",
            "Prompt": "OPTIONAL: Time to start running chore from in 24 hr time (at start of hour) (Blank=0)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pEndTime",
            "Prompt": "OPTIONAL: Time to finish chore being able to start in 24 hr time (Blank=24)",
            "Type": "Numeric",
            "Value": "24"
        }
    ],
    "PrologProcedure": "#Region CallThisProcess\r\n# A snippet of code provided as an example how to call this process should the developer be working on a system without access to an editor with auto-complete.\r\nIf( 1 = 0 );\r\n    ExecuteProcess( '}bedrock.chore.execution.check', 'pLogOutput', pLogOutput,\r\n        'pStrictErrorHandling', pStrictErrorHandling,\r\n        'pMonthDays', '',\r\n        'pWeekDays', '',\r\n        'pDelim', '&',\r\n        'pStartTime', 0, 'pEndTime', 24\r\n    );\r\nEndIf;\r\n#EndRegion CallThisProcess\r\n\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n#################################################################################################\r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock Ver 4.0~~##\r\n#################################################################################################\r\n\r\n#Region @DOC\r\n# Description:\r\n# This TI was created to overcome the limited scheduling options in chores. In order to use this TI it has to be the 1st TI in the chore.\r\n# As an example, if you need to run a chore every Monday & Wednesday you would schedule it to run EVERY day but set the pWeekdays parameter to Mon & Wed.\r\n# The chore would then kick off every day but this TI will perform a ProcessExitByChoreQuit function on all days NOT mentioned in pWeekdays.\r\n\r\n# Use case: For productive systems.\r\n# 1. A chore should run every 30 minutes between 8am & 8pm on weekdays. Schedule chore for every 30 minutes and include this process 1st in chore with parameters pWeekDays=MON&TUE&WED&THU&FRI pStartTime=8 pEndTime=20.\r\n# 2. A chore should run only on 1st calendar day of each month. Schedule chore for daily execution and include this process 1st in chore with parameters pMonthDays=1.\r\n\r\n# Note:\r\n# * This process will quit a chore if any time-bound, weekday-bound or date-bound conditions which define when the chore should NOT run are met.\r\n# * Only the parameter(s) needed shoudl be specified.\r\n# * Only scheduled executions will be quit outside the parameters. The checks are bypassed if a chore is manually executed by a user. This is done by checking the TM1User function.\r\n# * Time conditions are checked using these parameters in the following order of priority.\r\n#   1. pMonthDays : Days in month when chore is allowed to run. Enter delimited list of days e.g. 1&2&30&31 (blank = no restriction on allowed days of month).\r\n#   2. pWeekDays : Days in week when chore is allowed to run Enter delimited list of weekdays e.g. MON&FRI (blank = no restriction on allowed weekdays).\r\n#   3. pStartTime & pEndTime : Time of day when chore is allowed to run e.g. pStartTime=7, pEndTime=22 execution will be allowed between 7AM & 10PM ( blank = no time-bound restrictionss).\r\n#EndRegion @DOC\r\n\r\n### Global Variables\r\nStringGlobalVariable('sProcessReturnCode');\r\nNumericGlobalVariable('nProcessReturnCode');\r\nnProcessReturnCode= 0;\r\n\r\n### Constants ###\r\ncThisProcName   = GetProcessName();\r\ncUserName       = TM1User();\r\ncTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\r\ncRandomInt      = NumberToString( INT( RAND( ) * 1000 ));\r\ncTempSub        = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\r\ncStartTime      = NumberToString( pStartTime );\r\ncEndTime        = NumberToString( pEndTime );\r\ncMsgErrorLevel  = 'ERROR';\r\ncMsgErrorContent= 'User:%cUserName% Process:%cThisProcName% Message: %sMsg%';\r\ncLogInfo        = 'User:%cUserName% Process:%cThisProcName% run to check if chore should run with parameters pMonthDays:%pMonthDays%, pWeekDays:%pWeekDays%, pDelim:%pDelim%, pStartTime:%cStartTime%, pEndTime:%cEndTime%.' ;\r\nnErrors         = 0;\r\nsMsg            = '';\r\n\r\n## LogOutput parameters\r\nIF( pLogoutput = 1 );\r\n    LogOutput('INFO', Expand( cLogInfo ) );\r\nEndIf;\r\n\r\n### Check params\r\nIf( pDelim @= '' );\r\n    pDelim = '&';\r\nElse;\r\n    pDelim = SubSt( pDelim, 1, 1 );\r\nEndIf;\r\n\r\nIf( pMonthDays @= 'ALL' );\r\n    pMonthDays = '';\r\nEndIf;\r\nIf( pMonthDays @<> '' );\r\n    If( SubSt( pMonthDays, Long( pMonthDays ), 1 ) @<> pDelim );\r\n        pMonthDays = pMonthDays | pDelim;\r\n    EndIf;\r\nEndIf;\r\n\r\nIf( pWeekDays @= 'ALL' );\r\n    pWeekDays = '';\r\nEndIf;\r\nIf( pWeekDays @<> '' );\r\n    pWeekDays = Upper( pWeekDays );\r\n    If( SubSt( pWeekDays, Long( pWeekDays ), 1 ) @<> pDelim );\r\n        pWeekDays = pWeekDays | pDelim;\r\n    EndIf;\r\nEndIf;\r\n\r\nIf( pStartTime <= 0 % pStartTime > 24 );\r\n    pStartTime = 0;\r\nElse;\r\n    pStartTime = Round(pStartTime);\r\nEndIf;\r\nsStartTime = NumberToString( pStartTime );\r\n\r\nIf( pEndTime <= 0 % pEndTime > 24 );\r\n    pEndTime = 24;\r\nElse;\r\n    pEndTime = Round(pEndTime);\r\nEndIf;\r\n\r\nIf( pEndTime < pStartTime );\r\n    pEndTime = pStartTime;\r\nEndIf;\r\nsEndTime = NumberToString( pEndTime );\r\n\r\n### Initialize quit Boolean\r\nbQuit = 0;\r\n\r\n### Check the user\r\nIf( DIMIX( '}Clients', cUserName ) > 0 );\r\n    If( pLogOutput >= 1 );\r\n        sMsg = 'This chore will NOT quit since executed by a user.';\r\n        LogOutput( 'INFO', Expand( cMsgErrorContent ) );\r\n    EndIf;\r\nElse;\r\n\r\n    ### Check the day of the month\r\n    If( pMonthDays @<> '' );\r\n        sDayInMonth = TimSt(Now, '\\d');\r\n        If( Scan( sDayInMonth | pDelim, pMonthDays ) = 0 & Scan( sDayInMonth |' '| pDelim, pMonthDays ) = 0 );\r\n            # could not find the day in the list of acceptable days\r\n            bQuit = 1;\r\n            sMsg = Expand('Bedrock debug %cThisProcName%: chore will quit. Could not find today %sDayInMonth% in list of acceptable days %pMonthDays%');\r\n            IF( pLogoutput = 1 ); LogOutput( 'INFO', sMsg ); EndIf;\r\n        Else;\r\n            sMsg = Expand('Bedrock debug %cThisProcName%: today %sDayInMonth% found in list of acceptable days %pMonthDays%');\r\n            IF( pLogoutput = 1 ); LogOutput( 'INFO', sMsg ); EndIf;\r\n        EndIF;\r\n    EndIf;\r\n\r\n    ### Check the day of the week\r\n    If( pWeekDays @<> '' );\r\n        nDayIndex = Mod( DayNo ( Today ) + 21915, 7 );\r\n        sWeekday = '';\r\n        If( nDayIndex = 0 );\r\n            sWeekday = 'SUN';\r\n        ElseIf( nDayIndex = 1 );\r\n            sWeekday = 'MON';\r\n        ElseIf( nDayIndex = 2 );\r\n            sWeekday = 'TUE';\r\n        ElseIf( nDayIndex = 3 );\r\n            sWeekday = 'WED';\r\n        ElseIf( nDayIndex = 4 );\r\n            sWeekday = 'THU';\r\n        ElseIf( nDayIndex = 5 );\r\n            sWeekday = 'FRI';\r\n        ElseIf( nDayIndex = 6 );\r\n            sWeekday = 'SAT';\r\n        EndIf;\r\n        If( Scan( sWeekday | pDelim, pWeekDays ) = 0 & Scan( sWeekday |' '| pDelim, pWeekDays ) = 0 );\r\n            # could not find the day in the list of acceptable days\r\n            bQuit = 1;\r\n            sMsg = Expand('Bedrock debug %cThisProcName%: chore will quit. Could not find today %sWeekday% in list of acceptable days %pWeekDays%');\r\n            IF( pLogoutput = 1 ); LogOutput( 'INFO', sMsg ); EndIf;\r\n        Else;\r\n            sMsg = Expand('Bedrock debug %cThisProcName%: today %sWeekday% found in list of acceptable days %pWeekDays%');\r\n            IF( pLogoutput = 1 ); LogOutput( 'INFO', sMsg ); EndIf;\r\n        EndIF;\r\n    EndIf;\r\n\r\n    ### Check the time of day\r\n    sMinute = TimSt(Now, '\\h:\\i');\r\n    vTimeNow = StringToNumber(SubSt(sMinute, 1, 2));\r\n    If( pStartTime = 0 & pEndTime = 24 );\r\n        # no time exclusion parameters are set\r\n    ElseIf( vTimeNow < pStartTime % vTimeNow >= pEndTime );\r\n        # we are in the exclusion zone do not execute chore\r\n        bQuit = 1;\r\n        sMsg = Expand('Bedrock debug %cThisProcName%: chore will quit. current time %sMinute% is outside the defined execution time from %sStartTime%:00 to %sEndTime%:00');\r\n        IF( pLogoutput = 1 ); LogOutput( 'INFO', sMsg ); EndIf;\r\n    Else;\r\n        # we are not in the exclusion zone, proceed as normal\r\n        sMsg = Expand('Bedrock debug %cThisProcName%: current time %sMinute% is within the defined execution time from %sStartTime%:00 to %sEndTime%:00');\r\n        IF( pLogoutput = 1 ); LogOutput( 'INFO', sMsg ); EndIf;\r\n    EndIF;\r\n\r\nEndIf;\r\n\r\n### Quit chore if quit conditions met\r\nIf( bQuit = 1 );\r\n    sMsg = Expand('Bedrock debug %cThisProcName%: terminated the chore for the reasons stated above.');\r\n    If( pLogoutput = 1 ); LogOutput( 'INFO' , Expand( cMsgErrorContent ) ); EndIf;\r\n    nProcessReturnCode = ProcessExitByChoreQuit();\r\n    sProcessReturnCode = 'ProcessExitByChoreQuit';\r\n    ChoreQuit;\r\nElse;\r\n    ### Return Code\r\n    sProcessAction      = Expand('Bedrock debug %cThisProcName%: validated the chore to run as normal.');\r\n    sProcessReturnCode  = Expand( '%sProcessReturnCode% %sProcessAction%' );\r\n    nProcessReturnCode  = 1;\r\n    If( pLogoutput = 1 ); LogOutput('INFO', Expand( sProcessAction ) );  EndIf;\r\nEndIf;\r\n\r\n",
    "UIData": "CubeAction=1511\fDataAction=1503\fCubeLogChanges=0\f",
    "Variables": [],
    "VariablesUIData": []
}