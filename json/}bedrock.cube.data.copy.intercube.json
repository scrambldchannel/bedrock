{
    "DataProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n  # The exapand function gives the value of the variable passed to it\r\n  # So if the say the third dimension in the source cube is the first dimension in the target cube\r\n  # the string variable Source Variable for Target varialbe V1 is set on the prolog to V3 (see Mapped part)\r\n  # which means Expand(%V3%) gives the value of V3\r\n  # and Target sV1 will equal V3\r\nIf( pFile = 0 );\r\n  sV1 =IF(nMappedDim1=1,  Expand('%'|sMappedV1|'%'), IF(nNewDim1=1, sNewV1,V1));\r\n  sV2 =IF(nMappedDim2=1,  Expand('%'|sMappedV2|'%'), IF(nNewDim2=1, sNewV2,V2));\r\n  sV3 =IF(nMappedDim3=1,  Expand('%'|sMappedV3|'%'), IF(nNewDim3=1, sNewV3,V3));\r\n  sV4 =IF(nMappedDim4=1,  Expand('%'|sMappedV4|'%'), IF(nNewDim4=1, sNewV4,V4));\r\n  sV5 =IF(nMappedDim5=1,  Expand('%'|sMappedV5|'%'), IF(nNewDim5=1, sNewV5,V5));\r\n  sV6 =IF(nMappedDim6=1,  Expand('%'|sMappedV6|'%'), IF(nNewDim6=1, sNewV6,V6));\r\n  sV7 =IF(nMappedDim7=1,  Expand('%'|sMappedV7|'%'), IF(nNewDim7=1, sNewV7,V7));\r\n  sV8 =IF(nMappedDim8=1,  Expand('%'|sMappedV8|'%'), IF(nNewDim8=1, sNewV8,V8));\r\n  sV9 =IF(nMappedDim9=1,  Expand('%'|sMappedV9|'%'), IF(nNewDim9=1, sNewV9,V9));\r\n  sV10=IF(nMappedDim10=1, Expand('%'|sMappedV10|'%'),IF(nNewDim10=1,sNewV10,V10));\r\n  sV11=IF(nMappedDim11=1, Expand('%'|sMappedV11|'%'),IF(nNewDim11=1,sNewV11,V11));\r\n  sV12=IF(nMappedDim12=1, Expand('%'|sMappedV12|'%'),IF(nNewDim12=1,sNewV12,V12));\r\n  sV13=IF(nMappedDim13=1, Expand('%'|sMappedV13|'%'),IF(nNewDim13=1,sNewV13,V13));\r\n  sV14=IF(nMappedDim14=1, Expand('%'|sMappedV14|'%'),IF(nNewDim14=1,sNewV14,V14));\r\n  sV15=IF(nMappedDim15=1, Expand('%'|sMappedV15|'%'),IF(nNewDim15=1,sNewV15,V15));\r\n  sV16=IF(nMappedDim16=1, Expand('%'|sMappedV16|'%'),IF(nNewDim16=1,sNewV16,V16));\r\n  sV17=IF(nMappedDim17=1, Expand('%'|sMappedV17|'%'),IF(nNewDim17=1,sNewV17,V17));\r\n  sV18=IF(nMappedDim18=1, Expand('%'|sMappedV18|'%'),IF(nNewDim18=1,sNewV18,V18));\r\n  sV19=IF(nMappedDim19=1, Expand('%'|sMappedV19|'%'),IF(nNewDim19=1,sNewV19,V19));\r\n  sV20=IF(nMappedDim20=1, Expand('%'|sMappedV20|'%'),IF(nNewDim20=1,sNewV20,V20));\r\n  sV21=IF(nMappedDim21=1, Expand('%'|sMappedV21|'%'),IF(nNewDim21=1,sNewV21,V21));\r\n  sV22=IF(nMappedDim22=1, Expand('%'|sMappedV22|'%'),IF(nNewDim22=1,sNewV22,V22));\r\n  sV23=IF(nMappedDim23=1, Expand('%'|sMappedV23|'%'),IF(nNewDim23=1,sNewV23,V23));\r\n  sV24=IF(nMappedDim24=1, Expand('%'|sMappedV24|'%'),IF(nNewDim24=1,sNewV24,V24));\r\n  sV25=IF(nMappedDim25=1, Expand('%'|sMappedV25|'%'),IF(nNewDim25=1,sNewV25,V25));\r\n  sV26=IF(nMappedDim26=1, Expand('%'|sMappedV26|'%'),IF(nNewDim26=1,sNewV26,V26));\r\n  sV27=IF(nMappedDim27=1, Expand('%'|sMappedV27|'%'),IF(nNewDim27=1,sNewV27,V27));\r\n  sV28=IF(nMappedDim28=1, Expand('%'|sMappedV28|'%'),V28);\r\nElseIf( pFile > 0 );\r\n  sV1 =IF(nMappedDim1=1,  Expand('%'|sMappedV1|'%'), IF(nNewDim1=1, sNewV1,V2));\r\n  sV2 =IF(nMappedDim2=1,  Expand('%'|sMappedV2|'%'), IF(nNewDim2=1, sNewV2,V3));\r\n  sV3 =IF(nMappedDim3=1,  Expand('%'|sMappedV3|'%'), IF(nNewDim3=1, sNewV3,V4));\r\n  sV4 =IF(nMappedDim4=1,  Expand('%'|sMappedV4|'%'), IF(nNewDim4=1, sNewV4,V5));\r\n  sV5 =IF(nMappedDim5=1,  Expand('%'|sMappedV5|'%'), IF(nNewDim5=1, sNewV5,V6));\r\n  sV6 =IF(nMappedDim6=1,  Expand('%'|sMappedV6|'%'), IF(nNewDim6=1, sNewV6,V7));\r\n  sV7 =IF(nMappedDim7=1,  Expand('%'|sMappedV7|'%'), IF(nNewDim7=1, sNewV7,V8));\r\n  sV8 =IF(nMappedDim8=1,  Expand('%'|sMappedV8|'%'), IF(nNewDim8=1, sNewV8,V9));\r\n  sV9 =IF(nMappedDim9=1,  Expand('%'|sMappedV9|'%'), IF(nNewDim9=1, sNewV9,V10));\r\n  sV10=IF(nMappedDim10=1, Expand('%'|sMappedV10|'%'),IF(nNewDim10=1,sNewV10,V11));\r\n  sV11=IF(nMappedDim11=1, Expand('%'|sMappedV11|'%'),IF(nNewDim11=1,sNewV11,V12));\r\n  sV12=IF(nMappedDim12=1, Expand('%'|sMappedV12|'%'),IF(nNewDim12=1,sNewV12,V13));\r\n  sV13=IF(nMappedDim13=1, Expand('%'|sMappedV13|'%'),IF(nNewDim13=1,sNewV13,V14));\r\n  sV14=IF(nMappedDim14=1, Expand('%'|sMappedV14|'%'),IF(nNewDim14=1,sNewV14,V15));\r\n  sV15=IF(nMappedDim15=1, Expand('%'|sMappedV15|'%'),IF(nNewDim15=1,sNewV15,V16));\r\n  sV16=IF(nMappedDim16=1, Expand('%'|sMappedV16|'%'),IF(nNewDim16=1,sNewV16,V17));\r\n  sV17=IF(nMappedDim17=1, Expand('%'|sMappedV17|'%'),IF(nNewDim17=1,sNewV17,V18));\r\n  sV18=IF(nMappedDim18=1, Expand('%'|sMappedV18|'%'),IF(nNewDim18=1,sNewV18,V19));\r\n  sV19=IF(nMappedDim19=1, Expand('%'|sMappedV19|'%'),IF(nNewDim19=1,sNewV19,V20));\r\n  sV20=IF(nMappedDim20=1, Expand('%'|sMappedV20|'%'),IF(nNewDim20=1,sNewV20,V21));\r\n  sV21=IF(nMappedDim21=1, Expand('%'|sMappedV21|'%'),IF(nNewDim21=1,sNewV21,V22));\r\n  sV22=IF(nMappedDim22=1, Expand('%'|sMappedV22|'%'),IF(nNewDim22=1,sNewV22,V23));\r\n  sV23=IF(nMappedDim23=1, Expand('%'|sMappedV23|'%'),IF(nNewDim23=1,sNewV23,V24));\r\n  sV24=IF(nMappedDim24=1, Expand('%'|sMappedV24|'%'),IF(nNewDim24=1,sNewV24,V25));\r\n  sV25=IF(nMappedDim25=1, Expand('%'|sMappedV25|'%'),IF(nNewDim25=1,sNewV25,V26));\r\n  sV26=IF(nMappedDim26=1, Expand('%'|sMappedV26|'%'),IF(nNewDim26=1,sNewV26,V27));\r\n  sV27=IF(nMappedDim27=1, Expand('%'|sMappedV27|'%'),IF(nNewDim27=1,sNewV27,V28));\r\n  sV28=IF(nMappedDim28=1, Expand('%'|sMappedV28|'%'),V29);\r\nEndIf;\r\n\r\n##########################################################################################################\r\n### Write data from source file to target cube ###########################################################\r\n\r\n  If( nDimensionCount = 2 );\r\n    If( CellIsUpdateable( pTgtCube, sV1, sV2 ) = 1 );\r\n      sElType = DType( sDim2, sV2 );\r\n      IF( SubSt( pTgtCube, 1, 17 ) @= '}ElementSecurity_');\r\n        sV3 = IF( sV3 @= '', 'NONE', sV3 );\r\n        ElementSecurityPut( sV3, sDim1, sV1, sV2 );\r\n      ELSEIF( sElType @= 'AA' );\r\n        AttrPutS( sV3, sDim1, sV1, sV2, 1 );\r\n      ELSEIF( sElType @= 'AS' );\r\n        AttrPutS( sV3, sDim1, sV1, sV2 );\r\n      ELSEIF( sElType @= 'AN' );\r\n        AttrPutN( StringToNumberEx( sV3, sDecimalSeparator, sThousandSeparator ) * nFactor, sDim1, sV1, sV2 );\r\n      ElseIf( sElType @= 'S' );\r\n        CellPutS( sV3, pTgtCube, sV1, sV2 );\r\n      Else;\r\n        nObal = CellGetN( pTgtCube, sV1, sV2 );\r\n        nCbal = nObal + StringToNumberEx( sV3, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        CellPutN( nCbal, pTgtCube, sV1, sV2 );\r\n      EndIf;\r\n    EndIf;\r\n  ElseIf( nDimensionCount = 3 );\r\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3 ) = 1 );\r\n      sElType = DType( sDim3, sV3 );\r\n      If( sElType @<> 'S' );\r\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3 );\r\n        nCbal = nObal + StringToNumberEx( sV4, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        CellPutN( nCbal, pTgtCube, sV1, sV2, sV3 );\r\n      Else;\r\n        CellPutS( sV4, pTgtCube, sV1, sV2, sV3 );\r\n      EndIf;\r\n    EndIf;\r\n  ElseIf( nDimensionCount = 4 );\r\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4 ) = 1 );\r\n      sElType = DType( sDim4, sV4 );\r\n      If( sElType @<> 'S' );\r\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4);\r\n        nCbal = nObal + StringToNumberEx( sV5, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        CellPutN( nCbal, pTgtCube, sV1, sV2, sV3, sV4);\r\n      Else;\r\n        CellPutS( sV5, pTgtCube, sV1, sV2, sV3, sV4);\r\n      EndIf;\r\n    EndIf;\r\n  ElseIf( nDimensionCount = 5 );\r\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4, sV5 ) = 1 );\r\n      sElType = DType( sDim5, sV5 );\r\n      If( sElType @<> 'S' );\r\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4, sV5 );\r\n        nCbal = nObal + StringToNumberEx( sV6, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        CellPutN( nCbal, pTgtCube, sV1, sV2, sV3, sV4, sV5 );\r\n      Else;\r\n        CellPutS( sV6, pTgtCube, sV1, sV2, sV3, sV4, sV5 );\r\n      EndIf;\r\n    EndIf;\r\n  ElseIf( nDimensionCount = 6 );\r\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6 ) = 1 );\r\n      sElType = DType( sDim6, sV6 );\r\n      If( sElType @<> 'S' );\r\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6 );\r\n        nCbal = nObal + StringToNumberEx( sV7, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        CellPutN( nCbal, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6 );\r\n      Else;\r\n        CellPutS( sV7, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6 );\r\n      EndIf;\r\n    EndIf;\r\n  ElseIf( nDimensionCount = 7 );\r\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7 ) = 1 );\r\n      sElType = DType( sDim7, sV7 );\r\n      If( sElType @<> 'S' );\r\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7 );\r\n        nCbal = nObal + StringToNumberEx( sV8, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        CellPutN( nCbal, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7 );\r\n      Else;\r\n        CellPutS( sV8, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7 );\r\n      EndIf;\r\n    EndIf;\r\n  ElseIf( nDimensionCount = 8 );\r\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8 ) = 1 );\r\n      sElType = DType( sDim8, sV8 );\r\n      If( sElType @<> 'S' );\r\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8 );\r\n        nCbal = nObal + StringToNumberEx( sV9, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        CellPutN( nCbal, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8 );\r\n      Else;\r\n        CellPutS( sV9, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8 );\r\n      EndIf;\r\n    EndIf;\r\n  ElseIf( nDimensionCount = 9 );\r\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9 ) = 1 );\r\n      sElType = DType( sDim9, sV9 );\r\n      If( sElType @<> 'S' );\r\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9 );\r\n        nCbal = nObal + StringToNumberEx( sV10, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        CellPutN( nCbal, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9 );\r\n      Else;\r\n        CellPutS( sV10, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9 );\r\n      EndIf;\r\n    EndIf;\r\n  ElseIf( nDimensionCount = 10 );\r\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10 ) = 1 );\r\n      sElType = DType( sDim10, sV10 );\r\n      If( sElType @<> 'S' );\r\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10 );\r\n        nCbal = nObal + StringToNumberEx( sV11, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        CellPutN( nCbal, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10 );\r\n      Else;\r\n        CellPutS( sV11, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10 );\r\n      EndIf;\r\n    EndIf;\r\n  ElseIf( nDimensionCount = 11 );\r\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11 ) = 1 );\r\n      sElType = DType( sDim11, sV11 );\r\n      If( sElType @<> 'S' );\r\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11 );\r\n        nCbal = nObal + StringToNumberEx( sV12, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        CellPutN( nCbal, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11 );\r\n      Else;\r\n        CellPutS( sV12, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11 );\r\n      EndIf;\r\n    EndIf;\r\n  ElseIf( nDimensionCount = 12 );\r\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12 ) = 1 );\r\n      sElType = DType( sDim12, sV12 );\r\n      If( sElType @<> 'S' );\r\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12 );\r\n        nCbal = nObal + StringToNumberEx( sV13, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        CellPutN( nCbal, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12 );\r\n      Else;\r\n        CellPutS( sV13, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12 );\r\n      EndIf;\r\n    EndIf;\r\n  ElseIf( nDimensionCount = 13 );\r\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13 ) = 1 );\r\n      sElType = DType( sDim13, sV13 );\r\n      If( sElType @<> 'S' );\r\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13 );\r\n        nCbal = nObal + StringToNumberEx( sV14, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        CellPutN( nCbal, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13 );\r\n      Else;\r\n        CellPutS( sV14, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13 );\r\n      EndIf;\r\n    EndIf;\r\n  ElseIf( nDimensionCount = 14 );\r\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14 ) = 1 );\r\n      sElType = DType( sDim14, sV14 );\r\n      If( sElType @<> 'S' );\r\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14 );\r\n        nCbal = nObal + StringToNumberEx( sV15, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        CellPutN( nCbal, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14 );\r\n      Else;\r\n        CellPutS( sV15, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14 );\r\n      EndIf;\r\n    EndIf;\r\n  ElseIf( nDimensionCount = 15 );\r\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15 ) = 1 );\r\n      sElType = DType( sDim15, sV15 );\r\n      If( sElType @<> 'S' );\r\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15 );\r\n        nCbal = nObal + StringToNumberEx( sV16, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        CellPutN( nCbal, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15 );\r\n      Else;\r\n        CellPutS( sV16, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15 );\r\n      EndIf;\r\n    EndIf;\r\n  ElseIf( nDimensionCount = 16 );\r\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16 ) = 1 );\r\n      sElType = DType( sDim16, sV16 );\r\n      If( sElType @<> 'S' );\r\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16 );\r\n        nCbal = nObal + StringToNumberEx( sV17, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        CellPutN( nCbal, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16 );\r\n      Else;\r\n        CellPutS( sV17, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16 );\r\n      EndIf;\r\n    EndIf;\r\n  ElseIf( nDimensionCount = 17 );\r\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17 ) = 1 );\r\n      sElType = DType( sDim17, sV17 );\r\n      If( sElType @<> 'S' );\r\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17 );\r\n        nCbal = nObal + StringToNumberEx( sV18, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        CellPutN( nCbal, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17 );\r\n      Else;\r\n        CellPutS( sV18, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17 );\r\n      EndIf;\r\n    EndIf;\r\n  ElseIf( nDimensionCount = 18 );\r\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18 ) = 1 );\r\n      sElType = DType( sDim18, sV18 );\r\n      If( sElType @<> 'S' );\r\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18 );\r\n        nCbal = nObal + StringToNumberEx( sV19, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        CellPutN( nCbal, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18 );\r\n      Else;\r\n        CellPutS( sV19, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18 );\r\n      EndIf;\r\n    EndIf;\r\n  ElseIf( nDimensionCount = 19 );\r\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19 ) = 1 );\r\n      sElType = DType( sDim19, sV19 );\r\n      If( sElType @<> 'S' );\r\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19 );\r\n        nCbal = nObal + StringToNumberEx( sV20, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        CellPutN( nCbal, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19 );\r\n      Else;\r\n        CellPutS( sV20, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19 );\r\n      EndIf;\r\n    EndIf;\r\n  ElseIf( nDimensionCount = 20 );\r\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20 ) = 1 );\r\n      sElType = DType( sDim20, sV20 );\r\n      If( sElType @<> 'S' );\r\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20 );\r\n        nCbal = nObal + StringToNumberEx( sV21, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        CellPutN( nCbal, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20 );\r\n      Else;\r\n        CellPutS( sV21, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20 );\r\n      EndIf;\r\n    EndIf;\r\n  ElseIf( nDimensionCount = 21 );\r\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20, sV21 ) = 1 );\r\n      sElType = DType( sDim21, sV21 );\r\n      If( sElType @<> 'S' );\r\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20, sV21 );\r\n        nCbal = nObal + StringToNumberEx( sV22, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        CellPutN( nCbal, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20, sV21 );\r\n      Else;\r\n        CellPutS( sV22, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20, sV21 );\r\n      EndIf;\r\n    EndIf;\r\n  ElseIf( nDimensionCount = 22 );\r\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20, sV21, sV22 ) = 1 );\r\n      sElType = DType( sDim22, sV22 );\r\n      If( sElType @<> 'S' );\r\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20, sV21, sV22 );\r\n        nCbal = nObal + StringToNumberEx( sV23, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        CellPutN( nCbal, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20, sV21, sV22 );\r\n      Else;\r\n        CellPutS( sV23, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20, sV21, sV22 );\r\n      EndIf;\r\n    EndIf;\r\n  ElseIf( nDimensionCount = 23 );\r\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20, sV21, sV22, sV23 ) = 1 );\r\n      sElType = DType( sDim23, sV23 );\r\n      If( sElType @<> 'S' );\r\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20, sV21, sV22, sV23 );\r\n        nCbal = nObal + StringToNumberEx( sV24, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        CellPutN( nCbal, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20, sV21, sV22, sV23 );\r\n      Else;\r\n        CellPutS( sV24, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20, sV21, sV22, sV23 );\r\n      EndIf;\r\n    EndIf;\r\n  ElseIf( nDimensionCount = 24 );\r\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20, sV21, sV22, sV23, sV24 ) = 1 );\r\n      sElType = DType( sDim24, sV24 );\r\n      If( sElType @<> 'S' );\r\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20, sV21, sV22, sV23, sV24 );\r\n        nCbal = nObal + StringToNumberEx( sV25, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        CellPutN( nCbal, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20, sV21, sV22, sV23, sV24 );\r\n      Else;\r\n        CellPutS( sV25, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20, sV21, sV22, sV23, sV24 );\r\n      EndIf;\r\n    EndIf;\r\n  ElseIf( nDimensionCount = 25 );\r\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20, sV21, sV22, sV23, sV24, sV25 ) = 1 );\r\n      sElType = DType( sDim25, sV25 );\r\n      If( sElType @<> 'S' );\r\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20, sV21, sV22, sV23, sV24, sV25 );\r\n        nCbal = nObal + StringToNumberEx( sV26, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        CellPutN( nCbal, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20, sV21, sV22, sV23, sV24, sV25 );\r\n      Else;\r\n        CellPutS( sV26, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20, sV21, sV22, sV23, sV24, sV25 );\r\n      EndIf;\r\n    EndIf;\r\n  ElseIf( nDimensionCount = 26 );\r\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20, sV21, sV22, sV23, sV24, sV25, sV26 ) = 1 );\r\n      sElType = DType( sDim26, sV26 );\r\n      If( sElType @<> 'S' );\r\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20, sV21, sV22, sV23, sV24, sV25, sV26 );\r\n        nCbal = nObal + StringToNumberEx( sV27, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        CellPutN( nCbal, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20, sV21, sV22, sV23, sV24, sV25, sV26 );\r\n      Else;\r\n        CellPutS( sV27, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20, sV21, sV22, sV23, sV24, sV25, sV26 );\r\n      EndIf;\r\n    EndIf;\r\n  ElseIf( nDimensionCount = 27 );\r\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20, sV21, sV22, sV23, sV24, sV25, sV26, sV27 ) = 1 );\r\n      sElType = DType( sDim27, sV27 );\r\n      If( sElType @<> 'S' );\r\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20, sV21, sV22, sV23, sV24, sV25, sV26, sV27 );\r\n        nCbal = nObal + StringToNumberEx( sV28, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        CellPutN( nCbal, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20, sV21, sV22, sV23, sV24, sV25, sV26, sV27 );\r\n      Else;\r\n        CellPutS( sV28, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20, sV21, sV22, sV23, sV24, sV25, sV26, sV27 );\r\n      EndIf;\r\n    EndIf;\r\n\r\n  EndIf;\r\n\r\n### End Data ###",
    "DataSource": {
        "Type": "?",
        "asciiDecimalSeparator": ".",
        "asciiDelimiterChar": ",",
        "asciiHeaderRecords": 0,
        "asciiQuoteCharacter": "\"",
        "asciiThousandSeparator": ",",
        "dataSourceNameForClient": "Bedrock Source Cube",
        "dataSourceNameForServer": "Bedrock Source Cube"
    },
    "EpilogProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n## Zero Source\r\nIf( pZeroSource = 1 & nErrors = 0  );\r\n    If ( pCubeLogging <= 1 );\r\n        CubeSetLogChanges( pSrcCube, pCubeLogging);\r\n    EndIf;\r\n        ViewZeroOut( pSrcCube, sView );\r\n    If ( pCubeLogging <= 1 );\r\n        CubeSetLogChanges( pSrcCube, IF(CellGetS('}CubeProperties', pSrcCube, 'LOGGING' ) @= 'YES',1,0) );\r\n    EndIf;\r\nEndIf;\r\n\r\n## Switch back logging on Tgt Cube\r\nIf ( pCubeLogging <= 1 );\r\n    CubeSetLogChanges( pTgtCube, IF(sCubeLogging @='YES',1,0) );\r\nEndIf;\r\n\r\n### Delete export file if used\r\nIf( pFile = 1 );\r\n  TM1RunCmd = 'CMD.EXE /C \"DEL \"' | cFile | '\" \"';\r\n  EXECUTECOMMAND ( TM1RunCmd , 0 );\r\nEndIf;\r\n\r\n### Return code & final error message handling\r\nIf( nErrors > 0 );\r\n    sMessage = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\r\n    nProcessReturnCode = 0;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\r\n    If( pStrictErrorHandling = 1 );\r\n        ProcessQuit;\r\n    EndIf;\r\nElse;\r\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully copied data from %pSrcCube% cube to the %pTgtCube% cube.' );\r\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\r\n    nProcessReturnCode = 1;\r\n    If( pLogoutput = 1 );\r\n        LogOutput('INFO', Expand( sProcessAction ) );\r\n    EndIf;\r\nEndIf;\r\n\r\n### End Epilog ###",
    "HasSecurityAccess": true,
    "MetadataProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****",
    "Name": "}bedrock.cube.data.copy.intercube",
    "Parameters": [
        {
            "Name": "pLogOutput",
            "Prompt": "OPTIONAL: write parameters and action summary to server message log (Boolean True = 1)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pStrictErrorHandling",
            "Prompt": "OPTIONAL: On encountering any error exit with major error status by ProcessQuit after writing to the server message log (Boolean True = 1)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pSrcCube",
            "Prompt": "REQUIRED: Cube data is being copied from",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pFilter",
            "Prompt": "OPTIONAL: Filter on source cube in format Year\u00a6 2006 + 2007 & Scenario\u00a6 Actual + Budget. Blank for whole cube",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pFilterParallel",
            "Prompt": "OPTIONAL: Parallelization Filter: Month\u00a6Q1+Q2+Q3+Q4 (Blank=run single threaded). Single dimension parallel slices. Will be added to filter single element at a time. Dimension must not be part of filter",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pParallelThreads",
            "Prompt": "Maximum number of threads to run when parallel processing is enabled ( if <2 will execute one thread but parallel filter is still applied )",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pTgtCube",
            "Prompt": "REQUIRED: Name of cube to copy the values to",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pMappingToNewDims",
            "Prompt": "REQUIRED IF TARGET HAS DIMS NOT IN SOURCE: DimX\u00a6InputElementForDimX & DimY\u00a6InputElementForDimY (specify an N level element for each new dim)",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pSuppressConsol",
            "Prompt": "OPTIONAL: Suppress Consolidations (Skip = 1) Only use 0 for strings",
            "Type": "Numeric",
            "Value": "1"
        },
        {
            "Name": "pSuppressConsolStrings",
            "Prompt": "OPTIONAL: Suppress Consolidated String Cells (Skip = 1)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pSuppressRules",
            "Prompt": "OPTIONAL: Suppress Rules (Skip = 1)",
            "Type": "Numeric",
            "Value": "1"
        },
        {
            "Name": "pSuppressZero",
            "Prompt": "OPTIONAL: Suppress Null Cells (Skip = 1)",
            "Type": "Numeric",
            "Value": "1"
        },
        {
            "Name": "pZeroTarget",
            "Prompt": "OPTIONAL: Zero out Target Element PRIOR to Copy? (Boolean 1=True) Clears combination of pFilter and pMappingToNewDims",
            "Type": "Numeric",
            "Value": "1"
        },
        {
            "Name": "pZeroSource",
            "Prompt": "OPTIONAL: Zero out Source Element AFTER Copy? (Boolean 1=True). If pFilter is blank the whole source cube is cleared!",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pFactor",
            "Prompt": "OPTIONAL: Multiply source value by factor (1 keeps the value as is). To modify existing values make the target element the same as the source with pZeroTarget = 0",
            "Type": "Numeric",
            "Value": "1"
        },
        {
            "Name": "pDimDelim",
            "Prompt": "OPTIONAL. Delimiter for start of Dimension/Element set",
            "Type": "String",
            "Value": "&"
        },
        {
            "Name": "pEleStartDelim",
            "Prompt": "OPTIONAL: Delimiter for start of element list",
            "Type": "String",
            "Value": "\u00a6"
        },
        {
            "Name": "pEleDelim",
            "Prompt": "OPTIONAL: Delimiter between elements",
            "Type": "String",
            "Value": "+"
        },
        {
            "Name": "pTemp",
            "Prompt": "OPTIONAL: Delete temporary view and Subset ( 0 = Retain View and Subsets 1 = Delete View and Subsets 2 = Delete View only )",
            "Type": "Numeric",
            "Value": "1"
        },
        {
            "Name": "pCubeLogging",
            "Prompt": "Required: Cube Logging (0 = No transaction logging 1 = Logging of transactions 2 = Ignore Cube Logging - No Action Taken)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pSandbox",
            "Prompt": "OPTIONAL: To use sandbox not base data enter the sandbox name (invalid name will result in process error)",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pFile",
            "Prompt": "OPTIONAL: Copy via file export and import. Reduces locks (0 = no 1= use file and delete it 2= use file and retain it)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pDelim",
            "Prompt": "OPTIONAL: For pFile > 0. AsciiOutput delimiter character (Default = '' exactly 3 digits = ASCII code)",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pQuote",
            "Prompt": "OPTIONAL: For pFile > 0. AsciiOutput quote character (Default = '\"\"' exactly 3 digits = ASCII code)",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pDecimalSeparator",
            "Prompt": "OPTIONAL: For pFile > 0. Decimal separator for conversion of NumberToStringEx and StringToNumberEx (default = '.' exactly 3 digits = ASCII code)",
            "Type": "String",
            "Value": "."
        },
        {
            "Name": "pThousandSeparator",
            "Prompt": "OPTIONAL: For pFile > 0. Thousand separator for conversion of NumberToStringEx and StringToNumberEx (default = '' exactly 3 digits = ASCII code)",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pSubN",
            "Prompt": "OPTIONAL: Create N level subset for all dims not mentioned in pFilter",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pThreadMode",
            "Prompt": "DO NOT USE: Internal parameter only please do not use",
            "Type": "Numeric",
            "Value": "0"
        }
    ],
    "PrologProcedure": "#Region CallThisProcess\r\n# A snippet of code provided as an example how to call this process should the developer be working on a system without access to an editor with auto-complete.\r\nIf( 1 = 0 );\r\n    ExecuteProcess( '}bedrock.cube.data.copy.intercube', 'pLogOutput', pLogOutput,\r\n      'pStrictErrorHandling', pStrictErrorHandling,\r\n    \t'pSrcCube', '', 'pFilter', '',\r\n    \t'pFilterParallel', '', 'pParallelThreads', 0,\r\n    \t'pTgtCube', '', 'pMappingToNewDims', '',\r\n    \t'pSuppressConsol', 1, 'pSuppressConsolStrings', 0, 'pSuppressRules', 1, 'pSuppressZero', 1,\r\n    \t'pZeroTarget', 1, 'pZeroSource', 0,\r\n    \t'pFactor', 1,\r\n    \t'pDimDelim', '&', 'pEleStartDelim', '\u00a6', 'pEleDelim', '+',\r\n    \t'pTemp', 1, 'pCubeLogging', 0, 'pSandbox', pSandbox, 'pSubN', 0,\r\n    \t'pFile', 0, 'pDelim', ',', 'pQuote', '\"', 'pDecimalSeparator', '.', 'pThousandSeparator', ','\r\n\t);\r\nEndIf;\r\n#EndRegion CallThisProcess\r\n\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n#################################################################################################\r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock Ver 4.0~~##\r\n#################################################################################################\r\n\r\n#Region @DOC\r\n# Description:\r\n# This is the process used to copy data from a source cube to a different target cube.\r\n\r\n# Use case: Mainly used in production environments.\r\n# 1. This process could be used to populate a Reporting cube.\r\n# 2. The process could be used to archive data from one cube to another one for any use.\r\n\r\n# Note:\r\n# * The target cube may have a different number of dimensions as the source cube.\r\n# * Where the target and source cubes share the same dimensions, the process will match the dimensions even if their position in the cube is different.\r\n# * An input element must be specified for each dimension which is in the target but not in the source using the parameter pMappingToNewDims.\r\n# * The format of parameter pMappingToNewDims using default delimiters & and : is DimInTargetButNotSource1:ElementOfDim & DimInTargetButNotSource2:ElementOfDim.\r\n# * The input element must be an N level unless pSuppressConsol is set to 0.\r\n# * The maximum number of dimensions catered for in the target cube is 27. (In principle adding support for cubes with higher dimensionality is not difficult).\r\n\r\n# For dimensions in the source but not the target, the process will accumulate the values of all n level elements\r\n# (or all n level elements specified by the pFilter parameter).\r\n# The pFilter parameter contains the dimensions and elements to be used for filtering the source cube.\r\n# The format of the pFilter parameter is as follows, using default delimiters & + : Dim1: Elem1 + Elem2 & Dim2: Elem3 + Elem4.\r\n# The dimension parameters do not need to be given in the index order of dimensions in the cube.\r\n# The dimension name is specified as the first member of the delimited string of elements.\r\n# If consolidations are skipped the N level children of any consolidated filter elements will be used.\r\n# Spaces are ignored so use them to make your filter more readable.\r\n# If using the pFilterParallel parameter the **single dimension** used as the \"parallelization slicer\" cannot appear in\r\n# the pFilter parameters.\r\n# When using parallelization via the *RunProcess* function the elements listed in pFilterParallel will be split one_at_a_time\r\n# and passed to a recursive call of the process being added to pFilter.\r\n\r\n# An example:\r\n# To copy the 2011 Actual Sales data from the Sales cube to the General Ledger cube set pFilter to Year: 2011 & Version: Actual.\r\n# Say the General Ledger cube has an Account dimension but the Sales cube doesn't and the Account for sales is 9999 (an n level element).\r\n# Set the pMappingToNewDims parameter to Account:9999.\r\n# This will copy all Actual 2011 Sales to Account 9999 in the General Ledger.\r\n# If only sales for Company X are to be copied, set pFilter to Year: 2011 & Version: Actual & Company:X.\r\n# If sales from other companies are already in the General Ledger set pZeroTarget to 0 to add Company X's data to the existing data.\r\n# Setting pZeroTarget to 1 will clear our data in the target cube for the elements specified in the\r\n# pMappingToNewDims parameter and the pFilter parameter for dimensions that are in the target.\r\n#EndRegion @DOC\r\n\r\n### Global Variables\r\nStringGlobalVariable('sProcessReturnCode');\r\nNumericGlobalVariable('nProcessReturnCode');\r\n\r\n### Constants ###\r\ncThisProcName       = GetProcessName();\r\ncUserName           = TM1User();\r\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\r\ncRandomInt          = NumberToString( INT( RAND( ) * 1000 ));\r\ncMsgErrorLevel      = 'ERROR';\r\ncMsgErrorContent    = '%cThisProcName% : %sMessage% : %cUserName%';\r\ncLogInfo          = 'Process:%cThisProcName% run with parameters pSrcCube:%pSrcCube%, pFilter:%pFilter%, pFilterParallel:%pFilterParallel%, pParallelThreads:%pParallelThreads%, pTgtCube:%pTgtCube%, pMappingToNewDims:%pMappingToNewDims%, pSuppressConsol:%pSuppressConsol%, pSuppressConsolStrings:%pSuppressConsolStrings%, pSuppressRules:%pSuppressRules%, pSuppressZero:%pSuppressZero%, pZeroTarget:%pZeroTarget%, pZeroSource:%pZeroSource%, pFactor:%pFactor%, pDimDelim:%pDimDelim%, pEleStartDelim:%pEleStartDelim%, pEleDelim:%pEleDelim%, pTemp:%pTemp%, pCubeLogging:%pCubeLogging%, pSandbox:%pSandbox%, pFile:%pFile%, pThreadMode:%pThreadMode%.';\r\n\r\nsDelimDim           = TRIM(pDimDelim);\r\nsElementStartDelim  = TRIM(pElEStartDelim);\r\nsDelimElem          = TRIM(pEleDelim);\r\nnErrors             = 0;\r\ncLenASCIICode       = 3;\r\n\r\n## LogOutput parameters\r\nIF( pLogoutput = 1 );\r\n    LogOutput('INFO', Expand( cLogInfo ) );\r\nENDIF;\r\n\r\n# Make sure pFactor not zero\r\nnFactor             = If( pFactor = 0, 1, pFactor );\r\n\r\nsView               = cThisProcName | cTimeStamp | cRandomInt;\r\nsSubset             = sView;\r\nsTargetView         = 'Target '| sView;\r\nsTargetSubset       = sTargetView;\r\n\r\n## check operating system\r\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\r\n  sOS = 'Windows';\r\n  sOSDelim = '\\';\r\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0 );\r\n  sOS = 'Linux';\r\n  sOSDelim = '/';\r\nElse;\r\n  sOS = 'Windows';\r\n  sOSDelim = '\\';\r\nEndIf;\r\n\r\n## File location for indirect data copy\r\ncDir    = '.' | sOSDelim;\r\ncFileName = pSrcCube | cTimeStamp | cRandomInt | '.csv';\r\ncFile   = cDir | cFileName;\r\ncTitleRows = 1;\r\n\r\n# Validate file delimiter & quote character\r\nIf( pDelim @= '' );\r\n    pDelim = ',';\r\nElse;\r\n    # If length of pDelim is exactly 3 chars and each of them is decimal digit, then the pDelim is entered as ASCII code\r\n    nValid = 0;\r\n    If ( LONG(pDelim) = cLenASCIICode );\r\n      nChar = 1;\r\n      While ( nChar <= cLenASCIICode );\r\n        If( CODE( pDelim, nChar ) >= CODE( '0', 1 ) & CODE( pDelim, nChar ) <= CODE( '9', 1 ) );\r\n          nValid = 1;\r\n        Else;\r\n          nValid = 0;\r\n          Break;\r\n        EndIf;\r\n        nChar = nChar + 1;\r\n      End;\r\n    EndIf;\r\n    If ( nValid<>0 );\r\n      pDelim=CHAR(StringToNumber( pDelim ));\r\n    Else;\r\n      pDelim = SubSt( Trim( pDelim ), 1, 1 );\r\n    EndIf;\r\nEndIf;\r\ncDelimiter = pDelim;\r\n\r\nIf( pQuote @= '' );\r\n    ## Use no quote character\r\nElse;\r\n    # If length of pQuote is exactly 3 chars and each of them is decimal digit, then the pQuote is entered as ASCII code\r\n    nValid = 0;\r\n    If ( LONG(pQuote) = cLenASCIICode );\r\n      nChar = 1;\r\n      While ( nChar <= cLenASCIICode );\r\n        If( CODE( pQuote, nChar ) >= CODE( '0', 1 ) & CODE( pQuote, nChar ) <= CODE( '9', 1 ) );\r\n          nValid = 1;\r\n        Else;\r\n          nValid = 0;\r\n          Break;\r\n        EndIf;\r\n        nChar = nChar + 1;\r\n      End;\r\n    EndIf;\r\n    If ( nValid<>0 );\r\n      pQuote=CHAR(StringToNumber( pQuote ));\r\n    Else;\r\n      pQuote = SubSt( Trim( pQuote ), 1, 1 );\r\n    EndIf;\r\nEndIf;\r\ncQuote = pQuote;\r\n\r\n#Region ## Check Parameters ###\r\n\r\n## Default filter delimiters\r\nIf( pDimDelim     @= '' );\r\n    pDimDelim     = '&';\r\nEndIf;\r\nIf( pEleStartDelim@= '' );\r\n    pEleStartDelim= '\u00a6';\r\nEndIf;\r\nIf( pEleDelim     @= '' );\r\n    pEleDelim     = '+';\r\nEndIf;\r\n\r\nIf( pDecimalSeparator @= '' );\r\n \tpDecimalSeparator = '.';\r\nEndIf;\r\nIf ( LONG(pDecimalSeparator) = cLenASCIICode );\r\n  nValid = 0;\r\n  nChar = 1;\r\n  While ( nChar <= cLenASCIICode );\r\n    If( CODE( pDecimalSeparator, nChar ) >= CODE( '0', 1 ) & CODE( pDecimalSeparator, nChar ) <= CODE( '9', 1 ) );\r\n      nValid = 1;\r\n    Else;\r\n      nValid = 0;\r\n      Break;\r\n    EndIf;\r\n    nChar = nChar + 1;\r\n  End;\r\n  If ( nValid<>0 );\r\n    pDecimalSeparator = CHAR(StringToNumber( pDecimalSeparator ));\r\n  Else;\r\n    pDecimalSeparator = SubSt( Trim( pDecimalSeparator ), 1, 1 );\r\n  EndIf;\r\nEndIf;\r\nsDecimalSeparator = pDecimalSeparator;\r\n\r\nIf( pThousandSeparator @= '' );\r\n \tpThousandSeparator = ',';\r\nEndIf;\r\nIf ( LONG(pThousandSeparator) = cLenASCIICode );\r\n  nValid = 0;\r\n  nChar = 1;\r\n  While ( nChar <= cLenASCIICode );\r\n    If( CODE( pThousandSeparator, nChar ) >= CODE( '0', 1 ) & CODE( pThousandSeparator, nChar ) <= CODE( '9', 1 ) );\r\n      nValid = 1;\r\n    Else;\r\n      nValid = 0;\r\n      Break;\r\n    EndIf;\r\n    nChar = nChar + 1;\r\n  End;\r\n  If ( nValid<>0 );\r\n    pThousandSeparator = CHAR(StringToNumber( pThousandSeparator ));\r\n  Else;\r\n    pThousandSeparator = SubSt( Trim( pThousandSeparator ), 1, 1 );\r\n  EndIf;\r\nEndIf;\r\nsThousandSeparator = pThousandSeparator;\r\n\r\n# If specified source cube doesn't exist then terminate process\r\nIf( CubeExists(   pSrcCube   ) = 0 );\r\n    nErrors = nErrors + 1;\r\n  sMessage = Expand( 'Invalid source cube specified: %pSrcCube%.');\r\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\n# If specified target cube doesn't exist then terminate process\r\nIf( CubeExists(   pTgtCube   ) = 0 );\r\n  nErrors = nErrors + 1;\r\n  sMessage = Expand( 'Invalid target cube specified: %pTgtCube%.');\r\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\n# Validate parallelization filter\r\nIf( Scan( pEleStartDelim, pFilterParallel ) > 0 );\r\n    sDimParallel = SubSt( pFilterParallel, 1, Scan( pEleStartDelim, pFilterParallel ) - 1 );\r\n    If( Scan( Lower(sDimParallel) | pEleStartDelim, Lower(pFilter) ) > 0 );\r\n        sMessage = 'Parallelization dimension %sDimParallel% cannot exist in filter.';\r\n        nErrors = nErrors + 1;\r\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n    EndIf;\r\nEndIf;\r\n\r\n# Validate Max Threads\r\nIf( pParallelThreads > 0 );\r\n  nMaxThreads = pParallelThreads;\r\nElse;\r\n  nMaxThreads = 1;\r\nEndIf;\r\n\r\n# Validate Sandbox\r\nIf( TRIM( pSandbox ) @<> '' );\r\n    If( ServerSandboxExists( pSandbox ) = 0 );\r\n        SetUseActiveSandboxProperty( 0 );\r\n        nErrors = nErrors + 1;\r\n        sMessage = Expand('Sandbox %pSandbox% is invalid for the current user.');\r\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n    Else;\r\n        ServerActiveSandboxSet( pSandbox );\r\n        SetUseActiveSandboxProperty( 1 );\r\n    EndIf;\r\nElse;\r\n    SetUseActiveSandboxProperty( 0 );\r\nEndIf;\r\n\r\n### Check for errors before continuing\r\nIf( nErrors <> 0 );\r\n  If( pStrictErrorHandling = 1 );\r\n      ProcessQuit;\r\n  Else;\r\n      ProcessBreak;\r\n  EndIf;\r\nEndIf;\r\n#EndRegion\r\n#Region\r\n## Set variables =0 or '' ################################################################################################# ########################\r\n### Placeholders for mappped dimensions\r\nnMappedDim1 = 0;\r\nnMappedDim2 = 0;\r\nnMappedDim3 = 0;\r\nnMappedDim4 = 0;\r\nnMappedDim5 = 0;\r\nnMappedDim6 = 0;\r\nnMappedDim7 = 0;\r\nnMappedDim8 = 0;\r\nnMappedDim9 = 0;\r\nnMappedDim10 = 0;\r\nnMappedDim11 = 0;\r\nnMappedDim12 = 0;\r\nnMappedDim13 = 0;\r\nnMappedDim14 = 0;\r\nnMappedDim15 = 0;\r\nnMappedDim16 = 0;\r\nnMappedDim17 = 0;\r\nnMappedDim18 = 0;\r\nnMappedDim19 = 0;\r\nnMappedDim20 = 0;\r\nnMappedDim21 = 0;\r\nnMappedDim22 = 0;\r\nnMappedDim23 = 0;\r\nnMappedDim24 = 0;\r\nnMappedDim25 = 0;\r\nnMappedDim26 = 0;\r\nnMappedDim27 = 0;\r\n\r\nsMappedV1 = '';\r\nsMappedV2 = '';\r\nsMappedV3 = '';\r\nsMappedV4 = '';\r\nsMappedV5 = '';\r\nsMappedV6 = '';\r\nsMappedV7 = '';\r\nsMappedV8 = '';\r\nsMappedV9 = '';\r\nsMappedV10 = '';\r\nsMappedV11 = '';\r\nsMappedV12 = '';\r\nsMappedV13 = '';\r\nsMappedV14 = '';\r\nsMappedV15 = '';\r\nsMappedV16 = '';\r\nsMappedV17 = '';\r\nsMappedV18 = '';\r\nsMappedV19 = '';\r\nsMappedV20 = '';\r\nsMappedV21 = '';\r\nsMappedV22 = '';\r\nsMappedV23 = '';\r\nsMappedV24 = '';\r\nsMappedV25 = '';\r\nsMappedV26 = '';\r\nsMappedV27 = '';\r\nsMappedV28 = '';\r\n\r\n### Placeholders for new dimensions\r\nnNewDim1 = 0;\r\nnNewDim2 = 0;\r\nnNewDim3 = 0;\r\nnNewDim4 = 0;\r\nnNewDim5 = 0;\r\nnNewDim6 = 0;\r\nnNewDim7 = 0;\r\nnNewDim8 = 0;\r\nnNewDim9 = 0;\r\nnNewDim10 = 0;\r\nnNewDim11 = 0;\r\nnNewDim12 = 0;\r\nnNewDim13 = 0;\r\nnNewDim14 = 0;\r\nnNewDim15 = 0;\r\nnNewDim16 = 0;\r\nnNewDim17 = 0;\r\nnNewDim18 = 0;\r\nnNewDim19 = 0;\r\nnNewDim20 = 0;\r\nnNewDim21 = 0;\r\nnNewDim22 = 0;\r\nnNewDim23 = 0;\r\nnNewDim24 = 0;\r\nnNewDim25 = 0;\r\nnNewDim26 = 0;\r\nnNewDim27 = 0;\r\n\r\nsNewV1 = '';\r\nsNewV2 = '';\r\nsNewV3 = '';\r\nsNewV4 = '';\r\nsNewV5 = '';\r\nsNewV6 = '';\r\nsNewV7 = '';\r\nsNewV8 = '';\r\nsNewV9 = '';\r\nsNewV10 = '';\r\nsNewV11 = '';\r\nsNewV12 = '';\r\nsNewV13 = '';\r\nsNewV14 = '';\r\nsNewV15 = '';\r\nsNewV16 = '';\r\nsNewV17 = '';\r\nsNewV18 = '';\r\nsNewV19 = '';\r\nsNewV20 = '';\r\nsNewV21 = '';\r\nsNewV22 = '';\r\nsNewV23 = '';\r\nsNewV24 = '';\r\nsNewV25 = '';\r\nsNewV26 = '';\r\nsNewV27 = '';\r\n\r\n### Determine dimensions in target cube, we need to know this to test cell type before loading ###\r\n# only numbers get converted from strings to numbers\r\nsDim1 = TabDim( pTgtCube, 1 );\r\nsDim2 = TabDim( pTgtCube, 2 );\r\nsDim3 = TabDim( pTgtCube, 3 );\r\nsDim4 = TabDim( pTgtCube, 4 );\r\nsDim5 = TabDim( pTgtCube, 5 );\r\nsDim6 = TabDim( pTgtCube, 6 );\r\nsDim7 = TabDim( pTgtCube, 7 );\r\nsDim8 = TabDim( pTgtCube, 8 );\r\nsDim9 = TabDim( pTgtCube, 9 );\r\nsDim10 = TabDim( pTgtCube, 10 );\r\nsDim11 = TabDim( pTgtCube, 11 );\r\nsDim12 = TabDim( pTgtCube, 12 );\r\nsDim13 = TabDim( pTgtCube, 13 );\r\nsDim14 = TabDim( pTgtCube, 14 );\r\nsDim15 = TabDim( pTgtCube, 15 );\r\nsDim16 = TabDim( pTgtCube, 16 );\r\nsDim17 = TabDim( pTgtCube, 17 );\r\nsDim18 = TabDim( pTgtCube, 18 );\r\nsDim19 = TabDim( pTgtCube, 19 );\r\nsDim20 = TabDim( pTgtCube, 20 );\r\nsDim21 = TabDim( pTgtCube, 21 );\r\nsDim22 = TabDim( pTgtCube, 22 );\r\nsDim23 = TabDim( pTgtCube, 23 );\r\nsDim24 = TabDim( pTgtCube, 24 );\r\nsDim25 = TabDim( pTgtCube, 25 );\r\nsDim26 = TabDim( pTgtCube, 26 );\r\nsDim27 = TabDim( pTgtCube, 27 );\r\n#EndRegion\r\nsTgtDimString = '^^'|sDim1|'^^'|sDim2|'^^'|sDim3|'^^'|sDim4|'^^'|sDim5|'^^'|sDim6|'^^'|sDim7|'^^'|sDim8|'^^'|sDim9|'^^'|sDim10|'^^'\r\n                    |sDim11|'^^'|sDim12|'^^'|sDim13|'^^'|sDim14|'^^'|sDim15|'^^'|sDim16|'^^'|sDim17|'^^'|sDim18|'^^'|sDim19|'^^'|sDim20|'^^'\r\n                    |sDim21|'^^'|sDim22|'^^'|sDim23|'^^'|sDim24|'^^'|sDim25|'^^'|sDim26|'^^'|sDim27|'^^';\r\n\r\n### We have to remove spaces from the search string before going to include the string in searching loop\r\nsTgtDimString = UPPER( sTgtDimString );\r\nnSPIndex = SCAN( ' ', sTgtDimString );\r\nWhile ( nSPIndex <> 0);\r\n  sTgtDimString = DELET( sTgtDimString, nSPIndex, 1 );\r\n  nSPIndex = SCAN( ' ', sTgtDimString );\r\nEnd;\r\n\r\n###########################################\r\n#Region ### MAPPING Target DIMENSIONS #####\r\n###########################################\r\nnSourceIndex = 1;\r\nWhile( TabDim( pSrcCube, nSourceIndex ) @<> '' );\r\n  sSourceDim = TabDim( pSrcCube, nSourceIndex);\r\n    # reset target index if another source dimension has been found\r\n    nTargetIndex = 1;\r\n    WHILE(TabDim( pTgtCube, nTargetIndex ) @<> '');\r\n      sTargetDim = TabDim( pTgtCube, nTargetIndex );\r\n      If(sSourceDim @= sTargetDim);\r\n          If( pFile = 0 );\r\n            If(nTargetIndex = 1);\r\n              nMappedDim1 = 1;\r\n              sMappedV1  = 'V' | NumberToString(nSourceIndex);\r\n            ElseIf(nTargetIndex = 2);\r\n              nMappedDim2 = 1;\r\n              sMappedV2  = 'V' | NumberToString(nSourceIndex);\r\n            ElseIf(nTargetIndex = 3);\r\n              nMappedDim3 = 1;\r\n              sMappedV3  = 'V' | NumberToString(nSourceIndex);\r\n            ElseIf(nTargetIndex = 4);\r\n              nMappedDim4 = 1;\r\n              sMappedV4  = 'V' | NumberToString(nSourceIndex);\r\n            ElseIf(nTargetIndex = 5);\r\n              nMappedDim5 = 1;\r\n              sMappedV5  = 'V' | NumberToString(nSourceIndex);\r\n            ElseIf(nTargetIndex = 6);\r\n              nMappedDim6 = 1;\r\n              sMappedV6  = 'V' | NumberToString(nSourceIndex);\r\n            ElseIf(nTargetIndex = 7);\r\n              nMappedDim7 = 1;\r\n              sMappedV7  = 'V' | NumberToString(nSourceIndex);\r\n            ElseIf(nTargetIndex = 8);\r\n              nMappedDim8 = 1;\r\n              sMappedV8  = 'V' | NumberToString(nSourceIndex);\r\n            ElseIf(nTargetIndex = 9);\r\n              nMappedDim9 = 1;\r\n              sMappedV9  = 'V' | NumberToString(nSourceIndex);\r\n            ElseIf(nTargetIndex = 10);\r\n              nMappedDim10 = 1;\r\n              sMappedV10  = 'V' | NumberToString(nSourceIndex);\r\n            ElseIf(nTargetIndex = 11);\r\n              nMappedDim11 = 1;\r\n              sMappedV11  = 'V' | NumberToString(nSourceIndex);\r\n            ElseIf(nTargetIndex = 12);\r\n              nMappedDim12 = 1;\r\n              sMappedV12  = 'V' | NumberToString(nSourceIndex);\r\n            ElseIf(nTargetIndex = 13);\r\n              nMappedDim13 = 1;\r\n              sMappedV13  = 'V' | NumberToString(nSourceIndex);\r\n            ElseIf(nTargetIndex = 14);\r\n              nMappedDim14 = 1;\r\n              sMappedV14  = 'V' | NumberToString(nSourceIndex);\r\n            ElseIf(nTargetIndex = 15);\r\n              nMappedDim15 = 1;\r\n              sMappedV15  = 'V' | NumberToString(nSourceIndex);\r\n            ElseIf(nTargetIndex = 16);\r\n              nMappedDim16 = 1;\r\n              sMappedV16  = 'V' | NumberToString(nSourceIndex);\r\n            ElseIf(nTargetIndex = 17);\r\n              nMappedDim17 = 1;\r\n              sMappedV17  = 'V' | NumberToString(nSourceIndex);\r\n            ElseIf(nTargetIndex = 18);\r\n              nMappedDim18 = 1;\r\n              sMappedV18  = 'V' | NumberToString(nSourceIndex);\r\n            ElseIf(nTargetIndex = 19);\r\n              nMappedDim19 = 1;\r\n              sMappedV19  = 'V' | NumberToString(nSourceIndex);\r\n            ElseIf(nTargetIndex = 20);\r\n              nMappedDim20 = 1;\r\n              sMappedV20  = 'V' | NumberToString(nSourceIndex);\r\n            ElseIf(nTargetIndex = 21);\r\n              nMappedDim21 = 1;\r\n              sMappedV21  = 'V' | NumberToString(nSourceIndex);\r\n            ElseIf(nTargetIndex = 22);\r\n              nMappedDim22 = 1;\r\n              sMappedV22  = 'V' | NumberToString(nSourceIndex);\r\n            ElseIf(nTargetIndex = 23);\r\n              nMappedDim23 = 1;\r\n              sMappedV23  = 'V' | NumberToString(nSourceIndex);\r\n            ElseIf(nTargetIndex = 24);\r\n              nMappedDim24 = 1;\r\n              sMappedV24  = 'V' | NumberToString(nSourceIndex);\r\n            ElseIf(nTargetIndex = 25);\r\n              nMappedDim25 = 1;\r\n              sMappedV25  = 'V' | NumberToString(nSourceIndex);\r\n            ElseIf(nTargetIndex = 26);\r\n              nMappedDim26 = 1;\r\n              sMappedV26  = 'V' | NumberToString(nSourceIndex);\r\n            ElseIf(nTargetIndex = 27);\r\n              nMappedDim27 = 1;\r\n              sMappedV27  = 'V' | NumberToString(nSourceIndex);\r\n            EndIf;\r\n          ElseIf( pFile > 0 );\r\n            ## If using source file first variable holds tha cube name, so all the other ones have the index increased by 1\r\n            If(nTargetIndex = 1);\r\n              nMappedDim1 = 1;\r\n              sMappedV1  = 'V' | NumberToString(nSourceIndex + 1);\r\n            ElseIf(nTargetIndex = 2);\r\n              nMappedDim2 = 1;\r\n              sMappedV2  = 'V' | NumberToString(nSourceIndex + 1);\r\n            ElseIf(nTargetIndex = 3);\r\n              nMappedDim3 = 1;\r\n              sMappedV3  = 'V' | NumberToString(nSourceIndex + 1);\r\n            ElseIf(nTargetIndex = 4);\r\n              nMappedDim4 = 1;\r\n              sMappedV4  = 'V' | NumberToString(nSourceIndex + 1);\r\n            ElseIf(nTargetIndex = 5);\r\n              nMappedDim5 = 1;\r\n              sMappedV5  = 'V' | NumberToString(nSourceIndex + 1);\r\n            ElseIf(nTargetIndex = 6);\r\n              nMappedDim6 = 1;\r\n              sMappedV6  = 'V' | NumberToString(nSourceIndex + 1);\r\n            ElseIf(nTargetIndex = 7);\r\n              nMappedDim7 = 1;\r\n              sMappedV7  = 'V' | NumberToString(nSourceIndex + 1);\r\n            ElseIf(nTargetIndex = 8);\r\n              nMappedDim8 = 1;\r\n              sMappedV8  = 'V' | NumberToString(nSourceIndex + 1);\r\n            ElseIf(nTargetIndex = 9);\r\n              nMappedDim9 = 1;\r\n              sMappedV9  = 'V' | NumberToString(nSourceIndex + 1);\r\n            ElseIf(nTargetIndex = 10);\r\n              nMappedDim10 = 1;\r\n              sMappedV10  = 'V' | NumberToString(nSourceIndex + 1);\r\n            ElseIf(nTargetIndex = 11);\r\n              nMappedDim11 = 1;\r\n              sMappedV11  = 'V' | NumberToString(nSourceIndex + 1);\r\n            ElseIf(nTargetIndex = 12);\r\n              nMappedDim12 = 1;\r\n              sMappedV12  = 'V' | NumberToString(nSourceIndex + 1);\r\n            ElseIf(nTargetIndex = 13);\r\n              nMappedDim13 = 1;\r\n              sMappedV13  = 'V' | NumberToString(nSourceIndex + 1);\r\n            ElseIf(nTargetIndex = 14);\r\n              nMappedDim14 = 1;\r\n              sMappedV14  = 'V' | NumberToString(nSourceIndex + 1);\r\n            ElseIf(nTargetIndex = 15);\r\n              nMappedDim15 = 1;\r\n              sMappedV15  = 'V' | NumberToString(nSourceIndex + 1);\r\n            ElseIf(nTargetIndex = 16);\r\n              nMappedDim16 = 1;\r\n              sMappedV16  = 'V' | NumberToString(nSourceIndex + 1);\r\n            ElseIf(nTargetIndex = 17);\r\n              nMappedDim17 = 1;\r\n              sMappedV17  = 'V' | NumberToString(nSourceIndex + 1);\r\n            ElseIf(nTargetIndex = 18);\r\n              nMappedDim18 = 1;\r\n              sMappedV18  = 'V' | NumberToString(nSourceIndex + 1);\r\n            ElseIf(nTargetIndex = 19);\r\n              nMappedDim19 = 1;\r\n              sMappedV19  = 'V' | NumberToString(nSourceIndex + 1);\r\n            ElseIf(nTargetIndex = 20);\r\n              nMappedDim20 = 1;\r\n              sMappedV20  = 'V' | NumberToString(nSourceIndex + 1);\r\n            ElseIf(nTargetIndex = 21);\r\n              nMappedDim21 = 1;\r\n              sMappedV21  = 'V' | NumberToString(nSourceIndex + 1);\r\n            ElseIf(nTargetIndex = 22);\r\n              nMappedDim22 = 1;\r\n              sMappedV22  = 'V' | NumberToString(nSourceIndex + 1);\r\n            ElseIf(nTargetIndex = 23);\r\n              nMappedDim23 = 1;\r\n              sMappedV23  = 'V' | NumberToString(nSourceIndex + 1);\r\n            ElseIf(nTargetIndex = 24);\r\n              nMappedDim24 = 1;\r\n              sMappedV24  = 'V' | NumberToString(nSourceIndex + 1);\r\n            ElseIf(nTargetIndex = 25);\r\n              nMappedDim25 = 1;\r\n              sMappedV25  = 'V' | NumberToString(nSourceIndex + 1);\r\n            ElseIf(nTargetIndex = 26);\r\n              nMappedDim26 = 1;\r\n              sMappedV26  = 'V' | NumberToString(nSourceIndex + 1);\r\n            ElseIf(nTargetIndex = 27);\r\n              nMappedDim27 = 1;\r\n              sMappedV27  = 'V' | NumberToString(nSourceIndex + 1);\r\n            EndIf;\r\n          EndIf;\r\n\r\n      EndIf;\r\n\r\n      nTargetIndex = nTargetIndex + 1;\r\n\r\n    END;\r\n\r\n  nSourceIndex = nSourceIndex + 1;\r\n\r\nEND;\r\n\r\n# The last variable in the data source holds the values\r\n# which need to be mapped to the last variable in the target\r\n\r\nIf( pFile = 0 );\r\n  If(nTargetIndex = 1);\r\n    nMappedDim1 = 1;\r\n    sMappedV1  = 'V' | NumberToString(nSourceIndex);\r\n  ElseIf(nTargetIndex = 2);\r\n    nMappedDim2 = 1;\r\n    sMappedV2  = 'V' | NumberToString(nSourceIndex);\r\n  ElseIf(nTargetIndex = 3);\r\n    nMappedDim3 = 1;\r\n    sMappedV3  = 'V' | NumberToString(nSourceIndex);\r\n  ElseIf(nTargetIndex = 4);\r\n    nMappedDim4 = 1;\r\n    sMappedV4  = 'V' | NumberToString(nSourceIndex);\r\n  ElseIf(nTargetIndex = 5);\r\n    nMappedDim5 = 1;\r\n    sMappedV5  = 'V' | NumberToString(nSourceIndex);\r\n  ElseIf(nTargetIndex = 6);\r\n    nMappedDim6 = 1;\r\n    sMappedV6  = 'V' | NumberToString(nSourceIndex);\r\n  ElseIf(nTargetIndex = 7);\r\n    nMappedDim7 = 1;\r\n    sMappedV7  = 'V' | NumberToString(nSourceIndex);\r\n  ElseIf(nTargetIndex = 8);\r\n    nMappedDim8 = 1;\r\n    sMappedV8  = 'V' | NumberToString(nSourceIndex);\r\n  ElseIf(nTargetIndex = 9);\r\n    nMappedDim9 = 1;\r\n    sMappedV9  = 'V' | NumberToString(nSourceIndex);\r\n  ElseIf(nTargetIndex = 10);\r\n    nMappedDim10 = 1;\r\n    sMappedV10  = 'V' | NumberToString(nSourceIndex);\r\n  ElseIf(nTargetIndex = 11);\r\n    nMappedDim11 = 1;\r\n    sMappedV11  = 'V' | NumberToString(nSourceIndex);\r\n  ElseIf(nTargetIndex = 12);\r\n    nMappedDim12 = 1;\r\n    sMappedV12  = 'V' | NumberToString(nSourceIndex);\r\n  ElseIf(nTargetIndex = 13);\r\n    nMappedDim13 = 1;\r\n    sMappedV13  = 'V' | NumberToString(nSourceIndex);\r\n  ElseIf(nTargetIndex = 14);\r\n    nMappedDim14 = 1;\r\n    sMappedV14  = 'V' | NumberToString(nSourceIndex);\r\n  ElseIf(nTargetIndex = 15);\r\n    nMappedDim15 = 1;\r\n    sMappedV15  = 'V' | NumberToString(nSourceIndex);\r\n  ElseIf(nTargetIndex = 16);\r\n    nMappedDim16 = 1;\r\n    sMappedV16  = 'V' | NumberToString(nSourceIndex);\r\n  ElseIf(nTargetIndex = 17);\r\n    nMappedDim17 = 1;\r\n    sMappedV17  = 'V' | NumberToString(nSourceIndex);\r\n  ElseIf(nTargetIndex = 18);\r\n    nMappedDim18 = 1;\r\n    sMappedV18  = 'V' | NumberToString(nSourceIndex);\r\n  ElseIf(nTargetIndex = 19);\r\n    nMappedDim19 = 1;\r\n    sMappedV19  = 'V' | NumberToString(nSourceIndex);\r\n  ElseIf(nTargetIndex = 20);\r\n    nMappedDim20 = 1;\r\n    sMappedV20  = 'V' | NumberToString(nSourceIndex);\r\n  ElseIf(nTargetIndex = 21);\r\n    nMappedDim21 = 1;\r\n    sMappedV21  = 'V' | NumberToString(nSourceIndex);\r\n  ElseIf(nTargetIndex = 22);\r\n    nMappedDim22 = 1;\r\n    sMappedV22  = 'V' | NumberToString(nSourceIndex);\r\n  ElseIf(nTargetIndex = 23);\r\n    nMappedDim23 = 1;\r\n    sMappedV23  = 'V' | NumberToString(nSourceIndex);\r\n  ElseIf(nTargetIndex = 24);\r\n    nMappedDim24 = 1;\r\n    sMappedV24  = 'V' | NumberToString(nSourceIndex);\r\n  ElseIf(nTargetIndex = 25);\r\n    nMappedDim25 = 1;\r\n    sMappedV25  = 'V' | NumberToString(nSourceIndex);\r\n  ElseIf(nTargetIndex = 26);\r\n    nMappedDim26 = 1;\r\n    sMappedV26  = 'V' | NumberToString(nSourceIndex);\r\n  ElseIf(nTargetIndex = 27);\r\n    nMappedDim27 = 1;\r\n    sMappedV27  = 'V' | NumberToString(nSourceIndex);\r\n\r\n  # a cube with 27 dimensions uses V28 to hold the values\r\n  ElseIf(nTargetIndex = 28);\r\n    nMappedDim28 = 1;\r\n    sMapped28  = 'V' | NumberToString(nSourceIndex);\r\n  EndIf;\r\nElseIf( pFile > 0 );\r\n  If(nTargetIndex = 1);\r\n    nMappedDim1 = 1;\r\n    sMappedV1  = 'V' | NumberToString(nSourceIndex + 1);\r\n  ElseIf(nTargetIndex = 2);\r\n    nMappedDim2 = 1;\r\n    sMappedV2  = 'V' | NumberToString(nSourceIndex + 1);\r\n  ElseIf(nTargetIndex = 3);\r\n    nMappedDim3 = 1;\r\n    sMappedV3  = 'V' | NumberToString(nSourceIndex + 1);\r\n  ElseIf(nTargetIndex = 4);\r\n    nMappedDim4 = 1;\r\n    sMappedV4  = 'V' | NumberToString(nSourceIndex + 1);\r\n  ElseIf(nTargetIndex = 5);\r\n    nMappedDim5 = 1;\r\n    sMappedV5  = 'V' | NumberToString(nSourceIndex + 1);\r\n  ElseIf(nTargetIndex = 6);\r\n    nMappedDim6 = 1;\r\n    sMappedV6  = 'V' | NumberToString(nSourceIndex + 1);\r\n  ElseIf(nTargetIndex = 7);\r\n    nMappedDim7 = 1;\r\n    sMappedV7  = 'V' | NumberToString(nSourceIndex + 1);\r\n  ElseIf(nTargetIndex = 8);\r\n    nMappedDim8 = 1;\r\n    sMappedV8  = 'V' | NumberToString(nSourceIndex + 1);\r\n  ElseIf(nTargetIndex = 9);\r\n    nMappedDim9 = 1;\r\n    sMappedV9  = 'V' | NumberToString(nSourceIndex + 1);\r\n  ElseIf(nTargetIndex = 10);\r\n    nMappedDim10 = 1;\r\n    sMappedV10  = 'V' | NumberToString(nSourceIndex + 1);\r\n  ElseIf(nTargetIndex = 11);\r\n    nMappedDim11 = 1;\r\n    sMappedV11  = 'V' | NumberToString(nSourceIndex + 1);\r\n  ElseIf(nTargetIndex = 12);\r\n    nMappedDim12 = 1;\r\n    sMappedV12  = 'V' | NumberToString(nSourceIndex + 1);\r\n  ElseIf(nTargetIndex = 13);\r\n    nMappedDim13 = 1;\r\n    sMappedV13  = 'V' | NumberToString(nSourceIndex + 1);\r\n  ElseIf(nTargetIndex = 14);\r\n    nMappedDim14 = 1;\r\n    sMappedV14  = 'V' | NumberToString(nSourceIndex + 1);\r\n  ElseIf(nTargetIndex = 15);\r\n    nMappedDim15 = 1;\r\n    sMappedV15  = 'V' | NumberToString(nSourceIndex + 1);\r\n  ElseIf(nTargetIndex = 16);\r\n    nMappedDim16 = 1;\r\n    sMappedV16  = 'V' | NumberToString(nSourceIndex + 1);\r\n  ElseIf(nTargetIndex = 17);\r\n    nMappedDim17 = 1;\r\n    sMappedV17  = 'V' | NumberToString(nSourceIndex + 1);\r\n  ElseIf(nTargetIndex = 18);\r\n    nMappedDim18 = 1;\r\n    sMappedV18  = 'V' | NumberToString(nSourceIndex + 1);\r\n  ElseIf(nTargetIndex = 19);\r\n    nMappedDim19 = 1;\r\n    sMappedV19  = 'V' | NumberToString(nSourceIndex + 1);\r\n  ElseIf(nTargetIndex = 20);\r\n    nMappedDim20 = 1;\r\n    sMappedV20  = 'V' | NumberToString(nSourceIndex + 1);\r\n  ElseIf(nTargetIndex = 21);\r\n    nMappedDim21 = 1;\r\n    sMappedV21  = 'V' | NumberToString(nSourceIndex + 1);\r\n  ElseIf(nTargetIndex = 22);\r\n    nMappedDim22 = 1;\r\n    sMappedV22  = 'V' | NumberToString(nSourceIndex + 1);\r\n  ElseIf(nTargetIndex = 23);\r\n    nMappedDim23 = 1;\r\n    sMappedV23  = 'V' | NumberToString(nSourceIndex + 1);\r\n  ElseIf(nTargetIndex = 24);\r\n    nMappedDim24 = 1;\r\n    sMappedV24  = 'V' | NumberToString(nSourceIndex + 1);\r\n  ElseIf(nTargetIndex = 25);\r\n    nMappedDim25 = 1;\r\n    sMappedV25  = 'V' | NumberToString(nSourceIndex + 1);\r\n  ElseIf(nTargetIndex = 26);\r\n    nMappedDim26 = 1;\r\n    sMappedV26  = 'V' | NumberToString(nSourceIndex + 1);\r\n  ElseIf(nTargetIndex = 27);\r\n    nMappedDim27 = 1;\r\n    sMappedV27  = 'V' | NumberToString(nSourceIndex + 1);\r\n\r\n  # a cube with 27 dimensions uses V29 to hold the values if export file is used as source\r\n  ElseIf(nTargetIndex = 28);\r\n    nMappedDim28 = 1;\r\n    sMapped28  = 'V' | NumberToString(nSourceIndex + 1);\r\n  EndIf;\r\nEndIf;\r\n#EndRegion\r\n\r\n###########################################\r\n### SPLIT MAPPING TO NEW DIMS PARAMETER ###\r\n###########################################\r\n\r\n# now deduct 1 to set these indices to the number of dimensions in each cube\r\nnSourceDimensionCount       = nSourceIndex - 1;\r\nnTargetCubeDimensionCount   = nTargetIndex - 1;\r\n# default dimension count is for target\r\nnDimensionCount = nTargetIndex - 1;\r\n\r\nsElementMapping = TRIM( pMappingToNewDims );\r\nnChar = 1;\r\nnCharCount = LONG( sElementMapping );\r\n\r\nsTargetFilter = '';\r\nsWord = '';\r\nsLastDelim = '';\r\nnIndex = 1;\r\n\r\n# Add a trailing element delimiter so that the last element is picked up\r\nIf( nCharCount > 0 );\r\n  sElementMapping = sElementMapping | sDelimDim;\r\n  nCharCount = nCharCount + LONG(sDelimDim);\r\nEndIf;\r\n\r\nWHILE (nChar <= nCharCount);\r\n    sChar = SUBST( sElementMapping, nChar, 1);\r\n\r\n    # Used for delimiters, required for multiple character delimiters\r\n    sDelim = '';\r\n    nAddExtra = 0;\r\n\r\n    # Ignore spaces\r\n    IF (TRIM(sChar) @<> '' );\r\n\r\n      ### Dimension Name ###\r\n\r\n      # If the delimiter is more than 1 character peek ahead the same amount\r\n      # Ignore the first character\r\n      sDelim = sChar;\r\n      nCount = LONG(sElementStartDelim) - 1;\r\n      If( nCount > 0 & nChar + nCount <= nCharCount );\r\n        # Add the extra characters\r\n        sDelim = sDelim | SUBST( sElementMapping, nChar + 1, nCount);\r\n        # Move to the end of the delimter\r\n        nAddExtra = nCount;\r\n      EndIf;\r\n\r\n      If( sDelim @= sElementStartDelim );\r\n\r\n        sChar = sDelim;\r\n\r\n        If( sLastDelim @<> '' & sLastDelim @<> sDelimDim );\r\n            sMessage = 'In pMappingToNewDims the name of a dimension must follow a dimension delimiter (' | sDelimDim | ')';\r\n            nErrors = nErrors + 1;\r\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n            #ProcessError();\r\n        EndIf;\r\n\r\n        # Found a dimension\r\n        sDimension = sWord;\r\n\r\n        If( DimensionExists( sDimension ) = 0 );\r\n            # The dimension does not exist in the model. Cancel process\r\n            sMessage = 'In pMappingToNewDims - Dimension: ' | sDimension | ' does not exist';\r\n            nErrors = nErrors + 1;\r\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n            #ProcessError();\r\n        EndIf;\r\n\r\n        # Find the index of the dimension is in the Target cube\r\n        nTargetIndexCounter = 1;\r\n\r\n        WHILE(nTargetIndexCounter <= nTargetCubeDimensionCount );\r\n          sNthDimension = TabDim( pTgtCube, nTargetIndexCounter );\r\n\r\n          If(sDimension @= sNthDimension);\r\n            nTargetIndex = nTargetIndexCounter;\r\n            nTargetIndexCounter = 1000;\r\n          EndIf;\r\n\r\n          nTargetIndexCounter = nTargetIndexCounter + 1;\r\n        END;\r\n\r\n        #Add to the Target filter\r\n        IF(sTargetFilter@='');\r\n          sTargetFilter=sDimension;\r\n        Else;\r\n          sTargetFilter=sTargetFilter|sDelimDim|sDimension;\r\n        Endif;\r\n\r\n        sLastDelim = sChar;\r\n        # Clear the word\r\n        sWord = '';\r\n\r\n      Else;\r\n\r\n        # Reset extra chars\r\n        nAddExtra = 0;\r\n\r\n        ### Check both dim delimiter and element delimiter ###\r\n        nIsDelimiter = 0;\r\n\r\n        ## Check dimension delimiter first\r\n        # If the delimiter is more than 1 character peek ahead the same amount\r\n        # Ignore the first character\r\n        sDelim = sChar;\r\n        nCount = LONG(sDelimDim) - 1;\r\n        If( nCount > 0 & nChar + nCount <= nCharCount );\r\n          # Add the extra characters\r\n          sDelim = sDelim | SUBST( sElementMapping, nChar + 1, nCount);\r\n          # Move to the end of the delimter\r\n          nAddExtra = nCount;\r\n        EndIf;\r\n\r\n        If( sDelim @= sDelimDim );\r\n          nIsDelimiter = 1;\r\n          sChar = sDelim;\r\n        EndIf;\r\n\r\n        If ( nIsDelimiter = 1 );\r\n\r\n          If( sLastDelim @= '' % sLastDelim @= sDelimDim );\r\n            sMessage = 'In pMappingToNewDims - an element delimiter must follow a dimension name: ' |  sChar | ' (' | NumberToString(nChar) | ')';\r\n            nErrors = nErrors + 1;\r\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n            #ProcessError();\r\n          EndIf;\r\n\r\n          # an element has been found\r\n          sElement = sWord;\r\n\r\n          If( DIMIX( sDimension, sElement ) = 0 );\r\n              # The element does not exist in the dimension. Cancel process\r\n              sMessage = 'In pMappingToNewDims - Element: ' | sElement | ' in dimension ' | sDimension | ' does not exist';\r\n              nErrors = nErrors + 1;\r\n              LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n              #ProcessError();\r\n          EndIf;\r\n\r\n          # Allow consolidations only if pSuppressConsol is set to 0\r\n\r\n          If ( DTYPE( sDimension, sElement) @= 'C' );\r\n            sMessage = Expand( 'In pMappingToNewDims - Target element: %sElement% for dimension %sDimension% is consolidated' );\r\n            nErrors = nErrors + 1;\r\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n            #ProcessError();\r\n          Endif;\r\n\r\n\r\n          # Add the element to the source or target depending on whether it's the first or the second element\r\n          # Get principal name\r\n          # in case source element and this element are using different aliases\r\n\r\n          sElement = DimensionElementPrincipalName(sDimension,sElement);\r\n\r\n          ### Update the variable for InputElement Target Dim ######################################\r\n          If(nTargetIndex = 1);\r\n            nNewDim1 = 1;\r\n            sNewV1 = sElement;\r\n          ElseIf(nTargetIndex = 2);\r\n            nNewDim2 = 1;\r\n            sNewV2 = sElement;\r\n          ElseIf(nTargetIndex = 3);\r\n            nNewDim3 = 1;\r\n            sNewV3 = sElement;\r\n          ElseIf(nTargetIndex = 4);\r\n            nNewDim4 = 1;\r\n            sNewV4 = sElement;\r\n          ElseIf(nTargetIndex = 5);\r\n            nNewDim5 = 1;\r\n            sNewV5 = sElement;\r\n          ElseIf(nTargetIndex = 6);\r\n            nNewDim6 = 1;\r\n            sNewV6 = sElement;\r\n          ElseIf(nTargetIndex = 7);\r\n            nNewDim7 = 1;\r\n            sNewV7 = sElement;\r\n          ElseIf(nTargetIndex = 8);\r\n            nNewDim8 = 1;\r\n            sNewV8 = sElement;\r\n          ElseIf(nTargetIndex = 9);\r\n            nNewDim9 = 1;\r\n            sNewV9 = sElement;\r\n          ElseIf(nTargetIndex = 10);\r\n            nNewDim10 = 1;\r\n            sNewV10 = sElement;\r\n          ElseIf(nTargetIndex = 11);\r\n            nNewDim11 = 1;\r\n            sNewV11 = sElement;\r\n          ElseIf(nTargetIndex = 12);\r\n            nNewDim12 = 1;\r\n            sNewV12 = sElement;\r\n          ElseIf(nTargetIndex = 13);\r\n            nNewDim13 = 1;\r\n            sNewV13 = sElement;\r\n          ElseIf(nTargetIndex = 14);\r\n            nNewDim14 = 1;\r\n            sNewV14 = sElement;\r\n          ElseIf(nTargetIndex = 15);\r\n            nNewDim15 = 1;\r\n            sNewV15 = sElement;\r\n          ElseIf(nTargetIndex = 16);\r\n            nNewDim16 = 1;\r\n            sNewV16 = sElement;\r\n          ElseIf(nTargetIndex = 17);\r\n            nNewDim17 = 1;\r\n            sNewV17 = sElement;\r\n          ElseIf(nTargetIndex = 18);\r\n            nNewDim18 = 1;\r\n            sNewV18 = sElement;\r\n          ElseIf(nTargetIndex = 19);\r\n            nNewDim19 = 1;\r\n            sNewV19 = sElement;\r\n          ElseIf(nTargetIndex = 20);\r\n            nNewDim20 = 1;\r\n            sNewV20 = sElement;\r\n          ElseIf(nTargetIndex = 21);\r\n            nNewDim21 = 1;\r\n            sNewV21 = sElement;\r\n          ElseIf(nTargetIndex = 22);\r\n            nNewDim22 = 1;\r\n            sNewV22 = sElement;\r\n          ElseIf(nTargetIndex = 23);\r\n            nNewDim23 = 1;\r\n            sNewV23 = sElement;\r\n          ElseIf(nTargetIndex = 24);\r\n            nNewDim24 = 1;\r\n            sNewV24 = sElement;\r\n          ElseIf(nTargetIndex = 25);\r\n            nNewDim25 = 1;\r\n            sNewV25 = sElement;\r\n          ElseIf(nTargetIndex = 26);\r\n            nNewDim26 = 1;\r\n            sNewV26 = sElement;\r\n          ElseIf(nTargetIndex = 27);\r\n            nNewDim27 = 1;\r\n            sNewV27 = sElement;\r\n          EndIf;\r\n\r\n          #Add to the Target filter\r\n          sTargetFilter=sTargetFilter|sElementStartDelim|sElement;\r\n\r\n          # Clear the word\r\n          sWord = '';\r\n          sLastDelim = sChar;\r\n\r\n        Else;\r\n          sWord = sWord | sChar;\r\n        EndIf;\r\n\r\n      EndIf;\r\n\r\n    EndIf;\r\n\r\n    nChar = nChar + nAddExtra + 1;\r\n\r\nEND;\r\n\r\n# Check that an input element or variable has been specified for all dimensions in the target cube\r\n\r\nnIndexInTarget = 1;\r\nWHILE(nIndexInTarget <= nTargetCubeDimensionCount);\r\n\r\n      sMapped   = Expand('%nMappedDim'| NumberToString(nIndexInTarget) |'%');\r\n      sMapped   = Subst( sMapped , Scan( '.' , sMapped )-1 , 99);\r\n      nMapped   = StringToNumber( Trim( sMapped ) );\r\n      sNew      = Expand('%nNewDim'| NumberToString(nIndexInTarget) |'%');\r\n      sNew      = Subst( sNew , Scan( '.' , sNew )-1 , 99);\r\n      nNew      = StringToNumber( Trim( sNew ) );\r\n\r\n      If(nMapped = 0 & nNew = 0 );\r\n            # there's no input element and this dimension is not in the source\r\n            nErrors         = nErrors + 1;\r\n            sTargetDimName  = TabDim( pTgtCube,  nIndexInTarget );\r\n            sMessage        = 'Dimension ' | sTargetDimName | ' is missing an input element in pMappingToNewDims';\r\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n            If( pStrictErrorHandling = 1 );\r\n                ProcessQuit;\r\n            Else;\r\n                ProcessBreak;\r\n            EndIf;\r\n       EndIf;\r\n\r\n       nIndexInTarget = nIndexInTarget + 1;\r\nEND;\r\n\r\n\r\n############################# Clear out target ################################\r\n\r\n# Target is cleared for the elements specified in pMappingToNewDims\r\n# and for the parts of pFilter for dimensions in the target\r\n# This code works through pFilter looking for the parts relating to the target cube\r\n# the code which finds individual elements has been left in\r\n# so that it can be changed later to deal with consolidated elements\r\n\r\nsFilter = TRIM( pFilter );\r\nnChar = 1;\r\nnCharCount = LONG( sFilter );\r\nsWord = '';\r\nsLastDelim = '';\r\n\r\n# Add a trailing element delimiter so that the last Dimension:Element/s clause is picked up\r\nIf( nCharCount > 0 );\r\n  sFilter = sFilter | sDelimElem;\r\n  nCharCount = nCharCount + LONG(sDelimElem);\r\nEndIf;\r\n\r\nWHILE (nChar <= nCharCount);\r\n\r\n    sChar = SUBST( sFilter, nChar, 1);\r\n\r\n    # Used for delimiters, required for multiple character dilimiters\r\n    sDelim = '';\r\n    nAddExtra = 0;\r\n\r\n    # Ignore spaces\r\n    IF (TRIM(sChar) @<> '' );\r\n\r\n      ### Dimension Name ###\r\n\r\n      # If the delimiter is more than 1 character peek ahead the same amount\r\n      # Ignore the first character\r\n      sDelim = sChar;\r\n      nCount = LONG(sElementStartDelim) - 1;\r\n      If( nCount > 0 & nChar + nCount <= nCharCount );\r\n        # Add the extra characters\r\n        sDelim = sDelim | SUBST( sFilter, nChar + 1, nCount);\r\n        # Move to the end of the delimter\r\n        nAddExtra = nCount;\r\n      EndIf;\r\n\r\n      If( sDelim @= sElementStartDelim );\r\n\r\n        sChar = sDelim;\r\n\r\n        If( sLastDelim @<> '' & sLastDelim @<> sDelimDim );\r\n          sMessage = 'In pFilter - the name of a dimension must follow a dimension delimiter (' | sDelimDim | ')';\r\n          nErrors = nErrors + 1;\r\n          LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n          #ProcessError();\r\n        EndIf;\r\n\r\n        # Found a dimension!\r\n        sDimension = UPPER( sWord );\r\n        nDimInTgt=0;\r\n        # See if the dimension is in the target cube\r\n        IF(scan('^^'|sDimension|'^^', sTgtDimString)>0);\r\n          If(sTargetFilter@='');\r\n            sTargetFilter = sDimension;\r\n          Else;\r\n            sTargetFilter = sTargetFilter | sDelimDim | sDimension;\r\n          endif;\r\n          nDimInTgt=1;\r\n        Endif;\r\n\r\n        sLastDelim = sChar;\r\n        # Clear the word\r\n        sWord = '';\r\n        #reset element count\r\n        nElementCount = 1;\r\n\r\n      Else;\r\n\r\n        # Reset extra chars\r\n        nAddExtra = 0;\r\n\r\n        ### Check both both dim delimiter and element delimiter ###\r\n        nIsDelimiter = 0;\r\n\r\n        ## Check dimension delimiter first\r\n        # If the delimiter is more than 1 character peek ahead the same amount\r\n        # Ignore the first character\r\n        sDelim = sChar;\r\n        nCount = LONG(sDelimDim) - 1;\r\n        If( nCount > 0 & nChar + nCount <= nCharCount );\r\n          # Add the extra characters\r\n          sDelim = sDelim | SUBST( sFilter, nChar + 1, nCount);\r\n          # Move to the end of the delimter\r\n          nAddExtra = nCount;\r\n        EndIf;\r\n\r\n        If( sDelim @= sDelimDim );\r\n          nIsDelimiter = 1;\r\n          sChar = sDelim;\r\n        Else;\r\n          # Reset extra chars\r\n          nAddExtra = 0;\r\n\r\n          ## Check element delimiter\r\n\r\n          # If the delimiter is more than 1 character peek ahead the same amount\r\n          # Ignore the first character\r\n          sDelim = sChar;\r\n          nCount = LONG(sDelimElem) - 1;\r\n          If( nCount > 0 & nChar + nCount <= nCharCount );\r\n            # Add the extra characters\r\n            sDelim = sDelim | SUBST( sFilter, nChar + 1, nCount);\r\n            # Move to the end of the delimter\r\n            nAddExtra = nCount;\r\n          EndIf;\r\n\r\n          If( sDelim @= sDelimElem );\r\n            nIsDelimiter = 1;\r\n            sChar = sDelim;\r\n          Else;\r\n            # Reset extra chars\r\n            nAddExtra = 0;\r\n          EndIf;\r\n\r\n        EndIf;\r\n\r\n        If ( nIsDelimiter = 1 );\r\n\r\n          If( sLastDelim @= '' % sLastDelim @= sDelimDim );\r\n            sMessage = 'In pFilter - an element delimiter must follow a dimension name: ' |  sChar | ' (' | NumberToString(nChar) | ')';\r\n            nErrors = nErrors + 1;\r\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n            #ProcessError();\r\n          EndIf;\r\n\r\n          # Found an element\r\n          sElement = sWord;\r\n\r\n          IF(DIMIX(sDimension, sElement) > 0 & nDimInTgt=1);\r\n              # first element\r\n              IF(nElementCount = 1);\r\n                sTargetFilter = sTargetFilter | sElementStartDelim | sElement;\r\n              # later elements\r\n              Else;\r\n                sTargetFilter = sTargetFilter | sDelimElem | sElement;\r\n              EndIf;\r\n          EndIf;\r\n\r\n          nElementCount = nElementCount + 1;\r\n          sLastDelim = sChar;\r\n\r\n          # Clear the word\r\n          sWord = '';\r\n        Else;\r\n          sWord = sWord | sChar;\r\n        EndIf;\r\n\r\n      EndIf;\r\n\r\n    EndIf;\r\n\r\n    nChar = nChar + nAddExtra + 1;\r\n\r\nEND;\r\n\r\n### Check for errors before continuing\r\nIf( nErrors <> 0 );\r\n  If( pStrictErrorHandling = 1 );\r\n      ProcessQuit;\r\n  Else;\r\n      ProcessBreak;\r\n  EndIf;\r\nEndIf;\r\n\r\n# Branch depending on whether to do recursive calls to self on independent threads or run all in this thread\r\nIf( Scan( pEleStartDelim, pFilterParallel ) > 0 );\r\n  sDimParallel = SubSt( pFilterParallel, 1, Scan( pEleStartDelim, pFilterParallel ) - 1 );\r\n  sElementList = SubSt( pFilterParallel, Scan( pEleStartDelim, pFilterParallel ) + 1, Long( pFilterParallel ) );\r\n  If( SubSt( sElementList, Long( sElementList ), 1 ) @<> pEleDelim );\r\n      sElementList = sElementList | pEleDelim;\r\n  EndIf;\r\n  ## Counting elements in element list\r\n  sElementListCount = sElementList;\r\n  nElements = 0;\r\n  While( Scan( pEleDelim, sElementListCount ) > 0 );\r\n    nElements = nElements + 1;\r\n    sElementListCount = SubSt( sElementListCount, Scan( pEleDelim, sElementListCount ) + 1, Long( sElementListCount ) );\r\n  End;\r\n  IF( Mod( nElements, nMaxThreads ) = 0 );\r\n    nElemsPerThread = INT( nElements / nMaxThreads );\r\n  ELSE;\r\n    nElemsPerThread = INT( nElements / nMaxThreads ) + 1;\r\n  ENDIF;\r\n  nThreadElCounter = 0;\r\n  While( Scan( pEleDelim, sElementList ) > 0 );\r\n      sSlicerEle = SubSt( sElementList, 1, Scan( pEleDelim, sElementList ) - 1 );\r\n      sElementList = SubSt( sElementList, Scan( pEleDelim, sElementList ) + 1, Long( sElementList ) );\r\n      # Do recursive process call with new RunProcess function\r\n      nThreadElCounter = nThreadElCounter + 1;\r\n      sDimDelim = If(pFilter @= '', '', pDimDelim );\r\n      IF( nThreadElCounter = 1 );\r\n        sFilter = Expand('%pFilter%%sDimDelim%%sDimParallel%%pEleStartDelim%%sSlicerEle%');\r\n      ELSE;\r\n        sFilter = Expand('%sFilter%%pEleDelim%%sSlicerEle%');\r\n      ENDIF;\r\n      IF( nThreadElCounter >= nElemsPerThread );\r\n        RunProcess( cThisProcName, 'pLogoutput', pLogoutput,\r\n        \t'pSrcCube', pSrcCube, 'pFilter', sFilter, 'pFilterParallel', '', 'pTgtCube', pTgtCube, 'pMappingToNewDims', pMappingToNewDims,\r\n        \t'pSuppressConsol', pSuppressConsol, 'pSuppressConsolStrings', pSuppressConsolStrings, 'pSuppressRules', pSuppressRules, 'pSuppressZero', pSuppressZero, 'pZeroTarget', pZeroTarget, 'pZeroSource', pZeroSource,\r\n          'pFactor', pFactor, 'pDimDelim', pDimDelim, 'pEleStartDelim', pEleStartDelim, 'pEleDelim', pEleDelim,\r\n          'pTemp', pTemp, 'pCubeLogging', pCubeLogging, 'pSandbox', pSandbox, 'pFile', pFile, 'pThreadMode', 1\r\n        );\r\n    \t  nThreadElCounter = 0;\r\n    \t  sFilter = '';\r\n    \t ENDIF;\r\n  End;\r\n  ## Process last elements - only when filter is not empty (there are still elements)\r\n  IF( sFilter @<> '' );\r\n    RunProcess( cThisProcName, 'pLogoutput', pLogoutput,\r\n    \t'pSrcCube', pSrcCube, 'pFilter', sFilter, 'pFilterParallel', '', 'pTgtCube', pTgtCube, 'pMappingToNewDims', pMappingToNewDims,\r\n    \t'pSuppressConsol', pSuppressConsol, 'pSuppressConsolStrings', pSuppressConsolStrings, 'pSuppressRules', pSuppressRules, 'pSuppressZero', pSuppressZero, 'pZeroTarget', pZeroTarget, 'pZeroSource', pZeroSource,\r\n      'pFactor', pFactor, 'pDimDelim', pDimDelim, 'pEleStartDelim', pEleStartDelim, 'pEleDelim', pEleDelim,\r\n      'pTemp', pTemp, 'pCubeLogging', pCubeLogging, 'pSandbox', pSandbox, 'pFile', pFile, 'pThreadMode', 1\r\n    );\r\n  ENDIF;\r\n  DataSourceType = 'NULL';\r\nElse;\r\n  # Clear out target view\r\n  If(pZeroTarget = 1 & LONG(sTargetFilter)>= 0 & nErrors = 0);\r\n      ###### Create View of target to clear out ###\r\n      # Create View of target ###\r\n      nRet = ExecuteProcess('}bedrock.cube.view.create',\r\n          'pLogOutput', pLogOutput,\r\n          'pStrictErrorHandling', pStrictErrorHandling,\r\n          'pCube', pTgtCube,\r\n          'pView', sTargetView ,\r\n          'pFilter', sTargetFilter,\r\n          'pSuppressZero', pSuppressZero,\r\n          'pSuppressConsol', pSuppressConsol,\r\n          'pSuppressRules', pSuppressRules,\r\n          'pSuppressConsolStrings', pSuppressConsolStrings,\r\n          'pDimDelim', pDimDelim,\r\n          'pEleStartDelim', pEleStartDelim,\r\n          'pEleDelim', pEleDelim ,\r\n          'pTemp', pTemp\r\n          );\r\n\r\n      IF(nRet <> 0);\r\n          sMessage = 'Error creating the view from the filter.';\r\n          nErrors = nErrors + 1;\r\n          LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n          If( pStrictErrorHandling = 1 );\r\n              ProcessQuit;\r\n          Else;\r\n              ProcessBreak;\r\n          EndIf;\r\n      ENDIF;\r\n\r\n      nRet = ExecuteProcess( '}bedrock.cube.data.clear',\r\n          'pLogOutput', pLogOutput,\r\n          'pStrictErrorHandling', pStrictErrorHandling,\r\n          'pCube', pTgtCube,\r\n          'pView', sTargetView,\r\n          'pFilter', sTargetFilter,\r\n          'pDimDelim', pDimDelim,\r\n          'pEleStartDelim', pEleStartDelim,\r\n          'pEleDelim', pEleDelim,\r\n          'pTemp', pTemp,\r\n          'pCubeLogging', pCubeLogging,\r\n          'pSandbox', pSandbox\r\n          );\r\n\r\n      IF(nRet <> 0);\r\n          sMessage = 'Error clearing the target view.';\r\n          nErrors = nErrors + 1;\r\n          LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n          If( pStrictErrorHandling = 1 );\r\n              ProcessQuit;\r\n          Else;\r\n              ProcessBreak;\r\n          EndIf;\r\n      ENDIF;\r\n\r\n  Endif;\r\n\r\n  If( pFile = 0 );\r\n    ### Create View of Source ###\r\n    IF(pSuppressConsol = 0 & pSuppressConsolStrings = 1);\r\n      pSubN=1;\r\n    else;\r\n      pSubN=0;\r\n    Endif;\r\n\r\n    nRet = ExecuteProcess('}bedrock.cube.view.create',\r\n      'pLogOutput', pLogOutput,\r\n      'pStrictErrorHandling', pStrictErrorHandling,\r\n      'pCube', pSrcCube,\r\n      'pView', sView,\r\n      'pFilter', pFilter,\r\n      'pSuppressZero', pSuppressZero,\r\n      'pSuppressConsol', pSuppressConsol,\r\n      'pSuppressRules', pSuppressRules,\r\n      'pSuppressConsolStrings', pSuppressConsolStrings,\r\n      'pDimDelim', pDimDelim,\r\n      'pEleStartDelim', pEleStartDelim,\r\n      'pEleDelim', pEleDelim ,\r\n      'pTemp', pTemp,\r\n      'pSubN', pSubN\r\n      );\r\n\r\n    IF(nRet <> 0);\r\n          sMessage = 'Error creating the view from the filter.';\r\n          nErrors = nErrors + 1;\r\n          LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n          If( pStrictErrorHandling = 1 );\r\n              ProcessQuit;\r\n          Else;\r\n              ProcessBreak;\r\n          EndIf;\r\n    ENDIF;\r\n\r\n  ElseIf( pFile > 0 );\r\n    ### Export to File in case of Copy Data Via File ###\r\n    IF(pSuppressConsol = 0);\r\n      pSubN=1;\r\n    else;\r\n      pSubN=0;\r\n    Endif;\r\n\r\n    nRet = ExecuteProcess('}bedrock.cube.data.export',\r\n       'pLogoutput', pLogOutput,\r\n       'pStrictErrorHandling', pStrictErrorHandling,\r\n       'pCube', pSrcCube,\r\n       'pView', sView,\r\n       'pFilter', pFilter,\r\n       'pFilterParallel', '',\r\n       'pParallelThreads', 0,\r\n       'pDimDelim', pDimDelim,\r\n       'pEleStartDelim', pEleStartDelim,\r\n       'pEleDelim', pEleDelim,\r\n       'pSuppressZero', pSuppressZero,\r\n       'pSuppressConsol', pSuppressConsol,\r\n       'pSuppressRules', pSuppressRules,\r\n       'pSuppressConsolStrings', pSuppressConsolStrings,\r\n       'pZeroSource', 0,\r\n       'pCubeLogging', pCubeLogging,\r\n       'pTemp', pTemp,\r\n       'pFilePath', cDir,\r\n       'pFileName', cFileName,\r\n       'pDelim', cDelimiter,\r\n       'pDecimalSeparator', sDecimalSeparator,\r\n       'pThousandSeparator', sThousandSeparator,\r\n       'pQuote', cQuote,\r\n       'pTitleRecord', cTitleRows,\r\n       'pSandbox', pSandbox,\r\n       'pSubN', pSubN\r\n      );\r\n\r\n    IF(nRet <> 0);\r\n          sMessage = 'Error exporting data to file.';\r\n          nErrors = nErrors + 1;\r\n          LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n          If( pStrictErrorHandling = 1 );\r\n              ProcessQuit;\r\n          Else;\r\n              ProcessBreak;\r\n          EndIf;\r\n    ENDIF;\r\n  ENDIF;\r\n\r\n  If ( pCubeLogging <= 1 );\r\n    sCubeLogging = CellGetS('}CubeProperties', pTgtCube, 'LOGGING' );\r\n    CubeSetLogChanges( pTgtCube, pCubeLogging);\r\n  EndIf;\r\n\r\n  ### Assign Datasource ###\r\n  If( pFile = 0 );\r\n    DataSourceType          = 'VIEW';\r\n    DatasourceNameForServer = pSrcCube;\r\n    DatasourceNameForClient = pSrcCube;\r\n    DatasourceCubeView      = sView;\r\n  ElseIf( pFile > 0 );\r\n    DataSourceType                  = 'CHARACTERDELIMITED';\r\n    DatasourceNameForServer         = cFile;\r\n    DatasourceNameForClient         = cFile;\r\n    DatasourceASCIIHeaderRecords    = cTitleRows;\r\n    DatasourceASCIIDelimiter        = cDelimiter;\r\n    DatasourceASCIIQuoteCharacter   = cQuote;\r\n  EndIf;\r\nEndIf;\r\n\r\n### End Prolog ###",
    "UIData": "CubeAction=1511\fDataAction=1503\fCubeLogChanges=0\f",
    "Variables": [
        {
            "EndByte": 0,
            "Name": "V1",
            "Position": 1,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V2",
            "Position": 2,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V3",
            "Position": 3,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V4",
            "Position": 4,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V5",
            "Position": 5,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V6",
            "Position": 6,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V7",
            "Position": 7,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V8",
            "Position": 8,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V9",
            "Position": 9,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V10",
            "Position": 10,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V11",
            "Position": 11,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V12",
            "Position": 12,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V13",
            "Position": 13,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V14",
            "Position": 14,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V15",
            "Position": 15,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V16",
            "Position": 16,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V17",
            "Position": 17,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V18",
            "Position": 18,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V19",
            "Position": 19,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V20",
            "Position": 20,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V21",
            "Position": 21,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V22",
            "Position": 22,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V23",
            "Position": 23,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V24",
            "Position": 24,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V25",
            "Position": 25,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V26",
            "Position": 26,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V27",
            "Position": 27,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V28",
            "Position": 28,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V29",
            "Position": 29,
            "StartByte": 0,
            "Type": "String"
        }
    ],
    "VariablesUIData": []
}