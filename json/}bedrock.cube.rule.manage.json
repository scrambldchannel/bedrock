{
    "DataProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n",
    "DataSource": {
        "Type": "None"
    },
    "EpilogProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n################################################################################################# ####################\r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock Ver 4.0~~##\r\n#################################################################################################\r\n\r\n\r\n### Return code & final error message handling\r\nIf( nErrors > 0 );\r\n    sMessage = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\r\n    nProcessReturnCode = 0;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\r\n    If( pStrictErrorHandling = 1 );\r\n        ProcessQuit;\r\n    EndIf;\r\nElse;\r\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully %pMode% cube rule from cube %pCube% .' );\r\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\r\n    nProcessReturnCode = 1;\r\n    If( pLogoutput = 1 );\r\n        LogOutput('INFO', Expand( sProcessAction ) );\r\n    EndIf;\r\nEndIf;\r\n\r\n### End Epilog ###",
    "HasSecurityAccess": true,
    "MetadataProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****",
    "Name": "}bedrock.cube.rule.manage",
    "Parameters": [
        {
            "Name": "pLogOutput",
            "Prompt": "OPTIONAL: Write parameters and action summary to server message log (Boolean True = 1)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pStrictErrorHandling",
            "Prompt": "OPTIONAL: On encountering any error exit with major error status by ProcessQuit after writing to the server message log (Boolean True = 1)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pCube",
            "Prompt": "REQUIRED: Cube Name to Load/Unload rule (Separated by Delimiter Accepts Wild card)",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pMode",
            "Prompt": "REQUIRED: Load/Unload the cube rule (=Load the file name should be available in the data directory with the required file name Suffix)",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pFileName",
            "Prompt": "OPTIONAL: Full file name for storing the rule (if empty = cube name.txt)",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pDelim",
            "Prompt": "OPTIONAL: Delimiter  (default value if blank = '&')",
            "Type": "String",
            "Value": "&"
        },
        {
            "Name": "pPath",
            "Prompt": "OPTIONAL: Saves the file and the backup of the existing rule in this location. If Null backup will be saved in Data Directory. Default value Null",
            "Type": "String",
            "Value": ""
        }
    ],
    "PrologProcedure": "#Region CallThisProcess\r\n# A snippet of code provided as an example how to call this process should the developer be working on a system without access to an editor with auto-complete.\r\nIf( 1 = 0 );\r\n    ExecuteProcess( '}bedrock.cube.rule.manage', 'pLogOutput', pLogOutput,\r\n      'pStrictErrorHandling', pStrictErrorHandling,\r\n    \t'pCube', '', 'pMode', '',\r\n    \t'pFileName', '', 'pDelim','&',\r\n    \t'pPath', ''\r\n\t);\r\nEndIf;\r\n#EndRegion CallThisProcess\r\n\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n################################################################################################# ####################\r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock Ver 4.0~~##\r\n#################################################################################################\r\n\r\n#Region @DOC\r\n# Description:\r\n# This process will backup & remove **OR** re-attach the rule file to cube.\r\n\r\n# Use case: Intended to be used in production.\r\n# 1/ Remove rule file before data load to speed up data load.\r\n# 2/ Re-attach rule file after data load.\r\n\r\n# Note:\r\n# Naturally, a valid cube name (pCube) is mandatory otherwise the process will abort.\r\n# The mandatory pMode parameter must be set to 'Unload' to remove/unload the rule file.\r\n# The pMode parameter must be set to 'Load' to re-attach the rule file and apply the rules.\r\n#EndRegion @DOC\r\n\r\n##Global Variables\r\nStringGlobalVariable('sProcessReturnCode');\r\nNumericGlobalVariable('nProcessReturnCode');\r\nnProcessReturnCode= 0;\r\n\r\n### Constants ###\r\n\r\ncThisProcName       = GetProcessName();\r\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\r\ncRandomInt          = NumberToString( INT( RAND( ) * 1000 ));\r\ncTempSub            = cThisProcName | '_' | cTimeStamp | '_' | cRandomInt;\r\ncCubeDim            = '}Cubes';\r\ncCubeHier           = cCubeDim;\r\nsPath               = '';\r\ncUserName           = TM1User();\r\ncMsgErrorLevel      = 'ERROR';\r\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\r\ncLogInfo            = 'Process:%cThisProcName% run with parameters pCube:%pCube%, pMode:%pMode%, pFileName:%pFileName%, pDelim:%pDelim%, pPath:%pPath%.' ;\r\ncDimCubes           = '}Cubes';\r\n\r\n## check operating system\r\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\r\n  sOS = 'Windows';\r\n  sOSDelim = '\\';\r\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0 );\r\n  sOS = 'Linux';\r\n  sOSDelim = '/';\r\nElse;\r\n  sOS = 'Windows';\r\n  sOSDelim = '\\';\r\nEndIf;\r\n\r\n## LogOutput parameters\r\nIF( pLogoutput = 1 );\r\n    LogOutput('INFO', Expand( cLogInfo ) );\r\nENDIF;\r\n\r\nnErrors = 0;\r\n\r\n### PROCESS PROPERTIES\r\nDatasourceASCIIDelimiter = '';\r\nDatasourceASCIIQuoteCharacter = '';\r\n\r\n##Validate Mode\r\nIf(upper(pMode) @<> 'LOAD' & upper(pMode) @<> 'UNLOAD');\r\n    sMessage = Expand('Invalid Mode: %pMode%. Valid Modes are Load or Unload');\r\n    nErrors = nErrors + 1;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndif;\r\n\r\n##Validate Cube\r\nIf( Trim(pCube) @= '' );\r\n    sMessage = Expand('No cube specified');\r\n    nErrors = nErrors + 1;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndif;\r\n\r\n## Default filter delimiters\r\nIf( pDelim     @= '' );\r\n    pDelim     = '&';\r\nEndIf;\r\n\r\n# define backupdir\r\nIf(pPath @<> '');\r\n    If(Subst(pPath,long(pPath),1) @= sOSDelim );\r\n        sPath = pPath;\r\n    Else;\r\n        sPath = pPath | sOSDelim;\r\n    Endif;\r\nElse;\r\n  sPath = '.' | sOSDelim;\r\nEndif;\r\n\r\n## Default files names for storing rule and backups\r\nIF(pFileName@='');\r\n  sRuleFileName         = '%sCube%.txt';\r\n  sBackupFileName       = '%sCube%.rux.bkp_%cTimeStamp%.txt';\r\nElse;\r\n  sRuleFileName         = pFileName;\r\n  sBackupFileName       = '%pFileName%.bkp_%cTimeStamp%.txt';\r\nEndif;\r\n\r\n# Loop through list of Cubes\r\nsCubes = pCube;\r\nnCubeDelimIndex = 1;\r\n\r\nWhile( nCubeDelimIndex <> 0 );\r\n  nCubeDelimIndex = Scan( pDelim, sCubes );\r\n  If( nCubeDelimIndex = 0 );\r\n    sCube = sCubes;\r\n  Else;\r\n    If (sOS @= 'Windows');\r\n      sCube = Trim( SubSt( sCubes, 1, nCubeDelimIndex - 1 ) );\r\n    Else;\r\n      sCube = LOWER(Trim( SubSt( sCubes, 1, nCubeDelimIndex - 1 ) ));\r\n    EndIf;\r\n    sCubes = Trim( Subst( sCubes, nCubeDelimIndex + Long(pDelim), Long( sCubes ) ) );\r\n  EndIf;\r\n\r\n  sMDX = Expand( '{TM1FILTERBYPATTERN(TM1SUBSETALL([}Cubes]), \"%sCube%\")}' );\r\n\r\n  sProc = '}bedrock.hier.sub.create.bymdx';\r\n  ExecuteProcess( sProc,\r\n    'pLogOutput', pLogOutput,\r\n    'pStrictErrorHandling', pStrictErrorHandling,\r\n    'pDim', cDimCubes,\r\n    'pHier', '',\r\n    'pSub', cTempSub,\r\n    'pMDXExpr', sMDX,\r\n    'pConvertToStatic', 1,\r\n    'pTemp', 1\r\n  );\r\n\r\n  nCube = 1;\r\n  nCubes = SubsetGetSize( cDimCubes, cTempSub );\r\n  While( nCube <= nCubes );\r\n    sCube = SubsetGetElementName( cDimCubes, cTempSub, nCube );\r\n    nCube = nCube + 1;\r\n\r\n    If( sOS @= 'Windows');\r\n      cCubeRuleFileName = '.' | sOSDelim | sCube | '.rux';\r\n    Else;\r\n      cCubeRuleFileName = '.' | sOSDelim | LOWER(sCube) | '.rux';\r\n    EndIf;\r\n    If( sOS @= 'Windows');\r\n      cStoreDirFile = sPath | Expand(sRuleFileName);\r\n      cBackupDirFile = sPath | Expand(sBackupFileName);\r\n    Else;\r\n      cStoreDirFile = sPath | LOWER(Expand(sRuleFileName));\r\n      cBackupDirFile = sPath | LOWER(Expand(sBackupFileName));\r\n    EndIf;\r\n    # if there already is a rule file\r\n    If(FileExists(cCubeRuleFileName) <> 0);\r\n      ##Loading the Rule###\r\n      If(Upper(pMode) @= 'LOAD');\r\n        ##Backup the existing rule (saved as .bkp.txt in given path or data directory)\r\n        ##and load the new rule file. New Rule file should available in the given path or in data directory\r\n        If( sOS @= 'Windows');\r\n          sCmd = 'cmd /c \"copy \"\"\"' | cCubeRuleFileName | '\"\"\"  \"\"\"' | cBackupDirFile |'\"\"\" \"';\r\n        Else;\r\n          sCmd = 'cp \"' | cCubeRuleFileName | '\" \"' | cBackupDirFile | '\"';\r\n        EndIf;\r\n        ExecuteCommand(sCmd,1);\r\n        ## Check if the backup file exists\r\n        If( FileExists( cBackupDirFile ) <> 0 );\r\n          RuleLoadFromFile( sCube, cStoreDirFile);\r\n        Else;\r\n          sMessage = Expand('Backup of rule file (%cCubeRuleFileName%) has failed, rule was not loaded.');\r\n          nErrors = nErrors + 1;\r\n          LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n          If( pStrictErrorHandling = 1 );\r\n              ProcessQuit;\r\n          Else;\r\n              ProcessBreak;\r\n          EndIf;\r\n        EndIf;\r\n      Else;\r\n        ##Unloading the Rule###\r\n        ##Before unloading, backup the existing rule (saved as .bkp.txt in data directory or with the suffix parameter)\r\n        ##and drop current rule\r\n        If( sOS @= 'Windows');\r\n          sCmd = 'cmd /c \"copy \"\"\"' | cCubeRuleFileName | '\"\"\"  \"\"\"' | cBackupDirFile |'\"\"\" \"';\r\n        Else;\r\n          sCmd = 'cp \"' | cCubeRuleFileName | '\" \"' | cBackupDirFile |'\"';\r\n        EndIf;\r\n        ExecuteCommand(sCmd,1);\r\n        ## Check if the backup file exists\r\n        If( FileExists( cBackupDirFile ) = 0 );\r\n          sMessage = Expand('Backup of rule file (%cCubeRuleFileName%) has failed, rule was not unloaded.');\r\n          nErrors = nErrors + 1;\r\n          LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n          If( pStrictErrorHandling = 1 );\r\n              ProcessQuit;\r\n          Else;\r\n              ProcessBreak;\r\n          EndIf;\r\n        EndIf;\r\n        If( sOS @= 'Windows');\r\n          sCmd = 'cmd /c \"copy \"\"\"' | cCubeRuleFileName | '\"\"\"  \"\"\"' | cStoreDirFile |'\"\"\" \"';\r\n        Else;\r\n          sCmd = 'cp \"' | cCubeRuleFileName | '\"  \"' | cStoreDirFile |'\"';\r\n        EndIf;\r\n        ExecuteCommand(sCmd,1);\r\n        ## Check if the saved rule file exists\r\n        If( FileExists( cStoreDirFile ) <> 0 );\r\n          CubeRuleDestroy( sCube );\r\n        Else;\r\n          sMessage = Expand('Copy of rule file (%cCubeRuleFileName%) has failed, rule was not unloaded.');\r\n          nErrors = nErrors + 1;\r\n          LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n          If( pStrictErrorHandling = 1 );\r\n              ProcessQuit;\r\n          Else;\r\n              ProcessBreak;\r\n          EndIf;\r\n        EndIf;\r\n      Endif;\r\n\r\n    Else;\r\n      ###To create a new rule file for the cube (no existing rule)\r\n      If(Upper(pMode) @= 'LOAD');\r\n        RuleLoadFromFile( sCube, cStoreDirFile );\r\n      Else;\r\n        nErrors = nErrors + 1;\r\n        sMessage = 'No Rule file found for cube: ' | sCube;\r\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n      Endif;\r\n    Endif;\r\n  End;\r\nEnd;",
    "Variables": []
}