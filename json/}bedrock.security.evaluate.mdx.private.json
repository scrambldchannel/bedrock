{
    "DataProcedure": "#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n# MDX statement flag ends on 278\r\n\r\nIf ( Subst ( vLine, 1, 3 ) @= '278' );\r\n    # parse this MDX for keywords\r\n    sKeyWordString = '';\r\n    nKeywordFlag = 0;\r\n    sKeywordList = cKeywordList;\r\n    nKeywordLength = Long ( sKeywordList );\r\n    While ( nKeywordLength > 0 );\r\n        nDelimiter = Scan ( cKeywordDelimiter, sKeyWordList );\r\n        If ( nDelimiter = 0 );\r\n            sKeyword = sKeyWordList;\r\n            sKeyWordList = '';\r\n        Else;\r\n            nEnd = nDelimiter - 1;\r\n            sKeyWord = SubSt ( sKeywordList, 1, nEnd );\r\n            sKeyWordList = Subst ( sKeywordList, nEnd + 2, nKeywordLength - nEnd);\r\n        EndIf;\r\n\r\n        If ( Scan( sKeyWord, sMDX ) > 0 );\r\n            nKeyWordFlag = nKeyWordFlag + 1;\r\n            IF( Long( sKeyWordString ) = 0 );\r\n              sKeyWordString = sKeyWordString | sKeyWord;\r\n            ELSE;\r\n              sKeyWordString = sKeyWordString | pDelim | ' ' | sKeyWord;\r\n            ENDIF;\r\n            IF( pLogoutput = 1 );\r\n                sMessage = 'Keyword ' | sKeyWord | ' found in ' |sMDX;\r\n                LogOutput('INFO', Expand( cMsgInfoContent ) );\r\n            ENDIF;\r\n        EndIf;\r\n        nKeywordLength = Long ( sKeywordList );\r\n    End;\r\n    IF( sKeyWordString @<> '' );\r\n        sRow = '%pQuote%%pDimension%%pQuote%%pFieldDelim%%pQuote%Y%pQuote%%pFieldDelim%%pQuote%%pSubset%%pQuote%%pFieldDelim%%pQuote%%pUser%%pQuote%';\r\n        sRow = sRow|'%pFieldDelim%%pQuote%%sMDX%%pQuote%';\r\n        sRow = sRow|'%pFieldDelim%%pQuote%%sKeyWordString%%pQuote%';\r\n    ENDIF;\r\n    # end parsing for keywords\r\n    # if keywords found then see if we can match an element in the MDX with one in the dimension\r\n    # element will be included within [] but there will be [dimension][hierarchy][subset][attribute] so could be a false positive\r\n    sElementString = '';\r\n    sUsersString = '';\r\n    If ( nKeyWordFlag > 0 );\r\n        sMDXTemp = sMDX;\r\n        sStarter = '[';\r\n        sEnder = ']';\r\n        nMDXLength = Long ( sMDXTemp );\r\n        While ( nMDXLength > 0 );\r\n            nStarter = SCAN ( sStarter, sMDXTemp );\r\n            If ( nStarter > 0 );\r\n                nEnder = SCAN ( sEnder, sMDXTemp );\r\n                sElement = SubSt ( sMDXTemp, nStarter + 1, nEnder - nStarter -1);\r\n                nToGo = nMDXLength - nEnder + 1;\r\n                sMDXTemp = Subst ( sMDXTemp, nEnder + 1, nToGo );\r\n                # check if that is actually an element\r\n                If ( DimIx ( pDimension, sElement ) > 0 );\r\n                    IF( Scan( sElement, sElementString ) = 0 );\r\n                        IF( sElementString @= '' );\r\n                            sElementString = sElementString | sElement;\r\n                        ELSE;\r\n                            sElementString = sElementString | pDelim | ' ' | sElement;\r\n                        ENDIF;\r\n                    ENDIF;\r\n                    IF( pLogoutput = 1 );\r\n                        sMessage = sElement | ' is referenced in the MDX and exists in the dimension';\r\n                        LogOutput('INFO', Expand( cMsgInfoContent ) );\r\n                    ENDIF;\r\n                    # now need to loop through relevant groups to see access\r\n                    # loop through all groups to check access to this element\r\n                    nUserCheck = 0;\r\n                    iGroup = 1;\r\n                    While ( iGroup <= nGroupMax );\r\n                        sGroup = DimNm ( cGroupDim, iGroup );\r\n                        #skip the admin groups!\r\n                        If ( sGroup @<> 'ADMIN' & sGroup @<> 'SecurityAdmin' & sGroup @<> 'DataAdmin' & sGroup @<> 'OperationsAdmin' );\r\n                            nCheck = 1;\r\n                            # if we have a user check membership and we don;t need to continue if not in that group\r\n                            If ( CellGetS ( cSecCube, pUser, sGroup ) @= '' );\r\n                                nCheck = 0;\r\n                            EndIf;\r\n                            If ( nCheck = 1 );\r\n                                # get the groups security assignment\r\n                                sAccess = CellGetS ( cEleSecCube, sElement, sGroup );\r\n                                # if the user has rights to that element then all is good and we can quit the loops\r\n                                If ( sAccess @<> '' & sAccess @<> 'NONE' );\r\n                                    nUserCheck = 1;\r\n                                    iGroup = nGroupMax + 1;\r\n                                EndIf;\r\n                            EndIf;\r\n                        Else;\r\n                            # if the user is in an admin group them they will have access\r\n                            If ( CellGetS ( cSecCube, pUser, sGroup ) @<> '' );\r\n                                nUserCheck = 1;\r\n                            EndIf;\r\n                        EndIf;\r\n                        iGroup = iGroup + 1;\r\n                    End;\r\n                    If ( nUserCheck = 0 );\r\n                        sAlias = AttrS ( cUserDim, pUser, cUserAlias );\r\n                        If ( sAlias @= '' );\r\n                            sAlias = pUser;\r\n                        EndIf;\r\n                        IF( Scan( sAlias, sUsersString ) = 0 );\r\n                            IF( sUsersString @= '' );\r\n                              sUsersString = sUsersString | sAlias;\r\n                            ELSE;\r\n                              sUsersString = sUsersString | pDelim | ' ' | sAlias;\r\n                            ENDIF;\r\n                        ENDIF;\r\n                        IF( pLogoutput = 1 );\r\n                            sMessage = Expand('Private subset %pSubset% contains a keyword and a specific element %sElement% that the user %sAlias% do not have access to');\r\n                            LogOutput('INFO', Expand( cMsgInfoContent ) );\r\n                        ENDIF;\r\n                    EndIf;\r\n                EndIf;\r\n                nMDXLength = Long ( sMDXTemp );\r\n            Else;\r\n                nMDXLength = 0;\r\n            EndIf;\r\n        End;\r\n    sRow = sRow|'%pFieldDelim%%pQuote%%sElementString%%pQuote%%pFieldDelim%%pQuote%%sUsersString%%pQuote%';\r\n    EndIf;\r\n    nMDXFlag = 0;\r\n    IF( sTotalOutputRowString @= '' );\r\n        sTotalOutputRowString = Expand(sRow);\r\n    ELSE;\r\n        sTotalOutputRowString = sTotalOutputRowString | sCRLF | Expand(sRow);\r\n    ENDIF;\r\nEndIf;\r\n\r\n\r\nIf ( nMDXFlag = 1 );\r\n    sMDX = UPPER ( sMDX | vLine );\r\nEndIf;\r\n\r\n# MDX statement flag starts on 275\r\n\r\nIf ( Subst ( vLine, 1, 3 ) @= '275' );\r\n    nMDXFlag = 1;\r\nEndIf;",
    "DataSource": {
        "Type": "ASCII",
        "asciiDecimalSeparator": ".",
        "asciiDelimiterChar": "@",
        "asciiDelimiterType": "Character",
        "asciiHeaderRecords": 1,
        "asciiQuoteCharacter": "\"",
        "asciiThousandSeparator": ",",
        "dataSourceNameForClient": "Admin\\store}subs\\Euros.sub",
        "dataSourceNameForServer": "Admin\\store}subs\\Euros.sub"
    },
    "EpilogProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n#################################################################################################\r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock Ver 4.0~~##\r\n#################################################################################################\r\n\r\n### Write Output data\r\nIf( nErrors = 0 );\r\n  IF( pWriteOutput <> 0 );\r\n      DatasourceAsciiQuoteCharacter = '';\r\n      TextOutput( cExportFile, Expand(sTotalOutputRowString) );\r\n  ELSE;\r\n      IF( sGlobPrivateSubsetsTotalString @= '' );\r\n          sGlobPrivateSubsetsTotalString = sTotalOutputRowString;\r\n      ELSE;\r\n          IF( sTotalOutputRowString @<> '' );\r\n              sGlobPrivateSubsetsTotalString = sGlobPrivateSubsetsTotalString | sCRLF | sTotalOutputRowString;\r\n          ENDIF;\r\n      ENDIF;\r\n  ENDIF;\r\nENDIF;\r\n\r\n### Return code & final error message handling\r\nIf( nErrors > 0 );\r\n    sMessage = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\r\n    nProcessReturnCode = 0;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\r\n    If( pStrictErrorHandling = 1 );\r\n        ProcessQuit;\r\n    EndIf;\r\nElse;\r\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully executed.' );\r\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\r\n    nProcessReturnCode = 1;\r\n    If( pLogoutput = 1 );\r\n        LogOutput('INFO', Expand( sProcessAction ) );\r\n    EndIf;\r\nEndIf;\r\n\r\n### End Epilog ###",
    "HasSecurityAccess": false,
    "MetadataProcedure": "#****Begin: Generated Statements***\r\n#****End: Generated Statements****",
    "Name": "}bedrock.security.evaluate.mdx.private",
    "Parameters": [
        {
            "Name": "pLogOutput",
            "Prompt": "OPTIONAL: Write parameters and action summary to server message log (Boolean True = 1)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pStrictErrorHandling",
            "Prompt": "OPTIONAL: On encountering any error exit with major error status by ProcessQuit after writing to the server message log (Boolean True = 1)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pUser",
            "Prompt": "REQUIRED: User name",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pDimension",
            "Prompt": "REQUIRED: Dimension name",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pSubset",
            "Prompt": "REQUIRED: Subset name",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pSubsetFile",
            "Prompt": "REQUIRED: Path to subset file",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pFilePath",
            "Prompt": "OPTIONAL: Export Directory (will default to error file path)",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pFileName",
            "Prompt": "OPTIONAL: Export Filename (If Left Blank Defaults to processname_user_dimension_subset_export.csv)",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pDelim",
            "Prompt": "OPTIONAL: AsciiOutput delimiter character (Default=comma exactly 3 digits = ASCII code)",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pQuote",
            "Prompt": "OPTIONAL: AsciiOutput quote character (Accepts empty quote exactly 3 digits = ASCII code)",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pWriteOutput",
            "Prompt": "DO NOT USE: for internal use only",
            "Type": "Numeric",
            "Value": "1"
        }
    ],
    "PrologProcedure": "#Region CallThisProcess\r\n# A snippet of code provided as an example how to call this process should the developer be working on a system without access to an editor with auto-complete.\r\nIf( 1 = 0 );\r\n    ExecuteProcess('}bedrock.security.evaluate.mdx.private',\r\n       'pLogOutput', pLogOutput,\r\n       'pStrictErrorHandling', pStrictErrorHandling,\r\n       'pUser', pUser,\r\n       'pDimension', pDimension,\r\n       'pSubset', pSubset,\r\n       'pSubsetFile', pSubsetFile,\r\n       'pFilePath', pFilePath,\r\n       'pFileName', pFileName,\r\n       'pDelim', pDelim,\r\n       'pQuote', pQuote\r\n      );\r\nEndIf;\r\n#EndRegion CallThisProcess\r\n\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n#################################################################################################\r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock Ver 4.0~~##\r\n#################################################################################################\r\n\r\n#Region @DOC\r\n# Description:\r\n# This process will find out PRIVATE dynamic subsets of dimensions having security on them - element security - and evaluate expressions impacted by the latest MDX security changes\r\n\r\n# Use case: Intended for development or production.\r\n\r\n# Note:\r\n#\r\n#EndRegion @DOC\r\n\r\n##Global Variables\r\nStringGlobalVariable('sProcessReturnCode');\r\nNumericGlobalVariable('nProcessReturnCode');\r\nStringGlobalVariable('sGlobPrivateSubsetsTotalString');\r\nnProcessReturnCode= 0;\r\n\r\n### Constants ###\r\ncThisProcName       = GetProcessName();\r\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\r\ncRandomInt          = NumberToString( INT( RAND( ) * 1000 ));\r\ncUserName           = TM1User();\r\ncMsgErrorLevel      = 'ERROR';\r\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\r\ncLogInfo            = 'Process:%cThisProcName% run with parameters pUser:%pUser%, pDimension:%pDimension%, pSubset:%pSubset%, pSubsetFile:%pSubsetFile%, pFilePath:%pFilePath%, pFileName:%pFileName%, pDelim:%pDelim%, pQuote:%pQuote%.' ;\r\ncMsgInfoContent    = 'User:%cUserName% Process:%cThisProcName% InfoMsg:%sMessage%';\r\ncSecurityPrefix = '}ElementSecurity_';\r\ncDimDim = '}Dimensions';\r\ncUserDim = '}Clients';\r\ncUserAttrDim= '}ElementAttributes_}Clients';\r\ncUserAlias = '}TM1_DefaultDisplayValue';\r\ncSubsetPrefix = '}Subsets_';\r\ncGroupDim = '}Groups';\r\ncSecCube = '}ClientGroups';\r\nnGroupMax = DimSiz ( cGroupDim );\r\nnUserMax = DimSiz ( cUserDim );\r\ncEleSecCube = cSecurityPrefix | pDimension;\r\n\r\npFieldDelim       = TRIM(pDelim);\r\nsCRLF             = Char( 13 ) | Char( 10 );\r\ncLenASCIICode     = 3;\r\nnDataCount        = 0;\r\nnErrors           = 0;\r\n\r\n#reset flag and string\r\nnMDXFlag = 0;\r\nsMDX = '';\r\nsTotalRowString = '';\r\n\r\n#keywords to look out for in an MDX expression\r\ncKeyWordList = 'DRILLDOWN&.Children&FirstChild&Ancestors&Ascendants&Cousin&DrillUp&FirstSibling&IsAncestor&FirstSibling&LastChild&LastSibling&Descendants';\r\ncKeyWordList = UPPER ( cKeyWordList );\r\ncKeyWordDelimiter = '&';\r\n\r\n## LogOutput parameters\r\nIF( pLogoutput = 1 );\r\n    LogOutput('INFO', Expand( cLogInfo ) );\r\nENDIF;\r\n\r\n### Validate Parameters ###\r\n\r\n# Validate user\r\nIF( DimIx( cUserDim,  pUser) = 0 );\r\n    sMessage = Expand('Invalid user: %pUser%');\r\n    nErrors = nErrors + 1;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nENDIF;\r\n\r\n# Validate dimension\r\nIF( DimIx( cDimDim,  pDimension) = 0 );\r\n    sMessage = Expand('Invalid dimension: %pDimension%');\r\n    nErrors = nErrors + 1;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nENDIF;\r\n\r\n# Validate subset name\r\nIF( pSubset @= '' % Scan( pSubset, pSubsetFile ) = 0  );\r\n    sMessage = Expand('Invalid subset name: %pSubset%');\r\n    nErrors = nErrors + 1;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nENDIF;\r\n\r\n## check operating system\r\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\r\n  sOS = 'Windows';\r\n  sOSDelim = '\\';\r\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0 );\r\n  sOS = 'Linux';\r\n  sOSDelim = '/';\r\nElse;\r\n  sOS = 'Windows';\r\n  sOSDelim = '\\';\r\nEndIf;\r\n\r\n# Validate file path\r\nIf(Trim( pFilePath ) @= '' );\r\n    pFilePath = GetProcessErrorFileDirectory;\r\nEndIf;\r\nIf( SubSt( pFilePath, Long( pFilePath ), 1 ) @= sOSDelim );\r\n    pFilePath = SubSt( pFilePath, 1, Long( pFilePath ) -1 );\r\nEndIf;\r\nIf(  FileExists( pFilePath ) = 0 );\r\n    sMessage = Expand('Invalid export directory: %pFilePath%');\r\n    nErrors = nErrors + 1;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\npFilePath = pFilePath | sOSDelim;\r\n\r\n# Validate file name\r\nIf( pFileName @= '' );\r\n    sBaseFileName = Expand('%cThisProcName%_%pUser%_%pDimension%_%pSubset%_Export');\r\n    sExt = '.csv';\r\n    pFileName = sBaseFileName | '.csv';\r\nElse;\r\n    # determine file extension. If no file extension entered then use .csv as default\r\n    If( Scan( '.', pFileName ) = 0 );\r\n        sExt = '.csv';\r\n        sBaseFileName = pFileName;\r\n    Else;\r\n        sExt = SubSt( pFileName, Scan( '.', pFileName ), Long( pFileName ) );\r\n        sBaseFileName = SubSt( pFileName, 1, Scan( '.', pFileName ) - 1 );\r\n    EndIf;\r\n    pFileName = sBaseFileName | sExt;\r\nEndIf;\r\ncExportFile = pFilePath | pFileName;\r\n\r\n# Validate file delimiter & quote character\r\nIf( pFieldDelim @= '' );\r\n    pFieldDelim = ',';\r\nElse;\r\n    # If length of pFieldDelim is exactly 3 chars and each of them is decimal digit, then the pFieldDelim is entered as ASCII code\r\n    nValid = 0;\r\n    If ( LONG(pFieldDelim) = cLenASCIICode );\r\n      nChar = 1;\r\n      While ( nChar <= cLenASCIICode );\r\n        If( CODE( pFieldDelim, nChar ) >= CODE( '0', 1 ) & CODE( pFieldDelim, nChar ) <= CODE( '9', 1 ) );\r\n          nValid = 1;\r\n        Else;\r\n          nValid = 0;\r\n        EndIf;\r\n        nChar = nChar + 1;\r\n      End;\r\n    EndIf;\r\n    If ( nValid<>0 );\r\n      pFieldDelim=CHAR(StringToNumber( pFieldDelim ));\r\n    Else;\r\n      pFieldDelim = SubSt( Trim( pFieldDelim ), 1, 1 );\r\n    EndIf;\r\nEndIf;\r\nIf( pQuote @= '' );\r\n    ## Use no quote character\r\nElse;\r\n    # If length of pQuote is exactly 3 chars and each of them is decimal digit, then the pQuote is entered as ASCII code\r\n    nValid = 0;\r\n    If ( LONG(pQuote) = cLenASCIICode );\r\n      nChar = 1;\r\n      While ( nChar <= cLenASCIICode );\r\n        If( CODE( pQuote, nChar ) >= CODE( '0', 1 ) & CODE( pQuote, nChar ) <= CODE( '9', 1 ) );\r\n          nValid = 1;\r\n        Else;\r\n          nValid = 0;\r\n        EndIf;\r\n        nChar = nChar + 1;\r\n      End;\r\n    EndIf;\r\n    If ( nValid<>0 );\r\n      pQuote=CHAR(StringToNumber( pQuote ));\r\n    Else;\r\n      pQuote = SubSt( Trim( pQuote ), 1, 1 );\r\n    EndIf;\r\nEndIf;\r\n\r\n# Validate subset file\r\n\r\nIf ( FileExists( pSubsetFile ) = 0 );\r\n    sMessage = Expand('Invalid subset file: %pSubsetFile%');\r\n    nErrors = nErrors + 1;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\n### Check for errors before continuing\r\nIf( nErrors <> 0 );\r\n  If( pStrictErrorHandling = 1 );\r\n      ProcessQuit;\r\n  Else;\r\n      ProcessBreak;\r\n  EndIf;\r\nEndIf;\r\n\r\n### Initialize output\r\n\r\nsTotalOutputRowString = '';\r\nIF( pWriteOutput <> 0 );\r\n  sTitleRow = '%pQuote%DIMENSION%pQuote%%pFieldDelim%%pQuote%HAS SECURITY%pQuote%%pFieldDelim%%pQuote%SUBSET NAME%pQuote%';\r\n  sTitleRow = sTitleRow|'%pFieldDelim%%pQuote%IS PRIVATE%pQuote%%pFieldDelim%%pQuote%MDX EXPRESSION%pQuote%';\r\n  sTitleRow = sTitleRow|'%pFieldDelim%%pQuote%KEYWORDS%pQuote%%pFieldDelim%%pQuote%ELEMENTS%pQuote%%pFieldDelim%%pQuote%USERS WITH NO ACCESS%pQuote%';\r\n  sTotalOutputRowString = Expand(sTitleRow);\r\nENDIF;\r\nsRow = '';\r\n\r\n### Assign data source\r\nIf( nErrors = 0 );\r\n    DataSourceType ='CHARACTERDELIMITED';\r\n    DatasourceNameForServer = pSubsetFile;\r\n    DatasourceASCIIDelimiter='@@';\r\nEndIF;\r\n",
    "Variables": [
        {
            "EndByte": 0,
            "Name": "vLine",
            "Position": 1,
            "StartByte": 0,
            "Type": "String"
        }
    ]
}