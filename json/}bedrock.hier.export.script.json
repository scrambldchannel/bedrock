{
    "DataProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n#################################################################################################\r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock Ver 4.0~~##\r\n#################################################################################################\r\n\r\n# Set the output character set\r\nSetOutputCharacterSet( sFileName, pCharacterSet );\r\n\r\n### Record Count\r\nnRecordCount = nRecordCount + 1;\r\n\r\n### Set dimension & hierarchy variables\r\nIf( Scan( ':', vDim ) = 0 );\r\n    sDim    = vDim;\r\n    sHier   = vDim;\r\nElse;\r\n    sDim    = SubSt( vDim, 1, Scan( ':', vDim ) - 1 );\r\n    sHier   = SubSt( vDim, Scan( ':', vDim ) + 1, Long( vDim ) - ( Long( sDim ) + 1 ) );\r\nEndIf;\r\nsDimAttr    = '}ElementAttributes_' | sDim;\r\nsDimSub     = '}Subsets_' | sDim;\r\n\r\n### Export Header Information\r\nIf( nRecordCount = 1 & pTitleRecord = 1 );\r\n    sHeader = Expand('# Export dimensions as script pDim=%pDim% pEle=%pEle% On %cTimeStampPrint%');\r\n    TextOutput( sFileName, sHeader );\r\n    If( ( pAttrVal = 1 & DimensionExists( sDimAttr ) = 1 & pEle @<> '' ) % ( pSub = 1 & DimensionExists( sDimSub ) = 1 ) );\r\n        sHeader = Expand('# Export dimensions as script pDim=%pDim% pEle=%pEle% On %cTimeStampPrint%');\r\n        TextOutput( sFileName2, sHeader );\r\n    EndIf;\r\nEndIf;\r\n\r\n### Dimension write open\r\nTextOutput( sFileName, '' );\r\nTextOutput( sFileName, cHashLine );\r\nTextOutput( sFileName, Expand('#Region Dimension/Hierarchy: %vDim%') );\r\nIf( ( pAttrVal = 1 & DimensionExists( sDimAttr ) = 1 & pEle @<> '' ) % ( pSub = 1 & DimensionExists( sDimSub ) = 1 ) );\r\n    TextOutput( sFileName2, '' );\r\n    TextOutput( sFileName2, cHashLine );\r\n    TextOutput( sFileName2, Expand('#Region Dimension/Hierarchy: %vDim% (EPILOG)') );\r\nEndIf;\r\n\r\n#################################################################################################\r\n#Region Create Dimension (PROLOG)\r\nTextOutput( sFileName, '' );\r\nTextOutput( sFileName, Expand('sDimHier = ''%vDim%'';') );\r\nTextOutput( sFileName, Expand('sDim     = ''%sDim%'';') );\r\nTextOutput( sFileName, Expand('sHier    = ''%sHier%'';') );\r\nTextOutput( sFileName, Expand('sDimAttr = ''%sDimAttr%'';') );\r\nTextOutput( sFileName, 'If( DimensionExists( sDim ) = 0 );');\r\nTextOutput( sFileName, '    DimensionCreate( sDim );');\r\nTextOutput( sFileName, '    If( sDim @<> sHier );');\r\nTextOutput( sFileName, '        HierarchyCreate( sDim, sHier );');\r\nTextOutput( sFileName, '    EndIf;' );\r\nTextOutput( sFileName, 'ElseIf( sDim @<> sHier );');\r\nTextOutput( sFileName, '    If( HierarchyExists( sDim, sHier ) = 0 );');\r\nTextOutput( sFileName, '        HierarchyCreate( sDim, sHier );');\r\nTextOutput( sFileName, '    EndIf;' );\r\nTextOutput( sFileName, 'EndIf;' );\r\n#EndRegion Create Dimension\r\n#################################################################################################\r\n\r\n#################################################################################################\r\n#Region Dimension Info (PROLOG)\r\nIf( pDimInfo = 1 );\r\n    TextOutput( sFileName, '' );\r\n    TextOutput( sFileName, cHashLine );\r\n    TextOutput( sFileName, Expand('#Region Dimension Info: %vDim%') );\r\n    sSORTELEMENTSTYPE   = CellGetS( '}DimensionProperties', vDim, 'SORTELEMENTSTYPE' );\r\n    sSORTCOMPONENTSTYPE = CellGetS( '}DimensionProperties', vDim, 'SORTCOMPONENTSTYPE' );\r\n    sSORTELEMENTSSENSE  = CellGetS( '}DimensionProperties', vDim, 'SORTELEMENTSSENSE' );\r\n    sSORTCOMPONENTSSENSE= CellGetS( '}DimensionProperties', vDim, 'SORTCOMPONENTSSENSE' );\r\n    sDefHier            = CellGetS( '}DimensionProperties', vDim, 'DEFAULT_HIERARCHY' );\r\n    sDefMember          = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'defaultMember' );\r\n    sHierLevels         = NumberToString( CellGetN( '}HierarchyProperties', vDim, 'hierarchy0', 'LevelsToHierarchize' ) );\r\n    sLevel000           = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level000' );\r\n    sLevel001           = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level001' );\r\n    sLevel002           = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level002' );\r\n    sLevel003           = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level003' );\r\n    sLevel004           = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level004' );\r\n    sLevel005           = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level005' );\r\n    sLevel006           = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level006' );\r\n    sLevel007           = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level007' );\r\n    sLevel008           = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level008' );\r\n    sLevel009           = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level009' );\r\n    sLevel010           = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level010' );\r\n    sLevel011           = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level011' );\r\n    sLevel012           = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level012' );\r\n    sLevel013           = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level013' );\r\n    sLevel014           = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level014' );\r\n    sLevel015           = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level015' );\r\n    sLevel016           = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level016' );\r\n    sLevel017           = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level017' );\r\n    sLevel018           = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level018' );\r\n    sLevel019           = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level019' );\r\n    sLevel020           = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level020' );\r\n    TextOutput( sFileName, Expand('DimensionSortOrder( sDimHier, ''%sSORTCOMPONENTSTYPE%'', ''%sSORTCOMPONENTSSENSE%'', ''%sSORTELEMENTSTYPE%'', ''%sSORTELEMENTSSENSE%'' );') );\r\n    TextOutput( sFileName, Expand('CellPutS( ''%sDefHier%'', ''}DimensionProperties'', sDimHier, ''DEFAULT_HIERARCHY'' );') );\r\n    TextOutput( sFileName, Expand('CellPutS( ''%sDefMember%'', ''}HierarchyProperties'', sDimHier, ''hierarchy0'', ''defaultMember'' );') );\r\n    TextOutput( sFileName, Expand('CellPutN( %sHierLevels%, ''}HierarchyProperties'', sDimHier, ''hierarchy0'', ''LevelsToHierarchize'' );') );\r\n    nCtr                = 0;\r\n    While( nCtr         <= 20 );\r\n        sLvl            = 'Level0' | If( nCtr < 10, '0', '' ) | NumberToString( nCtr );\r\n        sLvlVal         = Expand('%'| Expand('s%sLvl%') |'%');\r\n        If( sLvlVal     @<> '' );\r\n            TextOutput( sFileName, Expand('CellPutS( ''%sLvlVal%'', ''}HierarchyProperties'', sDimHier, ''hierarchy0'', ''%sLvl%'' );') );\r\n        EndIf;\r\n        nCtr            = nCtr + 1;\r\n    End;\r\n    If( CubeExists( '}DimensionAttributes' ) = 1 );\r\n        nCtr            = 1;\r\n        While( nCtr     <= DimSiz( '}DimensionAttributes' ) );\r\n            sAttr       = DimNm( '}DimensionAttributes', nCtr );\r\n            sAttrTyp    = SubSt( DType( '}DimensionAttributes', sAttr ), 2, 1 );\r\n            sAttrVal    = If( sAttrTyp @= 'N', NumberToString( DimensionAttrN( vDim, sAttr ) ), DimensionAttrS( vDim, sAttr ) );\r\n            TextOutput( sFileName, Expand('DimensionAttrInsert( '''', ''%sAttr%'', ''%sAttrTyp%'' );') );\r\n            If( sAttrTyp @= 'N' );\r\n                TextOutput( sFileName, Expand('DimensionAttrPutN( %sAttrVal%, sDimHier, ''%sAttr%'' );') );\r\n            Else;\r\n                TextOutput( sFileName, Expand('DimensionAttrPutS( ''%sAttrVal%'', sDimHier, ''%sAttr%'' );') );\r\n            EndIf;\r\n            nCtr        = nCtr + 1;\r\n        End;\r\n    EndIf;\r\n    TextOutput( sFileName, Expand('#EndRegion Dimension Info: %vDim%') );\r\n    TextOutput( sFileName, cHashLine );\r\nEndIf;\r\n#EndRegion Dimension Info\r\n#################################################################################################\r\n\r\n#################################################################################################\r\n#Region Create Attributes (PROLOG)\r\nIf( pAttr = 1 & DimensionExists( sDimAttr ) = 1 & Scan( sDim|pDelim, sAttrDone ) = 0 );\r\n    sAttrDone       = sAttrDone | sDim | pDelim;\r\n    TextOutput( sFileName, '' );\r\n    TextOutput( sFileName, cHashLine );\r\n    TextOutput( sFileName, Expand('#Region Create Attributes: %sDim%') );\r\n    nCtr            = 1;\r\n    While( nCtr     <= DimSiz( sDimAttr ) );\r\n        sAttr       = DimNm( sDimAttr, nCtr );\r\n        sAttrTyp    = SubSt( DType( sDimAttr, sAttr ), 2, 1 );\r\n        # Escape potential single apostrophes to avoid parsing errors in attribute names\r\n        nChar = 1;\r\n        nCount = 0;\r\n        sAttrStrOut = '';\r\n        While( nChar <= LONG( sAttr ) + 1 );\r\n            If( nChar <= LONG( sAttr ) );\r\n                sChar = SUBST( sAttr, nChar, 1 );\r\n            Else;\r\n                sChar = '';\r\n            EndIf;\r\n            If( sChar @= '''' );\r\n                nCount = nCount + 1;\r\n            ElseIf( nCount > 0 );\r\n                If( MOD( nCount, 2 ) <> 0 );\r\n                    sAttrStrOut = sAttrStrOut | '''';\r\n                EndIf;\r\n                nCount = 0;\r\n            EndIf;\r\n            sAttrStrOut = sAttrStrOut | sChar;\r\n            nChar = nChar + 1;\r\n        End;\r\n        If( nCtr = 1 );\r\n            TextOutput( sFileName, 'If( DimensionExists( sDimAttr ) = 0 % CubeExists( sDimAttr ) = 0 );');\r\n            TextOutput( sFileName, Expand('    AttrInsert( sDim, '''', ''%sAttrStrOut%'', ''%sAttrTyp%'' );') );\r\n            TextOutput( sFileName, 'EndIf;' );\r\n        EndIf;\r\n        TextOutput( sFileName, Expand('If( DimIx( sDimAttr, ''%sAttrStrOut%'' ) = 0 );') );\r\n        TextOutput( sFileName, Expand('    AttrInsert( sDim, '''', ''%sAttrStrOut%'', ''%sAttrTyp%'' );') );\r\n        TextOutput( sFileName, 'Else;' );\r\n        TextOutput( sFileName, Expand('    If( DType( sDimAttr, ''%sAttrStrOut%'' ) @<> ''A%sAttrTyp%'' );') );\r\n        TextOutput( sFileName, Expand('        AttrDelete( sDim, ''%sAttrStrOut%'' );') );\r\n        TextOutput( sFileName, Expand('        AttrInsert( sDim, '''', ''%sAttrStrOut%'', ''%sAttrTyp%'' );') );\r\n        TextOutput( sFileName, '    EndIf;' );\r\n        TextOutput( sFileName, 'EndIf;' );\r\n        nCtr        = nCtr + 1;\r\n    End;\r\n    TextOutput( sFileName, Expand('#EndRegion Create Attributes: %sDim%') );\r\n    TextOutput( sFileName, cHashLine );\r\nEndIf;\r\n#EndRegion Create Attributes\r\n#################################################################################################\r\n\r\n#################################################################################################\r\n#Region Create Dimension/Hierarchy Structure (PROLOG)\r\nIf( pEle @<> '' );\r\n    sMDX = '';\r\n    If( pEle @= '*' );\r\n        sMDX = Expand('{TM1SubsetAll([%sDim%].[%sHier%])}');\r\n    Else;\r\n        # Loop through elements (inc. wildcard expressions) in pEle\r\n        sEles = pEle;\r\n        nEleDelimiterIndex = 1;\r\n        # Get 1st ele\r\n        While( nEleDelimiterIndex <> 0 );\r\n            # Extract 1st ele in sEles\r\n            nEleDelimiterIndex = Scan( pDelim, sEles );\r\n            If( nEleDelimiterIndex = 0 );\r\n                sEle = sEles;\r\n            Else;\r\n                sEle = Trim( SubSt( sEles, 1, nEleDelimiterIndex - 1 ) );\r\n                sEles = Trim( Subst( sEles, nEleDelimiterIndex + Long( pDelim ), Long( sEles ) ) );\r\n            EndIf;\r\n            If( Scan( '*', sEle ) > 0 % Scan( '?', sEle ) > 0 );\r\n                # Create MDX for subset of eles using Wildcard Pattern filter (means pEle entry MUST use principal name)\r\n                sEleExp = '\"'|sEle|'\"';\r\n                sMdxPart = Expand('{TM1FILTERBYPATTERN( TM1SUBSETALL( [%sDim%].[%sHier%] ), %sEleExp% )}');\r\n            Else;\r\n                # Create MDX of single element and all descendants\r\n                sMDXPart = Expand('{TM1DRILLDOWNMEMBER( {[%sDim%].[%sHier%].[%sEle%]}, ALL, RECURSIVE )}');\r\n            EndIf;\r\n            If( sMDX @= '');\r\n                sMDX = sMdxPart;\r\n            Else;\r\n                sMDX = sMDX | ' + ' | sMdxPart;\r\n            EndIf;\r\n        End;\r\n    EndIf;\r\n    If( SubsetExists( vDim, cTempSub ) = 1 );\r\n        SubsetMDXSet( vDim, cTempSub, sMDX );\r\n    Else;\r\n        SubsetCreatebyMDX( cTempSub, sMDX, vDim, 1 );\r\n    EndIf;\r\n    nMax = SubsetGetSize( vDim, cTempSub );\r\n    If( nMax >= 1 );\r\n        TextOutput( sFileName, '' );\r\n        TextOutput( sFileName, cHashLine );\r\n        TextOutput( sFileName, Expand('#Region Create Elements: %vDim%') );\r\n        nCtr = 1;\r\n        While( nCtr <= nMax );\r\n            # 1st insert all elements to get correct order\r\n            sEle = SubsetGetElementName( vDim, cTempSub, nCtr );\r\n            # Escape potential single apostrophes to avoid parsing errors in element names\r\n            nChar = 1;\r\n            nCount = 0;\r\n            sEleStrOut = '';\r\n            While( nChar <= LONG( sEle ) + 1 );\r\n                If( nChar <= LONG( sEle ) );\r\n                    sChar = SUBST( sEle, nChar, 1 );\r\n                Else;\r\n                    sChar = '';\r\n                EndIf;\r\n                If( sChar @= '''' );\r\n                    nCount = nCount + 1;\r\n                ElseIf( nCount > 0 );\r\n                    If( MOD( nCount, 2 ) <> 0 );\r\n                        sEleStrOut = sEleStrOut | '''';\r\n                    EndIf;\r\n                    nCount = 0;\r\n                EndIf;\r\n                sEleStrOut = sEleStrOut | sChar;\r\n                nChar = nChar + 1;\r\n            End;\r\n            sEleTyp = DType( vDim, sEle );\r\n            TextOutput( sFileName, Expand('DimensionElementInsert( sDimHier, '''', ''%sEleStrOut%'', ''%sEleTyp%'' );') );\r\n            nCtr    = nCtr + 1;\r\n        End;\r\n        nCtr = 1;\r\n        While( nCtr <= nMax );\r\n            # 2nd loop again and create parent linkages\r\n            sEle    = SubsetGetElementName( vDim, cTempSub, nCtr );\r\n            # Escape potential single apostrophes to avoid parsing errors in element names\r\n            nChar = 1;\r\n            nCount = 0;\r\n            sEleStrOut = '';\r\n            While( nChar <= LONG( sEle ) + 1 );\r\n                If( nChar <= LONG( sEle ) );\r\n                    sChar = SUBST( sEle, nChar, 1 );\r\n                Else;\r\n                    sChar = '';\r\n                EndIf;\r\n                If( sChar @= '''' );\r\n                    nCount = nCount + 1;\r\n                ElseIf( nCount > 0 );\r\n                    If( MOD( nCount, 2 ) <> 0 );\r\n                        sEleStrOut = sEleStrOut | '''';\r\n                    EndIf;\r\n                    nCount = 0;\r\n                EndIf;\r\n                sEleStrOut = sEleStrOut | sChar;\r\n                nChar = nChar + 1;\r\n            End;\r\n            nPar    = 1;\r\n            While( nPar <= ElParN( vDim, sEle ) );\r\n                sPar = ElPar( vDim, sEle, nPar );\r\n                # Escape potential single apostrophes to avoid parsing errors in parent element names\r\n                nChar = 1;\r\n                nCount = 0;\r\n                sParStrOut = '';\r\n                While( nChar <= LONG( sPar ) + 1 );\r\n                    If( nChar <= LONG( sPar ) );\r\n                        sChar = SUBST( sPar, nChar, 1 );\r\n                    Else;\r\n                        sChar = '';\r\n                    EndIf;\r\n                    If( sChar @= '''' );\r\n                        nCount = nCount + 1;\r\n                    ElseIf( nCount > 0 );\r\n                        If( MOD( nCount, 2 ) <> 0 );\r\n                            sParStrOut = sParStrOut | '''';\r\n                        EndIf;\r\n                        nCount = 0;\r\n                    EndIf;\r\n                    sParStrOut = sParStrOut | sChar;\r\n                    nChar = nChar + 1;\r\n                End;\r\n                sWht = NumberToString( ElWeight( vDim, sPar, sEle ) );\r\n                If( pEle @<> '*' );\r\n                    TextOutput( sFileName, Expand('DimensionElementInsert( sDimHier, '''', ''%sParStrOut%'', ''C'' );') );\r\n                EndIf;\r\n                TextOutput( sFileName, Expand('DimensionElementComponentAdd( sDimHier, ''%sParStrOut%'', ''%sEleStrOut%'', %sWht% );') );\r\n                nPar = nPar + 1;\r\n            End;\r\n            nCtr     = nCtr + 1;\r\n        End;\r\n        TextOutput( sFileName, Expand('#EndRegion Create Elements: %vDim%') );\r\n        TextOutput( sFileName, cHashLine );\r\n    EndIf;\r\nEndIf;\r\n#EndRegion Create Structure\r\n#################################################################################################\r\n\r\n#################################################################################################\r\n#Region Attribute Values (EPILOG)\r\nIf( pAttrVal = 1 & DimensionExists( sDimAttr ) = 1 & nMax >=1 );\r\n    TextOutput( sFileName2, '' );\r\n    TextOutput( sFileName2, cHashLine );\r\n    TextOutput( sFileName2, Expand('#Region Attribute Values: %vDim%') );\r\n    TextOutput( sFileName2, Expand('sDimHier = ''%vDim%'';') );\r\n    TextOutput( sFileName2, Expand('sDim     = ''%sDim%'';') );\r\n    TextOutput( sFileName2, Expand('sHier    = ''%sHier%'';') );\r\n    TextOutput( sFileName2, Expand('sDimAttr = ''%sDimAttr%'';') );\r\n    nCtr = 1;\r\n    While( nCtr <= nMax );\r\n        # loop elements again and internally loop attributes\r\n        sEle = SubsetGetElementName( vDim, cTempSub, nCtr );\r\n        # Escape potential single apostrophes to avoid parsing errors in element names\r\n        nChar = 1;\r\n        nCount = 0;\r\n        sEleStrOut = '';\r\n        While( nChar <= LONG( sEle ) + 1 );\r\n            If( nChar <= LONG( sEle ) );\r\n                sChar = SUBST( sEle, nChar, 1 );\r\n            Else;\r\n                sChar = '';\r\n            EndIf;\r\n            If( sChar @= '''' );\r\n                nCount = nCount + 1;\r\n            ElseIf( nCount > 0 );\r\n                If( MOD( nCount, 2 ) <> 0 );\r\n                    sEleStrOut = sEleStrOut | '''';\r\n                EndIf;\r\n                nCount = 0;\r\n            EndIf;\r\n            sEleStrOut = sEleStrOut | sChar;\r\n            nChar = nChar + 1;\r\n        End;\r\n        sEleTyp = DType( vDim, sEle );\r\n        nAttr   = 1;\r\n        While( nAttr <= DimSiz( sDimAttr ) );\r\n            sAttr       = DimNm( sDimAttr, nAttr );\r\n            # Escape potential single apostrophes to avoid parsing errors in attribute names\r\n            nChar = 1;\r\n            nCount = 0;\r\n            sAttrStrOut = '';\r\n            While( nChar <= LONG( sAttr ) + 1 );\r\n                If( nChar <= LONG( sAttr ) );\r\n                    sChar = SUBST( sAttr, nChar, 1 );\r\n                Else;\r\n                    sChar = '';\r\n                EndIf;\r\n                If( sChar @= '''' );\r\n                    nCount = nCount + 1;\r\n                ElseIf( nCount > 0 );\r\n                    If( MOD( nCount, 2 ) <> 0 );\r\n                        sAttrStrOut = sAttrStrOut | '''';\r\n                    EndIf;\r\n                    nCount = 0;\r\n                EndIf;\r\n                sAttrStrOut = sAttrStrOut | sChar;\r\n                nChar = nChar + 1;\r\n            End;\r\n            sAttrTyp    = SubSt( DType( sDimAttr, sAttr ), 2, 1 );\r\n            sAttrVal    = '';\r\n            If( ( sDim @<> sHier & sEleTyp @<> 'N' ) & sAttrTyp @= 'N' );\r\n                sAttrVal= NumberToString( ElementAttrN( sDim, sHier, sEle, sAttr ) );\r\n            ElseIf( sDim @<> sHier & sEleTyp @<> 'N' );\r\n                sAttrVal= ElementAttrS( sDim, sHier, sEle, sAttr );\r\n            ElseIf( sEleTyp @= 'N' & sAttrTyp @= 'N' & DimIx( sDim, sEle ) = 0 );\r\n                sAttrVal= NumberToString( ElementAttrN( sDim, sHier, sEle, sAttr ) );\r\n            ElseIf( sEleTyp @= 'N' & DimIx( sDim, sEle ) = 0 );\r\n                sAttrVal= ElementAttrS( sDim, sHier, sEle, sAttr );\r\n            ElseIf( sAttrTyp @= 'N' );\r\n                sAttrVal= NumberToString( AttrN( sDim, sEle, sAttr ) );\r\n            Else;\r\n                sAttrVal= AttrS( sDim, sEle, sAttr );\r\n            EndIf;\r\n            sAttrValStrOut = '';\r\n            If( sAttrVal @<> '' );\r\n                If( sAttrTyp @<> 'N' );\r\n                    # Escape potential single apostrophes to avoid parsing errors in attribute values\r\n                    nChar = 1;\r\n                    nCount = 0;\r\n                    While( nChar <= LONG( sAttrVal ) + 1 );\r\n                        If( nChar <= LONG( sAttrVal ) );\r\n                            sChar = SUBST( sAttrVal, nChar, 1 );\r\n                        Else;\r\n                            sChar = '';\r\n                        EndIf;\r\n                        If( sChar @= '''' );\r\n                            nCount = nCount + 1;\r\n                        ElseIf( nCount > 0 );\r\n                            If( MOD( nCount, 2 ) <> 0 );\r\n                                sAttrValStrOut = sAttrValStrOut | '''';\r\n                            EndIf;\r\n                            nCount = 0;\r\n                        EndIf;\r\n                        sAttrValStrOut = sAttrValStrOut | sChar;\r\n                        nChar = nChar + 1;\r\n                    End;\r\n                Else;\r\n                    # we won't need any tratment for non-string attributes\r\n                    sAttrValStrOut = sAttrVal;\r\n                EndIf;\r\n                If( ( sDim @<> sHier & sEleTyp @<> 'N' ) & sAttrTyp @= 'N' );\r\n                    TextOutput( sFileName2, Expand('ElementAttrPutN( %sAttrValStrOut%, sDim, sHier, ''%sEleStrOut%'', ''%sAttrStrOut%'' );') );\r\n                ElseIf( sDim @<> sHier & sEleTyp @<> 'N' );\r\n                    TextOutput( sFileName2, Expand('ElementAttrPutS( ''%sAttrValStrOut%'', sDim, sHier, ''%sEleStrOut%'', ''%sAttrStrOut%'' );') );\r\n                ElseIf( sEleTyp @= 'N' & sAttrTyp @= 'N' & DimIx( sDim, sEle ) = 0 );\r\n                    TextOutput( sFileName2, Expand('ElementAttrPutN( %sAttrValStrOut%, sDim, sHier, ''%sEleStrOut%'', ''%sAttrStrOut%'' );') );\r\n                ElseIf( sEleTyp @= 'N' & DimIx( sDim, sEle ) = 0 );\r\n                    TextOutput( sFileName2, Expand('ElementAttrPutS( ''%sAttrValStrOut%'', sDim, sHier, ''%sEleStrOut%'', ''%sAttrStrOut%'' );') );\r\n                ElseIf( sAttrTyp @= 'N' );\r\n                    TextOutput( sFileName2, Expand('AttrPutN( %sAttrValStrOut%, sDim, ''%sEleStrOut%'', ''%sAttrStrOut%'' );') );\r\n                Else;\r\n                    TextOutput( sFileName2, Expand('AttrPutS( ''%sAttrValStrOut%'', sDim, ''%sEleStrOut%'', ''%sAttrStrOut%'' );') );\r\n                EndIf;\r\n            EndIf;\r\n            nAttr = nAttr + 1;\r\n        End;\r\n        nCtr    = nCtr + 1;\r\n    End;\r\n    TextOutput( sFileName2, Expand('#EndRegion Attribute Values: %vDim%') );\r\n    TextOutput( sFileName2, cHashLine );\r\nEndIf;\r\n#EndRegion Attribute Values\r\n#################################################################################################\r\n\r\n#################################################################################################\r\n#Region Subsets (EPILOG)\r\nIf( pSub = 1 & DimensionExists( sDimSub ) = 1 );\r\n    If( sDim @= vDim );\r\n        sMDX = Expand('{Except( {TM1SubsetAll( [%sDimSub%] )}, {TM1FilterByPattern( {TM1SubsetAll( [%sDimSub%] )}, \"*:*\" )} )}');\r\n    Else;\r\n        sMDX = Expand('{TM1FilterByPattern( {TM1SubsetAll( [%sDimSub%] )}, \"%sHier%:*\" )}');\r\n    EndIf;\r\n    If( SubsetExists( sDimSub, cTempSub ) = 1 );\r\n        SubsetMDXSet( sDimSub, cTempSub, sMDX );\r\n    Else;\r\n        SubsetCreatebyMDX( cTempSub, sMDX, sDimSub, 1 );\r\n    EndIf;\r\n    nMax = SubsetGetSize( sDimSub, cTempSub );\r\n    If( nMax >= 1 );\r\n        TextOutput( sFileName2, '' );\r\n        TextOutput( sFileName2, cHashLine );\r\n        TextOutput( sFileName2, Expand('#Region Subsets: %vDim%') );\r\n        If( pAttrVal <> 1 % DimensionExists( sDimAttr ) = 0 % pEle @= '' );\r\n            TextOutput( sFileName2, Expand('sDimHier = ''%vDim%'';') );\r\n            TextOutput( sFileName2, Expand('sDim     = ''%sDim%'';') );\r\n            TextOutput( sFileName2, Expand('sHier    = ''%sHier%'';') );\r\n            TextOutput( sFileName2, Expand('sDimAttr = ''%sDimAttr%'';') );\r\n        EndIf;\r\n        nCtr = 1;\r\n        While( nCtr <= nMax );\r\n            sSub        = SubsetGetElementName( sDimSub, cTempSub, nCtr );\r\n            If( Scan( ':', sSub ) > 0 );\r\n                sSub    = SubSt( sSub, Scan( ':', sSub ) + 1, Long( sSub ) );\r\n            EndIf;\r\n            sMDX        = SubsetMDXGet( vDim, sSub );\r\n            # If MDX expression contains TM1SubsetBasis function then treat it as a static subset\r\n            If( sMDX @<> '' & Scan( 'TM1SUBSETBASIS()', Upper( sMDX ) ) = 0 );\r\n                # create by MDX\r\n                TextOutput( sFileName2, Expand('If( SubsetExists( sDimHier, ''%sSub%'' ) = 0 );') );\r\n                TextOutput( sFileName2, Expand('    SubsetCreatebyMDX( ''%sSub%'', ''%sMDX%'', sDimHier, 0 );') );\r\n                TextOutput( sFileName2, 'Else;' );\r\n                TextOutput( sFileName2, Expand('    SubsetMDXSet( sDimHier, ''%sSub%'', ''%sMDX%'' );') );\r\n                TextOutput( sFileName2, 'EndIf;' );\r\n            Else;\r\n                # loop members\r\n                TextOutput( sFileName2, Expand('If( SubsetExists( sDimHier, ''%sSub%'' ) = 0 );') );\r\n                TextOutput( sFileName2, Expand('    SubsetCreate( sDimHier, ''%sSub%'' );') );\r\n                TextOutput( sFileName2, 'Else;' );\r\n                TextOutput( sFileName2, Expand('    SubsetDeleteAllElements( sDimHier, ''%sSub%'' );') );\r\n                TextOutput( sFileName2, 'EndIf;' );\r\n                nEles   = SubsetGetSize( vDim, sSub );\r\n                nEle    = 1;\r\n                While( nEle <= nEles );\r\n                    sEle = SubsetGetElementName( vDim, sSub, nEle );\r\n                    # Escape potential single apostrophes to avoid parsing errors in element names\r\n                    nChar = 1;\r\n                    nCount = 0;\r\n                    sEleStrOut = '';\r\n                    While( nChar <= LONG( sEle ) + 1 );\r\n                        If( nChar <= LONG( sEle ) );\r\n                            sChar = SUBST( sEle, nChar, 1 );\r\n                        Else;\r\n                            sChar = '';\r\n                        EndIf;\r\n                        If( sChar @= '''' );\r\n                            nCount = nCount + 1;\r\n                        ElseIf( nCount > 0 );\r\n                            If( MOD( nCount, 2 ) <> 0 );\r\n                                sEleStrOut = sEleStrOut | '''';\r\n                            EndIf;\r\n                            nCount = 0;\r\n                        EndIf;\r\n                        sEleStrOut = sEleStrOut | sChar;\r\n                        nChar = nChar + 1;\r\n                    End;\r\n                    TextOutput( sFileName2, Expand('SubsetElementInsert( sDimHier, ''%sSub%'', ''%sEleStrOut%'', 0 );') );\r\n                    nEle = nEle + 1;\r\n                End;\r\n            EndIf;\r\n            nCtr        = nCtr + 1;\r\n        End;\r\n        TextOutput( sFileName2, Expand('#EndRegion Subsets: %vDim%') );\r\n        TextOutput( sFileName2, cHashLine );\r\n    EndIf;\r\nEndIf;\r\n#EndRegion Subsets\r\n#################################################################################################\r\n\r\n### Dimension write close\r\nTextOutput( sFileName, '' );\r\nTextOutput( sFileName, Expand('#EndRegion Dimension/Hierarchy: %vDim%') );\r\nTextOutput( sFileName, cHashLine );\r\nIf( ( pAttrVal = 1 & DimensionExists( sDimAttr ) = 1 & pEle @<> '' ) % ( pSub = 1 & DimensionExists( sDimSub ) = 1 ) );\r\n    TextOutput( sFileName2, '' );\r\n    TextOutput( sFileName2, Expand('#EndRegion Dimension/Hierarchy: %vDim%') );\r\n    TextOutput( sFileName2, cHashLine );\r\nEndIf;",
    "DataSource": {
        "Type": "?",
        "asciiDecimalSeparator": ".",
        "asciiDelimiterChar": ",",
        "asciiHeaderRecords": 0,
        "asciiQuoteCharacter": "\"",
        "asciiThousandSeparator": ",",
        "dataSourceNameForClient": "}Cubes",
        "dataSourceNameForServer": "}Cubes"
    },
    "EpilogProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n#################################################################################################\r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock Ver 4.0~~##\r\n#################################################################################################\r\n\r\n\r\n### If errors occurred terminate process with a major error status ###\r\nIf( nErrors > 0 );\r\n    sMessage = 'the process incurred at least 1 major error and consequently aborted. Please see above lines in this file for more details.';\r\n    nProcessReturnCode = 0;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% aborted. Check tm1server.log for details.' );\r\n    If( pStrictErrorHandling = 1 );\r\n        ProcessQuit;\r\n    EndIf;\r\nEndIf;\r\n\r\n### Return Code\r\nsProcessAction      = Expand( 'Process:%cThisProcName% successfully exported %pDim% dimension:hierarchy to %sFileName%.' );\r\nsProcessReturnCode  = Expand( '%sProcessReturnCode% %sProcessAction%' );\r\nnProcessReturnCode  = 1;\r\nIf ( pLogoutput = 1 );\r\n    LogOutput('INFO', Expand( sProcessAction ) );\r\nEndIf;\r\n\r\n### End Epilog ###",
    "HasSecurityAccess": true,
    "MetadataProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n",
    "Name": "}bedrock.hier.export.script",
    "Parameters": [
        {
            "Name": "pLogOutput",
            "Prompt": "OPTIONAL: Write parameters and action summary to server message log (Boolean True = 1)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pStrictErrorHandling",
            "Prompt": "OPTIONAL: On encountering any error exit with major error status by ProcessQuit after writing to the server message log (Boolean True = 1)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pDim",
            "Prompt": "REQUIRED: Target Dimension or Hierarchy (as dim:hier) accepts wildcards (if = * then all the dimensions)",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pEle",
            "Prompt": "OPTIONAL: Target Element(s) accepts wildcards ( * will include ALL)",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pDelim",
            "Prompt": "OPTIONAL: Delimiter character if list used for pDim pHier or pEle",
            "Type": "String",
            "Value": "&"
        },
        {
            "Name": "pTgtDir",
            "Prompt": "OPTIONAL: Target Directory Path (defaults to Error File Directory if blank)",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pTgtFile",
            "Prompt": "OPTIONAL: Root file name without file extension. If blank \"\"bedrock_dimension_script\"\" will be used",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pTitleRecord",
            "Prompt": "REQUIRED: Boolean 1 = Yes - Include header row",
            "Type": "Numeric",
            "Value": "1"
        },
        {
            "Name": "pDimInfo",
            "Prompt": "OPTIONAL: Include dimension info section (SortOrder HierarchyProperties etc.)",
            "Type": "Numeric",
            "Value": "1"
        },
        {
            "Name": "pAttr",
            "Prompt": "OPTIONAL: Include creation of attributes",
            "Type": "Numeric",
            "Value": "1"
        },
        {
            "Name": "pSub",
            "Prompt": "OPTIONAL: Include subset definitions",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pAttrVal",
            "Prompt": "OPTIONAL: Include attribute values (for selected elements in pEle)",
            "Type": "Numeric",
            "Value": "1"
        },
        {
            "Name": "pCharacterSet",
            "Prompt": "OPTIONAL: The output character set (defaults to TM1CS_UTF8 if blank)",
            "Type": "String",
            "Value": ""
        }
    ],
    "PrologProcedure": "#Region CallThisProcess\r\n# A snippet of code provided as an example how to call this process should the developer be working on a system without access to an editor with auto-complete.\r\nIf( 1 = 0 );\r\n    ExecuteProcess( '}bedrock.hier.export.script', 'pLogOutput', pLogOutput,\r\n         'pStrictErrorHandling', pStrictErrorHandling,\r\n         'pDim', '', 'pEle', '', 'pDelim', '&',\r\n         'pTgtDir', '', 'pTitleRecord', 1,\r\n         'pDimInfo', 1, 'pAttr', 1, 'pAttrVal', 1, 'pSub', 0\r\n    );\r\nEndIf;\r\n#EndRegion CallThisProcess\r\n\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n#################################################################################################\r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock Ver 4.0~~##\r\n#################################################################################################\r\n\r\n#Region @DOC\r\n# Description:\r\n# This process exports a dimension hierarchies as _TurboIntegrator script_. This is rather than creating a CSV which can be read by a generic\r\n# TurboIntegrator process this process creates a _**hardcoded**_ TurboIntegrator process to create a dimension/hierarchy complete with rollup\r\n# structure, attribute values, subsets and metadata information such as sort order, MDX hierarchy names and levels and captions.\r\n#\r\n# Use case:\r\n# The specific use case where this process will be useful is to automate the creation of TurboIntegrator script for promotion/migration purposes\r\n# as 100% stand-alone without need for data source o any parameters for the process. This can be useful in situations where DevOps has no file system access\r\n# to an environment and for manually defined dimensions such as measures.\r\n#\r\n# Note:\r\n# Several parameters control the scope of what is exported.\r\n# * pDim accepts wildcard and lists of dimensions and/or hierarchies to filter the **}Dimensions** dimension. There is no separate **pHier** parameter for this process\r\n# * pEle accepts wildcard and lists of _elements_. This can be used to limit the scope of the export of dimension structure and attribute values to a subset of elements\r\n# * pDimInfo 1/0 numeric Boolean whether to include metadata relevant to the dimensions/hierarchies defined in pDim from }DimensionProperties, }HierarchyProperties and }DimensionAttributes\r\n# * pAttr 1/0 numeric Boolean whether to include attribute creation\r\n# * pAttrVal 1/0 numeric Boolean whether to include attribute values (for the elements defined in pEle )\r\n# * pSub 1/0 numeric Boolean whether to include subset definitions for dynamic and static subsets\r\n# * There is no Boolean for exporting dimension structure, this is determined by pEle. To export all elements use pEle=\"*\". To suppress export of rollup structure (and attribute values) use pEle=\"\"\r\n# * 2 scripts are produced. One to copy/paste into prolog and one for epilog as Direct functions are not used for creation of elements and parent-child relationships\r\n#\r\n# Caution:\r\n# This process is designed for _**smaller (typically manually defined) dimensions**_. No check is implemented for upper limit of the set of elements defined by pEle if run on a large\r\n# dimension then the export script will be correspondingly large.\r\n#EndRegion @DOC\r\n\r\n### Global Variables\r\nStringGlobalVariable('sProcessReturnCode');\r\nNumericGlobalVariable('nProcessReturnCode');\r\nnProcessReturnCode= 0;\r\n\r\n### Constants ###\r\ncThisProcName   = GetProcessName();\r\ncUserName       = TM1User();\r\ncTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\r\ncTimeStampPrint = TimSt( Now, '\\Y-\\m-\\d \\h:\\i:\\s' );\r\ncRandomInt      = NumberToString( INT( RAND( ) * 1000 ));\r\ncTempSub        = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\r\ncMsgErrorLevel  = 'ERROR';\r\ncMsgErrorContent= 'Process:%cThisProcName% ErrorMsg:%sMessage%';\r\ncLogInfo        = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pEle:%pEle%, pDelim:%pDelim%, pTgtDir:%pTgtDir%, pTgtFile:%pTgtFile%, pTitleRecord:%pTitleRecord%, pDimInfo:%pDimInfo%, pAttr:%pAttr%, pAttrVal:%pAttrVal%, pSub:%pSub%';\r\ncCubeS1         = '}DimensionProperties';\r\npDelim          = Trim( pDelim );\r\ncLenASCIICode   = 3;\r\ncHashLine       = '#################################################################################################';\r\nsAttrDone       = '';\r\n\r\n## LogOutput parameters\r\nIF( pLogoutput = 1 );\r\n    LogOutput('INFO', Expand( cLogInfo ) );\r\nENDIF;\r\n\r\n### Initialise ###\r\nnRecordCount = 0;\r\n\r\n### Validate Parameters ###\r\nnErrors = 0;\r\n\r\n## Validate Source dimension\r\nIF( Trim( pDim ) @= '' );\r\n    nErrors = 1;\r\n    sMessage = 'No dimension specified.';\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nElseIF( Scan( '*', pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0 & DimensionExists( pDim ) = 0 );\r\n    nErrors = 1;\r\n    sMessage = 'Invalid dimension: ' | pDim;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\n# Validate element\r\nIf( pEle @<> '');\r\n    If( Scan( '*', pEle ) = 0 & Scan( '?', pEle ) = 0 & Scan( pDelim, pEle ) = 0 & DimIx( pDim, pEle ) = 0 );\r\n        nErrors = 1;\r\n        sMessage = 'Item ' | pEle | ' does NOT exist. Please enter a valid element in the ' |pDim| ' dimension.';\r\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n    Endif;\r\nEndif;\r\n\r\n## check operating system\r\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\r\n  sOS = 'Windows';\r\n  sOSDelim = '\\';\r\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0 );\r\n  sOS = 'Linux';\r\n  sOSDelim = '/';\r\nElse;\r\n  sOS = 'Windows';\r\n  sOSDelim = '\\';\r\nEndIf;\r\n\r\n# Validate export path\r\nIf( Trim( pTgtDir ) @= '' );\r\n    pTgtDir     = GetProcessErrorFileDirectory;\r\n    sMessage    = 'Target folder defaulted to error file directory.';\r\n    LogOutput( 'INFO', Expand( cMsgErrorContent ) );\r\nEndIf;\r\nIf( SubSt( pTgtDir, Long( pTgtDir ), 1 ) @= sOSDelim );\r\n    pTgtDir     = SubSt( pTgtDir, 1, Long( pTgtDir ) -1 );\r\nEndIf;\r\nIf( FileExists( pTgtDir ) = 0 );\r\n    nErrors     = 1;\r\n    sMessage    = 'Invalid export path specified. Folder does not exist.';\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\npTgtDir         = pTgtDir | sOSDelim;\r\n\r\n# Validate export filename\r\nIf( pTgtFile    @= '' );\r\n    pTgtFile1   = 'bedrock_dimension_script_prolog.txt';\r\n    pTgtFile2   = 'bedrock_dimension_script_epilog.txt';\r\nElse;\r\n    If( SubSt( pTgtFile, Long( pTgtFile ) - 4, 1 ) @= '.' );\r\n        pTgtFile = SubSt( pTgtFile, 1, Long( pTgtFile ) - 5 );\r\n    EndIf;\r\n    If( SubSt( pTgtFile, Long( pTgtFile ), 1 ) @= '_' );\r\n        pTgtFile = SubSt( pTgtFile, 1, Long( pTgtFile ) - 1 );\r\n    EndIf;\r\n    pTgtFile1   = pTgtFile | '_prolog.txt';\r\n    pTgtFile2   = pTgtFile | '_epilog.txt';\r\n\r\nEndIf;\r\n\r\n# Validate file delimiter & quote character\r\nIf( pDelim @= '' );\r\n    pDelim      = '&';\r\nElse;\r\n    # If length of pDelim is exactly 3 chars and each of them is decimal digit, then the pDelim is entered as ASCII code\r\n    nValid      = 0;\r\n    If ( LONG(pDelim) = cLenASCIICode );\r\n      nChar     = 1;\r\n      While ( nChar <= cLenASCIICode );\r\n        If( CODE( pDelim, nChar )>=CODE( '0', 1 ) & CODE( pDelim, nChar )<=CODE( '9', 1 ) );\r\n          nValid = 1;\r\n        Else;\r\n          nValid = 0;\r\n        EndIf;\r\n        nChar   = nChar + 1;\r\n      End;\r\n    EndIf;\r\n    If ( nValid<>0 );\r\n      pDelim    = Char( StringToNumber( pDelim ) );\r\n    Else;\r\n      pDelim    = SubSt( Trim( pDelim ), 1, 1 );\r\n    EndIf;\r\nEndIf;\r\n\r\n# Validate Character Set\r\nIf(Trim( pCharacterSet ) @= '' );\r\n  pCharacterSet = 'TM1CS_UTF8';\r\nEndIf;\r\n\r\n# Use no quote character\r\npQuote          = '';\r\n\r\n# Construct full export filename including path\r\nsFileName       = pTgtDir | pTgtFile1;\r\nsFileName2      = pTgtDir | pTgtFile2;\r\n\r\n# If blank delimiter specified then convert to default\r\nIf( pDelim @= '' );\r\n    pDelim = '&';\r\nEndIf;\r\n\r\n### Check for errors before continuing\r\nIf( nErrors <> 0 );\r\n  If( pStrictErrorHandling = 1 );\r\n      ProcessQuit;\r\n  Else;\r\n      ProcessBreak;\r\n  EndIf;\r\nEndIf;\r\n\r\n# Loop through dimensions in pDim\r\nsDims = pDim;\r\nnDimDelimiterIndex = 1;\r\nsMdx = '';\r\n# Get 1st dimension\r\nWhile( nDimDelimiterIndex <> 0 );\r\n    # Extract 1st dimension > sDim\r\n    nDimDelimiterIndex = Scan( pDelim, sDims );\r\n    If( nDimDelimiterIndex = 0 );\r\n        sDim = sDims;\r\n    Else;\r\n        sDim = Trim( SubSt( sDims, 1, nDimDelimiterIndex - 1 ) );\r\n        sDims = Trim( Subst( sDims, nDimDelimiterIndex + Long(pDelim), Long( sDims ) ) );\r\n    EndIf;\r\n\r\n    # Create subset of dimensions using Wildcard to loop through dimensions in pDim with wildcard\r\n    sDimExp = '\"'|sDim|'\"';\r\n    sMdxPart = Expand('{TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions].[}Dimensions] ), %sDimExp% )}');\r\n    If( sMdx @= '');\r\n        sMdx = sMdxPart;\r\n    Else;\r\n        sMdx = sMdx | ' + ' | sMdxPart;\r\n    EndIf;\r\nEnd;\r\n\r\nIf( SubsetExists( '}Dimensions' , cTempSub ) = 1 );\r\n    # If a delimited list of dim names includes wildcards then we may have to re-use the subset multiple times\r\n    SubsetMDXSet( '}Dimensions' , cTempSub, sMDX );\r\nElse;\r\n    # temp subset, therefore no need to destroy in epilog\r\n    SubsetCreatebyMDX( cTempSub, sMDX, '}Dimensions' , 1 );\r\nEndIf;\r\n\r\n# Assign Data Source\r\nDataSourceType                  = 'SUBSET';\r\nDatasourceNameForServer         = '}Dimensions';\r\nDatasourceDimensionSubset       = cTempSub;\r\nDatasourceASCIIQuoteCharacter   = pQuote;\r\n\r\n### End Prolog ###",
    "UIData": "CubeAction=1511\fDataAction=1503\fCubeLogChanges=0\f",
    "Variables": [
        {
            "EndByte": 0,
            "Name": "vDim",
            "Position": 1,
            "StartByte": 0,
            "Type": "String"
        }
    ],
    "VariablesUIData": []
}