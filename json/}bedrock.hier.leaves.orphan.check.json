{
    "DataProcedure": "#****Begin: Generated Statements***\r\n#****End: Generated Statements****",
    "DataSource": {
        "Type": "?",
        "asciiDecimalSeparator": ".",
        "asciiDelimiterChar": ",",
        "asciiHeaderRecords": 0,
        "asciiQuoteCharacter": "\"",
        "asciiThousandSeparator": ",",
        "dataSourceNameForClient": "}Dimensions",
        "dataSourceNameForServer": "}Dimensions"
    },
    "EpilogProcedure": "#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n#################################################################################################\r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock Ver 4.0~~##\r\n#################################################################################################\r\n\r\n### If errors occurred terminate process with a major error status ###\r\nIf( nErrors <> 0 );\r\n    sMessage = 'the process incurred at least 1 major error and consequently aborted. Please see above lines in this file for more details.';\r\n    nProcessReturnCode = 0;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% aborted. Check tm1server.log for details.' );\r\n    If( pStrictErrorHandling = 1 );\r\n        ProcessQuit;\r\n    EndIf;\r\nEndIf;\r\n\r\n### Return Code\r\nIf ( nDims <> 0 );\r\n  sDims = NumberToString( nDims );\r\n  ### Regular function - Leaves orphans\r\n  If ( nDimsWithOrphans = 0 & nElemsMissing <> 0 );\r\n    nDimsWithOrphans = 1;\r\n    If ( pLogOutput <> 0 );\r\n      sElemsMissing = NumberToString( nElemsMissing );\r\n      LogOutput( cMsgInfoLevel, Expand( 'Dimension [%sDimPrev%] is missing [%sElemsMissing%] elements from [%cHierLeaves%] hierarchy in all of matching hierarchies [%pHier%]. List of elements is available in subset [%pTgtSub%] of [%cHierLeaves%] hierarchy.' ) );\r\n    EndIf;\r\n  EndIf;\r\n  sDimsWithOrphans = NumberToString( nDimsWithOrphans );\r\n  If ( nDimsWithOrphans <> 0 );\r\n    sProcessAction = Expand( 'There are orphan elements in [%sDimsWithOrphans%] dimensions out of [%sDims%] matching.' );\r\n  Else;\r\n    sProcessAction = Expand( 'Scanned [%sDims%] dimensions, all are OK and contain no Leaves orphans.' );\r\n  EndIf;\r\n  ### Optional function - elements missing parents\r\n  If ( nDimsWithoutParents = 0 & nElemsMissingParent <> 0 );\r\n    nDimsWithoutParents = 1;\r\n    If ( pLogOutput <> 0 );\r\n      sElemsMissingParents = NumberToString( nElemsMissingParent );\r\n      LogOutput( cMsgInfoLevel, Expand( 'Dimension [%sDimPrev%] contains [%sElemsMissingParents%] elements that are missing parent in matching hierarchies [%pHier%].' ) );\r\n    EndIf;\r\n  EndIf;\r\n  sDimsWithoutParents = NumberToString( nDimsWithoutParents );\r\n  If ( nDimsWithoutParents <> 0 );\r\n    sProcessAction = Expand( '%sProcessAction% There are elements having no parent in [%sDimsWithoutParents%] dimensions out of [%sDims%] matching.' );\r\n  Else;\r\n    sProcessAction = Expand( '%sProcessAction% All scanned dimensions are OK and contain no elements without parents.' );\r\n  EndIf;\r\nElse;\r\n  sProcessAction = 'No dimensions/hierarchies are matching supplied parameters.';\r\nEndIf;\r\nsProcessReturnCode  = Expand( '%sProcessReturnCode% %sProcessAction%' );\r\nnProcessReturnCode  = 1;\r\nIf( pLogoutput <> 0 );\r\n    LogOutput( cMsgInfoLevel, Expand( sProcessAction ) );\r\nEndIf;",
    "HasSecurityAccess": true,
    "MetadataProcedure": "#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n# Skip processing if there is no Leaves hierarchy defined for the dimension or we are processing Leaves\r\nIf ( HierarchyExists( vDim, cHierLeaves ) = 0 );\r\n  ItemSkip;\r\nEndIf;\r\n\r\n# Summary information printout\r\nIf ( sDimPrev @<> vDim );\r\n  If ( sDimPrev @<> '' & nElemsMissing <> 0 );\r\n    sElemsMissing = NumberToString( nElemsMissing );\r\n    If ( pLogOutput <> 0 );\r\n      LogOutput( cMsgInfoLevel, Expand( 'Dimension [%sDimPrev%] is missing [%sElemsMissing%] elements from [%cHierLeaves%] hierarchy in all of matching hierarchies [%pHier%]. List of elements is available in subset [%pTgtSub%] of [%cHierLeaves%] hierarchy.' ) );\r\n    EndIf;\r\n    nDimsWithOrphans = nDimsWithOrphans + 1;\r\n  EndIf;\r\n  If ( sDimPrev @<> '' & nElemsMissingParent <> 0 );\r\n    sElemsMissingParent = NumberToString( nElemsMissingParent );\r\n    If ( pLogOutput <> 0 );\r\n      LogOutput( cMsgInfoLevel, Expand( 'Dimension [%sDimPrev%] contains [%sElemsMissingParent%] elements that are missing parent in matching hierarchies [%pHier%].' ) );\r\n    EndIf;\r\n    nDimsWithoutParents = nDimsWithoutParents + 1;\r\n  EndIf;\r\n  nDims = nDims + 1;\r\n  nElemsMissing = 0;\r\n  nElemsMissingParent = 0;\r\n  sDimPrev = vDim;\r\nEndIf;\r\n\r\nIf( pHier @= '' );\r\n  sHier = vDim;\r\nElse;\r\n  sHier = pHier;\r\nEndIf;\r\n\r\nIf( sHier @= cAll );\r\n  sMDX = Expand( '{FILTER(TM1SUBSETALL([%cDimDimensions%]), [%cDimDimensions%].CurrentMember.Name = ''%vDim%'' OR INSTR([%cDimDimensions%].CurrentMember.Name, ''%vDim%:'' ) = 1 )}' );\r\n  SubsetMDXSet( cDimDimensions, cTempSub2, sMDX );\r\n  # Exclude Leaves from the count\r\n  nMaxHier = SubsetGetSize( cDimDimensions, cTempSub2 ) - 1;\r\nElse;\r\n  sMDX = Expand( '{TM1FILTERBYPATTERN({TM1SUBSETALL([%cDimDimensions%])}, ''%vDim%:%sHier%'')}' );\r\n  SubsetMDXSet( cDimDimensions, cTempSub2, sMDX );\r\n  nMaxHier = SubsetGetSize( cDimDimensions, cTempSub2 );\r\nEndIf;\r\n\r\nIf ( nMaxHier <> 0 );\r\n  nElem = 1;\r\n  nMaxElem = ElementCount( vDim, cHierLeaves );\r\n  While ( nElem <= nMaxElem );\r\n    sElem = ElementName( vDim, cHierLeaves, nElem );\r\n    nElems = 0;\r\n    nHier = 1;\r\n    While ( nHier <= nMaxHier );\r\n      sDimHier = SubsetGetElementName( cDimDimensions, cTempSub2, nHier );\r\n      nDelimHier = SCAN( ':', sDimHier );\r\n      If ( nDelimHier <> 0 );\r\n        sDim = SUBST( sDimHier, 1, nDelimHier - 1);\r\n        sHier = SUBST( sDimHier, nDelimHier + 1, LONG( sDimHier ) - nDelimHier );\r\n      Else;\r\n        sDim = sDimHier;\r\n        sHier = sDimHier;\r\n      EndIf;\r\n      If ( sHier @<> cHierLeaves );\r\n        If ( pIncludeNoParentElems <> 0 );\r\n          If(ElementIndex( sDim, sHier, sElem ) <> 0 & ElementParentCount( sDim, sHier, sElem ) = 0 & ElementLevel(sDim, sHier, sElem) = 0);\r\n            sTgtSubNoParents = Expand(pTgtSubNoParents);\r\n            If ( HierarchySubsetExists( sDim, cHierLeaves, sTgtSubNoParents ) = 0 );\r\n              HierarchySubsetCreate( sDim, cHierLeaves, sTgtSubNoParents );\r\n            ElseIf ( nElemsMissingParent = 0 );\r\n              HierarchySubsetDeleteAllElements( sDim, cHierLeaves, sTgtSubNoParents );\r\n            EndIf;\r\n            If ( HierarchySubsetElementExists( sDim, cHierLeaves, sTgtSubNoParents, sElem ) = 0 );\r\n              HierarchySubsetElementInsert( sDim, cHierLeaves, sTgtSubNoParents, sElem, 0 );\r\n            EndIf;\r\n            If ( pLogOutput > 1 );\r\n              LogOutput( cMsgInfoLevel, Expand( 'Element [%sElem%] is missing parent in [%sHier%] of dimension [%vDim%].' ) );\r\n            EndIf;\r\n            nElemsMissingParent = nElemsMissingParent + 1;\r\n          EndIf;\r\n        EndIf;\r\n        If ( ElementIndex( sDim, sHier, sElem ) = 0 );\r\n          nElems = nElems + 1;\r\n        EndIf;\r\n      EndIf;\r\n      nHier = nHier + 1;\r\n    End;\r\n    # We have scanned all hierarchies and if number of elements missing equals number of hierarchies (excl. Leaves) then the element is orphan in Leaves\r\n    If ( nElems = nMaxHier );\r\n      If ( HierarchySubsetExists( sDim, cHierLeaves, pTgtSubLeaves ) = 0 );\r\n        HierarchySubsetCreate( sDim, cHierLeaves, pTgtSubLeaves );\r\n      ElseIf ( nElemsMissing = 0 );\r\n        HierarchySubsetDeleteAllElements( sDim, cHierLeaves, pTgtSubLeaves );\r\n      EndIf;\r\n      If ( HierarchySubsetElementExists( sDim, cHierLeaves, pTgtSubLeaves, sElem ) = 0 );\r\n        HierarchySubsetElementInsert( sDim, cHierLeaves, pTgtSubLeaves, sElem, 0 );\r\n      EndIf;\r\n      If ( pLogOutput > 1 );\r\n        LogOutput( cMsgInfoLevel, Expand( 'Element [%sElem%] is missing in all matching hierarchies [%pHier%] of dimension [%vDim%] except [%cHierLeaves%].' ) );\r\n      EndIf;\r\n      nElemsMissing = nElemsMissing + 1;\r\n    EndIf;\r\n    nElem = nElem + 1;\r\n  End;\r\nEndIf;",
    "Name": "}bedrock.hier.leaves.orphan.check",
    "Parameters": [
        {
            "Name": "pLogOutput",
            "Prompt": "OPTIONAL: Write parameters and action summary to server message log (Boolean True = 1)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pStrictErrorHandling",
            "Prompt": "OPTIONAL: On encountering any error exit with major error status by ProcessQuit after writing to the server message log (Boolean True = 1)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pDim",
            "Prompt": "REQUIRED: Dimension accepts wildcards (if = * then all the dimensions)",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pHier",
            "Prompt": "OPTIONAL: Hierarchy accepts wildcards (all hierarchies except default and Leaves deleted if = *)",
            "Type": "String",
            "Value": "*"
        },
        {
            "Name": "pTgtSubLeaves",
            "Prompt": "OPTIONAL: Name of target subset to store orphans in Leaves hierarchy",
            "Type": "String",
            "Value": "Bedrock - Orphan Elements - Leaves"
        },
        {
            "Name": "pIncludeNoParentElems",
            "Prompt": "OPTIONAL: Include elements that have no parent in any of matching hierarchies",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pTgtSubNoParents",
            "Prompt": "OPTIONAL: Name of target subset to store elements that have no parent in any of matching hierarchies",
            "Type": "String",
            "Value": "Bedrock - No Parents"
        },
        {
            "Name": "pDelim",
            "Prompt": "OPTIONAL: Delimiter character (default value if blank = '&')",
            "Type": "String",
            "Value": "&"
        }
    ],
    "PrologProcedure": "#Region CallThisProcess\r\n# A snippet of code provided as an example how to call this process should the developer be working on a system without access to an editor with auto-complete.\r\nIf( 1 = 0 );\r\n    ExecuteProcess( '}bedrock.hier.leaves.orphan.check', 'pLogOutput', pLogOutput,\r\n      'pStrictErrorHandling', pStrictErrorHandling,\r\n    \t'pDim', '', 'pHier', '*',\r\n    \t'pTgtSubLeaves', 'Bedrock - Orphan Elements - Leaves',\r\n    \t'pIncludeNoParentElems', 0,\r\n    \t'pTgtSubNoParents', 'Bedrock - No Parents',\r\n    \t'pDelim', '&'\r\n\t);\r\nEndIf;\r\n#EndRegion CallThisProcess\r\n\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n#################################################################################################\r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock Ver 4.0~~##\r\n#################################################################################################\r\n\r\n#Region @DOC\r\n# Description:\r\n# This process checks all leaf elements (in the Leaves hierarchy) of the specified dimension(s).\r\n# Within the Leaves hierarchy for each element *all hierarchies* are scanned for the existance of the leaf element.\r\n# If the leaf element does not exist in all hierarchies except for Leaves then the element is classified as an orphan and added to the\r\n# \"Orphan Leaf Elements\" subset.\r\n# Additionally when running with pIncludeNoParentElems parameter set, elements that have no parent will be stored in No Parents subset\r\n# of matching hierarchy (except `Leaves`) within Leaves. The subset name might be accomodated and will be suffixed by dash and name of the matching hierarchy.\r\n#\r\n# Use case:\r\n# 1. Primarily intended to identify dimensions with maintenance issues during development/prototyping.\r\n# 2. Can also be used for trouble-shooting in productive instances.\r\n#\r\n#EndRegion @DOC\r\n\r\n### Global Variables\r\n\r\nStringGlobalVariable('sProcessReturnCode');\r\nNumericGlobalVariable('nProcessReturnCode');\r\nnProcessReturnCode= 0;\r\n\r\n### Constants\r\ncThisProcName     = GetProcessName();\r\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\r\ncRandomInt        = NumberToString( INT( RAND( ) * 1000 ));\r\ncTempSub1          = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\r\ncTempSub2         = cTempSub1 | '_2';\r\ncTempSubDim       = cThisProcName |'_Dim_'| cTimeStamp |'_'| cRandomInt;\r\ncUserName         = TM1User();\r\ncMsgErrorLevel    = 'ERROR';\r\ncMsgInfoLevel     = 'INFO';\r\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\r\ncLogInfo          = 'Process:%cThisProcName% run with parameters pDim:%pDim%.';\r\ncAll              = '*';\r\ncDimDimensions    = '}Dimensions';\r\ncHierLeaves       = 'Leaves';\r\ncSubMissing       = 'Bedrock - Orphan Elements - Leaves';\r\ncSubNoParents     = 'Bedrock - No Parents - %sHier%';\r\n\r\n### LogOutput parameters\r\nIF( pLogoutput = 1 );\r\n  LogOutput('INFO', Expand( cLogInfo ) );\r\nENDIF;\r\n\r\n### Validate Parameters\r\nnErrors = 0;\r\nnDims = 0;\r\nnDimsWithOrphans = 0;\r\nnDimsWithoutParents = 0;\r\nnElems = 0;\r\nnElemsMissing = 0;\r\nnElemsMissingParent = 0;\r\nsDimPrev = '';\r\n\r\nIf( Scan( '*', pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0 & Scan( ':', pDim ) > 0 & pHier @= '' );\r\n  # A hierarchy has been passed as dimension. Handle the input error by splitting dim:hier into dimension & hierarchy\r\n  pHier = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\r\n  pDim = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\r\nEndIf;\r\n\r\n### Validate delimiter\r\nIf( Trim( pDelim ) @= '' );\r\n  pDelim = '&';\r\nEndIf;\r\n\r\nIf( Trim( pTgtSubLeaves ) @= '' );\r\n  pTgtSubLeaves = cSubMissing;\r\nEndIf;\r\n\r\nIf( Trim( pTgtSubNoParents ) @= '' );\r\n  pTgtSubNoParents = cSubNoParents;\r\nElse;\r\n  pTgtSubNoParents = pTgtSubNoParents | ' - %sHier%';\r\nEndIf;\r\n\r\n### Validate dimension\r\nIf( Trim( pDim ) @= '' );\r\n  nErrors = 1;\r\n  sMessage = 'No dimension specified.';\r\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\n### If errors occurred terminate process with a major error status ###\r\nIf( nErrors <> 0 );\r\n  If( pStrictErrorHandling = 1 );\r\n      ProcessQuit;\r\n  Else;\r\n      ProcessBreak;\r\n  EndIf;\r\nEndIf;\r\n\r\n### Handle All dimensions or a dimension list\r\n### We will exclude hierarchies in this step and will filter them in connection with subsets in later steps\r\nIf ( TRIM( pDim ) @= cAll );\r\n  sMDX = Expand( '{FILTER(TM1SUBSETALL([%cDimDimensions%]), INSTR([%cDimDimensions%].CurrentMember.Name, '':'' ) = 0 )}' );\r\nElse;\r\n  sDimTokenizer = TRIM( pDim );\r\n  sMDX = '';\r\n  ### Loop and tokenize dimension list\r\n  While ( sDimTokenizer @<> '' );\r\n    nPos = SCAN( pDelim, sDimTokenizer );\r\n    If ( nPos = 0 );\r\n      nPos = LONG( sDimTokenizer ) + 1;\r\n    EndIf;\r\n    sSearchDim = TRIM( SUBST( sDimTokenizer, 1, nPos - 1 ) );\r\n    If( sMDX @= '' );\r\n      sMDX = Expand( '{TM1FILTERBYPATTERN({FILTER(TM1SUBSETALL([%cDimDimensions%]), INSTR([%cDimDimensions%].CurrentMember.Name, '':'' ) = 0 )}, \"%sSearchDim%\")}' );\r\n    Else;\r\n      sMDX = Expand( '%sMDX% + {TM1FILTERBYPATTERN({FILTER(TM1SUBSETALL([%cDimDimensions%]), INSTR([%cDimDimensions%].CurrentMember.Name, '':'' ) = 0 )}, \"%sSearchDim%\")}' );\r\n    EndIf;\r\n    ### Consume dimension and delimiter\r\n    sDimTokenizer = TRIM( DELET( sDimTokenizer, 1, nPos + LONG( pDelim ) - 1 ) );\r\n  End;\r\n  sMDX = Expand( '{%sMDX%}' );\r\nEndIf;\r\n\r\n### Create dimensions subset\r\nIf ( SubsetExists( cDimDimensions, cTempSub1 ) = 0 );\r\n  SubsetCreate( cDimDimensions, cTempSub1, 1 );\r\nEndIf;\r\nSubsetMDXSet( cDimDimensions, cTempSub1, sMDX );\r\nSubsetMDXSet( cDimDimensions, cTempSub1, '' );\r\n\r\n### Create hierachies working subset\r\nIf ( SubsetExists( cDimDimensions, cTempSub2 ) = 0 );\r\n  SubsetCreate( cDimDimensions, cTempSub2, 1 );\r\nEndIf;\r\n\r\nDatasourceNameForServer = cDimDimensions;\r\nDatasourceNameForClient = cDimDimensions;\r\nDataSourceType = 'SUBSET';\r\nDatasourceDimensionSubset = cTempSub1;",
    "UIData": "CubeAction=1511\fDataAction=1503\fCubeLogChanges=0\f",
    "Variables": [
        {
            "EndByte": 0,
            "Name": "vDim",
            "Position": 1,
            "StartByte": 0,
            "Type": "String"
        }
    ],
    "VariablesUIData": []
}