{
    "DataProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****",
    "DataSource": {
        "Type": "None"
    },
    "EpilogProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n#################################################################################################\r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock Ver 4.0~~##\r\n#################################################################################################\r\n\r\n### Write Output data\r\nIf( nErrors = 0 );\r\n  TextOutput( cExportFile, sTotalRowString );\r\n  TextOutput( cExportFile, sGlobPrivateSubsetsTotalString );\r\nENDIF;\r\n\r\n### Return code & final error message handling\r\nIf( nErrors > 0 );\r\n    sMessage = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\r\n    nProcessReturnCode = 0;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\r\n    If( pStrictErrorHandling = 1 );\r\n        ProcessQuit;\r\n    EndIf;\r\nElse;\r\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully created report file.' );\r\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\r\n    nProcessReturnCode = 1;\r\n    If( pLogoutput = 1 );\r\n        LogOutput('INFO', Expand( sProcessAction ) );\r\n    EndIf;\r\nEndIf;\r\n\r\n\r\n\r\n### End Epilog ###\r\n",
    "HasSecurityAccess": false,
    "MetadataProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****",
    "Name": "}bedrock.security.evaluate.mdx",
    "Parameters": [
        {
            "Name": "pLogOutput",
            "Prompt": "OPTIONAL: Write parameters and action summary to server message log (Boolean True = 1)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pStrictErrorHandling",
            "Prompt": "OPTIONAL: On encountering any error exit with major error status by ProcessQuit after writing to the server message log (Boolean True = 1)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pNameSpace",
            "Prompt": "If CAM ID is used we need to check namespaces enter 1 for CAMID 0 for not (mode 1)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pFilePath",
            "Prompt": "OPTIONAL: Export Directory (will default to error file path)",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pFileName",
            "Prompt": "OPTIONAL: Export Filename (If Left Blank Defaults to processname_export.csv)",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pDelim",
            "Prompt": "OPTIONAL: AsciiOutput delimiter character (Default=comma exactly 3 digits = ASCII code)",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pQuote",
            "Prompt": "OPTIONAL: AsciiOutput quote character (Accepts empty quote exactly 3 digits = ASCII code)",
            "Type": "String",
            "Value": ""
        }
    ],
    "PrologProcedure": "#Region CallThisProcess\r\n# A snippet of code provided as an example how to call this process should the developer be working on a system without access to an editor with auto-complete.\r\nIf( 1 = 0 );\r\n    ExecuteProcess('}bedrock.security.evaluate.mdx', 'pLogOutput', pLogOutput,\r\n       'pStrictErrorHandling', pStrictErrorHandling,\r\n       'pNameSpace', 0,\r\n       'pFilePath', pFilePath,\r\n       'pFileName', pFileName,\r\n       'pDelim', pDelim,\r\n       'pQuote', pQuote\r\n    );\r\nEndIf;\r\n#EndRegion CallThisProcess\r\n\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n#################################################################################################\r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock Ver 4.0~~##\r\n#################################################################################################\r\n\r\n#Region @DOC\r\n# Description:\r\n# This process will find out which dimensions have security on them - element security - and evaluate dynamic subsets with expressions impacted by the latest MDX security changes\r\n\r\n# Use case: Intended for development or production.\r\n\r\n\r\n# Note:\r\n#\r\n#EndRegion @DOC\r\n\r\n##Global Variables\r\nStringGlobalVariable('sProcessReturnCode');\r\nNumericGlobalVariable('nProcessReturnCode');\r\nStringGlobalVariable('sGlobPrivateSubsetsTotalString');\r\nsGlobPrivateSubsetsTotalString = '';\r\nnProcessReturnCode= 0;\r\n\r\n### Constants ###\r\ncThisProcName       = GetProcessName();\r\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\r\ncRandomInt          = NumberToString( INT( RAND( ) * 1000 ));\r\ncUserName           = TM1User();\r\ncMsgErrorLevel      = 'ERROR';\r\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\r\ncLogInfo            = 'Process:%cThisProcName% run with parameters pNameSpace:%pNameSpace%, pFilePath:%pFilePath%, pFileName:%pFileName%, pDelim:%pDelim%, pQuote:%pQuote%.' ;\r\ncMsgInfoContent    = 'User:%cUserName% Process:%cThisProcName% InfoMsg:%sMessage%';\r\ncSecurityPrefix = '}ElementSecurity_';\r\ncDimDim = '}Dimensions';\r\ncUserDim = '}Clients';\r\ncUserAttrDim= '}ElementAttributes_}Clients';\r\ncUserAlias = '}TM1_DefaultDisplayValue';\r\ncSubsetPrefix = '}Subsets_';\r\ncGroupDim = '}Groups';\r\ncSecCube = '}ClientGroups';\r\n\r\npFieldDelim       = TRIM(pDelim);\r\nsCRChar           = Char( 13 );\r\nsLFChar           = Char( 10 );\r\nsCRLF             = Char( 13 ) | Char( 10 );\r\ncLenASCIICode     = 3;\r\nnDataCount        = 0;\r\nnErrors           = 0;\r\n\r\ncKeyWordList = 'DRILLDOWN&.Children&FirstChild&Ancestors&Ascendants&Cousin&DrillUp&FirstSibling&IsAncestor&FirstSibling&LastChild&LastSibling&Descendants';\r\ncKeyWordList = UPPER ( cKeyWordList );\r\ncKeyWordDelimiter = '&';\r\n\r\n## LogOutput parameters\r\nIF( pLogoutput = 1 );\r\n    LogOutput('INFO', Expand( cLogInfo ) );\r\nENDIF;\r\n\r\n### Validate Parameters ###\r\n\r\n# Namespace\r\nIf( pNameSpace <> 0 & pNameSpace <> 1 );\r\n    nErrors         = 1;\r\n    sMessage        = 'NameSpace parameter not valid';\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\n## check operating system\r\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\r\n  sOS = 'Windows';\r\n  sOSDelim = '\\';\r\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0 );\r\n  sOS = 'Linux';\r\n  sOSDelim = '/';\r\nElse;\r\n  sOS = 'Windows';\r\n  sOSDelim = '\\';\r\nEndIf;\r\n\r\n# Validate file path\r\nIf(Trim( pFilePath ) @= '' );\r\n    pFilePath = GetProcessErrorFileDirectory;\r\nEndIf;\r\nIf( SubSt( pFilePath, Long( pFilePath ), 1 ) @= sOSDelim );\r\n    pFilePath = SubSt( pFilePath, 1, Long( pFilePath ) -1 );\r\nEndIf;\r\nIf(  FileExists( pFilePath ) = 0 );\r\n    sMessage = Expand('Invalid export directory: %pFilePath%');\r\n    nErrors = nErrors + 1;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\npFilePath = pFilePath | sOSDelim;\r\n\r\n# Validate file name\r\nIf( pFileName @= '' );\r\n    sBaseFileName = Expand('%cThisProcName%_Export');\r\n    sExt = '.csv';\r\n    pFileName = sBaseFileName | '.csv';\r\nElse;\r\n    # determine file extension. If no file extension entered then use .csv as default\r\n    If( Scan( '.', pFileName ) = 0 );\r\n        sExt = '.csv';\r\n        sBaseFileName = pFileName;\r\n    Else;\r\n        sExt = SubSt( pFileName, Scan( '.', pFileName ), Long( pFileName ) );\r\n        sBaseFileName = SubSt( pFileName, 1, Scan( '.', pFileName ) - 1 );\r\n    EndIf;\r\n    pFileName = sBaseFileName | sExt;\r\nEndIf;\r\ncExportFile = pFilePath | pFileName;\r\n\r\n# Validate file delimiter & quote character\r\nIf( pFieldDelim @= '' );\r\n    pFieldDelim = ',';\r\nElse;\r\n    # If length of pFieldDelim is exactly 3 chars and each of them is decimal digit, then the pFieldDelim is entered as ASCII code\r\n    nValid = 0;\r\n    If ( LONG(pFieldDelim) = cLenASCIICode );\r\n      nChar = 1;\r\n      While ( nChar <= cLenASCIICode );\r\n        If( CODE( pFieldDelim, nChar ) >= CODE( '0', 1 ) & CODE( pFieldDelim, nChar ) <= CODE( '9', 1 ) );\r\n          nValid = 1;\r\n        Else;\r\n          nValid = 0;\r\n        EndIf;\r\n        nChar = nChar + 1;\r\n      End;\r\n    EndIf;\r\n    If ( nValid<>0 );\r\n      pFieldDelim=CHAR(StringToNumber( pFieldDelim ));\r\n    Else;\r\n      pFieldDelim = SubSt( Trim( pFieldDelim ), 1, 1 );\r\n    EndIf;\r\nEndIf;\r\nIf( pQuote @= '' );\r\n    ## Use no quote character\r\nElse;\r\n    # If length of pQuote is exactly 3 chars and each of them is decimal digit, then the pQuote is entered as ASCII code\r\n    nValid = 0;\r\n    If ( LONG(pQuote) = cLenASCIICode );\r\n      nChar = 1;\r\n      While ( nChar <= cLenASCIICode );\r\n        If( CODE( pQuote, nChar ) >= CODE( '0', 1 ) & CODE( pQuote, nChar ) <= CODE( '9', 1 ) );\r\n          nValid = 1;\r\n        Else;\r\n          nValid = 0;\r\n        EndIf;\r\n        nChar = nChar + 1;\r\n      End;\r\n    EndIf;\r\n    If ( nValid<>0 );\r\n      pQuote=CHAR(StringToNumber( pQuote ));\r\n    Else;\r\n      pQuote = SubSt( Trim( pQuote ), 1, 1 );\r\n    EndIf;\r\nEndIf;\r\n\r\n### Check for errors before continuing\r\nIf( nErrors <> 0 );\r\n  If( pStrictErrorHandling = 1 );\r\n      ProcessQuit;\r\n  Else;\r\n      ProcessBreak;\r\n  EndIf;\r\nEndIf;\r\n\r\nDatasourceAsciiDelimiter = pFieldDelim;\r\nDatasourceAsciiQuoteCharacter = '';\r\nsTotalRowString = '';\r\n\r\nsTitleRow = '%pQuote%DIMENSION%pQuote%%pFieldDelim%%pQuote%HAS SECURITY%pQuote%%pFieldDelim%%pQuote%SUBSET NAME%pQuote%';\r\nsTitleRow = sTitleRow|'%pFieldDelim%%pQuote%IS PRIVATE%pQuote%%pFieldDelim%%pQuote%MDX EXPRESSION%pQuote%';\r\nsTitleRow = sTitleRow|'%pFieldDelim%%pQuote%KEYWORDS%pQuote%%pFieldDelim%%pQuote%ELEMENTS%pQuote%%pFieldDelim%%pQuote%USERS WITH NO ACCESS%pQuote%';\r\nTextOutput( cExportFile, Expand(sTitleRow) );\r\nsTotalRowString = Expand(sTitleRow);\r\n\r\niDim = 1;\r\nnMaxDim = DimSiz ( cDimDim );\r\n\r\nWhile ( iDim <= nMaxDim );\r\n    sDim = DimNm ( cDimDim, iDim );\r\n    sSecurityCube = cSecurityPrefix | sDim;\r\n    If ( CubeExists ( sSecurityCube ) = 1 );\r\n        IF( pLogoutput = 1 );\r\n            sMessage = 'The dimension ' | sDim | ' has element security assigned';\r\n            LogOutput('INFO', Expand( cMsgInfoContent ) );\r\n        ENDIF;\r\n        # now we need to go find subsets - two ways of doing this - data directory or }subset dimension\r\n        # data directory is the only place to find private subs but need to know the username to loop through\r\n    #########################################################################################################################################\r\n        iUser = 1;\r\n        nMaxUser = DimSiz ( cUserDim );\r\n        While ( iUser <= nMaxUser );\r\n            sUser = DimNm ( cUserDim, iUser );\r\n            # if CAMId is used folder structure is different\r\n            If ( DimIx ( cUserAttrDim, cUserAlias ) > 0 );\r\n                sAlias = AttrS ( cUserDim, sUser, cUserAlias );\r\n                If ( sAlias @= '' );\r\n                    sAlias = sUser;\r\n                EndIf;\r\n            EndIf;\r\n            sNamespacePrefix = '';\r\n            # if CAMId is used folder structure is different\r\n            If ( pNamespace = 1 );\r\n                # this \\ or / is hardcoded as it is the CAMID }TM1_DefaultDisplayValue alias which sometimes uses back- and sometimes forward-slash. We aren't sanning for directory separator.\r\n                nEnd = Scan( '/', sAlias);\r\n                If ( nEnd = 0 );\r\n                    nEnd = Scan ( '\\', sAlias );\r\n                EndIf;\r\n                sNamespace = SubSt ( sAlias, 1, nEnd - 1 );\r\n                sAlias = SubSt ( sAlias, nEnd + 1, Long ( sAlias ) - nEnd );\r\n                sNamespacePrefix = sNameSpace | sOSDelim;\r\n            EndIf;\r\n            sSubset = WildcardFileSearch( Expand('%sNameSpacePrefix%%sAlias%%sOSDelim%%sDim%}subs%sOSDelim%*.sub') , '');\r\n            # loop through all subsets\r\n            While ( sSubset @<> '' );\r\n                sSubsetName = Subst ( sSubset, 1, LONG ( sSubset ) - 4 );\r\n                sFile = Expand('%sNameSpacePrefix%%sAlias%%sOSDelim%%sDim%}subs%sOSDelim%%sSubset%') ;\r\n                IF( pLogoutput = 1 );\r\n                    sMessage = Expand('Private subset called %sSubsetName% found for user %sAlias% in dimension %sDim%. File = %sFile%');\r\n                    LogOutput('INFO', Expand( cMsgInfoContent ) );\r\n                ENDIF;\r\n                # run the sub process to evaluate the MDX\r\n                If ( sSubset @<> '' );\r\n                    nRet = ExecuteProcess('}bedrock.security.evaluate.mdx.private',\r\n                               'pLogOutput', pLogOutput,\r\n                               'pStrictErrorHandling', pStrictErrorHandling,\r\n                               'pUser', sUser,\r\n                               'pDimension', sDim,\r\n                               'pSubset', sSubsetName,\r\n                               'pSubsetFile', sFile,\r\n                               'pFilePath', pFilePath,\r\n                               'pFileName', '',\r\n                               'pDelim', pDelim,\r\n                               'pQuote', pQuote,\r\n                               'pWriteOutput', 0\r\n                      );\r\n                    If( nRet <> ProcessExitNormal() );\r\n                        nErrors = nErrors + 1;\r\n                        sMessage= 'Error in evaluating private subsets.';\r\n                        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n                    EndIf;\r\n\r\n                EndIf;\r\n                sSubset = WildcardFileSearch( Expand('%sNameSpacePrefix%%sAlias%%sOSDelim%%sDim%}subs%sOSDelim%*.sub') , sSubset);\r\n            End;\r\n            iUser = iUser + 1;\r\n        End;\r\n    ##########################################################################################################################################\r\n            # for public subsets we can use the subsets dimension\r\n    #########################################################################################################################################\r\n\r\n\r\n        sSubsetDim = cSubsetPrefix | sDim;\r\n        iSub = 1;\r\n        nSubsetMax = DimSiz ( sSubsetDim );\r\n        # loop through all subsets\r\n        While ( iSub <= nSubsetMax );\r\n            sSubsetName = DimNm ( sSubsetDim, iSub );\r\n            sMDX = '';\r\n            sMDX = SubsetMDXGet ( sDim, sSubsetName );\r\n            sMDX = UPPER ( sMDX );\r\n            If ( sMDX @<> '' );\r\n                ## Remove line breaks from MDX string\r\n                nMDXLen = Long( sMDX );\r\n                nMDXCount = 1;\r\n                While( nMDXCount <= nMDXLen );\r\n                  sCharPoint = Subst( sMDX, nMDXCount, 1 );\r\n                  IF( sCharPoint @= sCRChar % sCharPoint @= sLFChar );\r\n                      Delet( sMDX, nMDXCount, 1 );\r\n                      nMDXLen = Long( sMDX );\r\n                  ENDIF;\r\n\r\n                  nMDXCount = nMDXCount + 1;\r\n                End;\r\n                nMDXLen = Long( sMDX );\r\n                sMDXLastChar = Subst( sMDX, nMDXLen, 1 );\r\n                While( sMDXLastChar @<> '}' );\r\n                  sMDX = Subst( sMDX, 1, nMDXLen - 1 );\r\n                  nMDXLen = Long( sMDX );\r\n                  sMDXLastChar = Subst( sMDX, nMDXLen, 1 );\r\n                End;\r\n                sRow = '%pQuote%%sDim%%pQuote%%pFieldDelim%%pQuote%Y%pQuote%%pFieldDelim%%pQuote%%sSubsetName%%pQuote%%pFieldDelim%%pQuote%NO%pQuote%%pFieldDelim%%pQuote%%sMDX%%pQuote%';\r\n                IF( pLogoutput = 1 );\r\n                    sMessage = Expand('Public subset called %sSubsetName% found in dimension %sDim% with MDX %sMDX%');\r\n                    LogOutput('INFO', Expand( cMsgInfoContent ) );\r\n                ENDIF;\r\n                # now parse the MDX\r\n                nKeywordFlag = 0;\r\n                sKeyWordString = '';\r\n                sKeywordList = cKeywordList;\r\n                nKeywordLength = Long ( sKeywordList );\r\n                While ( nKeywordLength > 0 );\r\n                    nDelimiter = Scan ( cKeywordDelimiter, sKeyWordList );\r\n                    If ( nDelimiter = 0 );\r\n                        sKeyword = sKeyWordList;\r\n                        sKeyWordList = '';\r\n                    Else;\r\n                        nEnd = nDelimiter - 1;\r\n                        sKeyWord = SubSt ( sKeywordList, 1, nEnd );\r\n                        sKeyWordList = Subst ( sKeywordList, nEnd + 2, nKeywordLength - nEnd);\r\n                    EndIf;\r\n                    If ( Scan( sKeyWord, sMDX ) > 0 );\r\n                        nKeyWordFlag = nKeyWordFlag + 1;\r\n                        IF( Long( sKeyWordString ) = 0 );\r\n                          sKeyWordString = sKeyWordString | sKeyWord;\r\n                        ELSE;\r\n                          sKeyWordString = sKeyWordString | pDelim | ' ' | sKeyWord;\r\n                        ENDIF;\r\n                        IF( pLogoutput = 1 );\r\n                            sMessage = 'Keyword ' | sKeyWord | ' found in ' | sMDX;\r\n                            LogOutput('INFO', Expand( cMsgInfoContent ) );\r\n                        ENDIF;\r\n                    EndIf;\r\n                    nKeywordLength = Long ( sKeywordList );\r\n                End;\r\n                # if keywords found then see if we can match an element in the MDX with one in the dimension\r\n                # element will be included within [] but there will be [dimension][hierarchy][subset][attribute] so could be a false positive\r\n                If ( nKeyWordFlag > 0 );\r\n                    sRow = sRow|'%pFieldDelim%%pQuote%%sKeyWordString%%pQuote%';\r\n                    sUsersString = '';\r\n                    sElementString = '';\r\n                    sMDXTemp = sMDX;\r\n                    sStarter = '[';\r\n                    sEnder = ']';\r\n                    nMDXLength = Long ( sMDXTemp );\r\n                    While ( nMDXLength > 0 );\r\n                        nStarter = SCAN ( sStarter, sMDXTemp );\r\n                        If ( nStarter > 0 );\r\n                            nEnder = SCAN ( sEnder, sMDXTemp );\r\n                            sElement = SubSt ( sMDXTemp, nStarter + 1, nEnder - nStarter -1);\r\n                            nToGo = nMDXLength - nEnder + 1;\r\n                            sMDXTemp = Subst ( sMDXTemp, nEnder + 1, nToGo );\r\n                            # check if that is actually an element\r\n                            If ( DimIx ( sDim, sElement ) > 0 );\r\n                                IF( Scan( sElement, sElementString ) = 0 );\r\n                                    IF( sElementString @= '' );\r\n                                        sElementString = sElementString | sElement;\r\n                                    ELSE;\r\n                                        sElementString = sElementString | pDelim | ' ' | sElement;\r\n                                    ENDIF;\r\n                                ENDIF;\r\n                                IF( pLogoutput = 1 );\r\n                                    sMessage = sElement | ' is referenced in the MDX and exists in the dimension';\r\n                                    LogOutput('INFO', Expand( cMsgInfoContent ) );\r\n                                ENDIF;\r\n                                #loop thropugh all users\r\n                                iUser = 1;\r\n                                nMaxUser = DimSiz ( cUserDim );\r\n                                While ( iUser <= nMaxUser );\r\n                                    sUser = DimNm ( cUserDim, iUser );\r\n                                    # now need to loop through relevant groups to see access\r\n                                    # loop through all groups to check access to this element\r\n                                    nUserCheck = 0;\r\n                                    iGroup = 1;\r\n                                    nGroupMax = DimSiz ( cGroupDim );\r\n                                    While ( iGroup <= nGroupMax );\r\n                                        sGroup = DimNm ( cGroupDim, iGroup );\r\n                                        #skip the admin groups!\r\n                                        If ( sGroup @<> 'ADMIN' & sGroup @<> 'SecurityAdmin' & sGroup @<> 'DataAdmin' & sGroup @<> 'OperationsAdmin' );\r\n                                            nCheck = 1;\r\n                                            # if we have a user check membership and we don;t need to continue if not in that group\r\n                                            If ( CellGetS ( cSecCube, sUser, sGroup ) @= '' );\r\n                                                nCheck = 0;\r\n                                            EndIf;\r\n                                            If ( nCheck = 1 );\r\n                                                # get the groups security assignment\r\n                                                sAccess = CellGetS ( sSecurityCube, sElement, sGroup );\r\n                                                # if the user has rights to that element then all is good and we can quit the loops\r\n                                                If ( sAccess @<> '' & sAccess @<> 'NONE' );\r\n                                                    nUserCheck = 1;\r\n                                                    iGroup = nGroupMax + 1;\r\n                                                EndIf;\r\n                                            EndIf;\r\n                                        Else;\r\n                                            # if the user is in an admin group them they will have access\r\n\r\n                                            If ( CellGetS ( cSecCube, sUser, sGroup ) @<> '' );\r\n                                                nUserCheck = 1;\r\n                                                iGroup = nGroupMax + 1;\r\n                                            EndIf;\r\n                                        EndIf;\r\n                                        iGroup = iGroup + 1;\r\n                                    End;\r\n                                    If ( nUserCheck = 0 );\r\n                                        IF( Scan( sUser, sUsersString ) = 0 );\r\n                                            IF( sUsersString @= '' );\r\n                                              sUsersString = sUsersString | sUser;\r\n                                            ELSE;\r\n                                              sUsersString = sUsersString | pDelim | ' ' | sUser;\r\n                                            ENDIF;\r\n                                        ENDIF;\r\n                                        IF( pLogoutput = 1 );\r\n                                            sMessage = Expand('Public subset %sSubsetName% contains a keyword and a specific element %sElement% that the user %sUser% do not have access to');\r\n                                            LogOutput('INFO', Expand( cMsgInfoContent ) );\r\n                                        ENDIF;\r\n                                    EndIf;\r\n                                    iUser = iUser + 1;\r\n                                End;\r\n                            EndIf;\r\n                            nMDXLength = Long ( sMDXTemp );\r\n                        Else;\r\n                            nMDXLength = 0;\r\n                        EndIf;\r\n                    End;\r\n\r\n                sRow = sRow|'%pFieldDelim%%pQuote%%sElementString%%pQuote%%pFieldDelim%%pQuote%%sUsersString%%pQuote%';\r\n                sTotalRowString = sTotalRowString | sCRLF | Expand(sRow);\r\n                # Output data\r\n                #TextOutput( cExportFile, Expand(sRow) );\r\n                EndIf;\r\n            EndIf;\r\n            iSub = iSub + 1;\r\n        End;\r\n\r\n    ##########################################################################################################################################\r\n    EndIf;\r\n    iDim = iDim + 1;\r\nEnd;",
    "UIData": "CubeAction=1511\fDataAction=1503\fCubeLogChanges=0\f",
    "Variables": [],
    "VariablesUIData": []
}