{
    "DataProcedure": "#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n\r\n#################################################################################################\r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock Ver 4.0~~##\r\n#################################################################################################\r\n\r\nIf( pFile > 0 );\r\n  v0 = v1; v1 = v2; v2 = v3;  v3 = v4; v4 = v5; v5 = v6; v6 = v7; v7 = v8; v8 = v9; v9 = v10; v10 = v11; v11 = v12; v12 = v13; v13 = v14; v14 = v15;\r\n  v15 = v16; v16 = v17; v17 = v18; v18 = v19; v19 = v20; v20 = v21; v21 = v22; v22 = v23; v23 = v24; v24 = v25; v25 = v26; v26 = v27; v27 = v28;  v28 = v29;\r\nEndIf;\r\n\r\nv1 = IF(nMappedDim1 = 1, IF(v1 @= sSourceDim1 % elisanc(sDim1,sSourceDim1,v1)=1, sTargetDim1, v1), v1);\r\nv2 = IF(nMappedDim2 = 1, IF(v2 @= sSourceDim2 % elisanc(sDim2,sSourceDim2,v2)=1, sTargetDim2, v2), v2);\r\nv3 = IF(nMappedDim3 = 1, IF(v3 @= sSourceDim3 % elisanc(sDim3,sSourceDim3,v3)=1, sTargetDim3, v3), v3);\r\nv4 = IF(nMappedDim4 = 1, IF(v4 @= sSourceDim4 % elisanc(sDim4,sSourceDim4,v4)=1, sTargetDim4, v4), v4);\r\nv5 = IF(nMappedDim5 = 1, IF(v5 @= sSourceDim5 % elisanc(sDim5,sSourceDim5,v5)=1, sTargetDim5, v5), v5);\r\nv6 = IF(nMappedDim6 = 1, IF(v6 @= sSourceDim6 % elisanc(sDim6,sSourceDim6,v6)=1, sTargetDim6, v6), v6);\r\nv7 = IF(nMappedDim7 = 1, IF(v7 @= sSourceDim7 % elisanc(sDim7,sSourceDim7,v7)=1, sTargetDim7, v7), v7);\r\nv8 = IF(nMappedDim8 = 1, IF(v8 @= sSourceDim8 % elisanc(sDim8,sSourceDim8,v8)=1, sTargetDim8, v8), v8);\r\nv9 = IF(nMappedDim9 = 1, IF(v9 @= sSourceDim9 % elisanc(sDim9,sSourceDim9,v9)=1, sTargetDim9, v9), v9);\r\nv10 = IF(nMappedDim10 = 1, IF(v10 @= sSourceDim10 % elisanc(sDim10,sSourceDim10,v10)=1, sTargetDim10, v10), v10);\r\nv11 = IF(nMappedDim11 = 1, IF(v11 @= sSourceDim11 % elisanc(sDim11,sSourceDim11,v11)=1, sTargetDim11, v11), v11);\r\nv12 = IF(nMappedDim12 = 1, IF(v12 @= sSourceDim12 % elisanc(sDim12,sSourceDim12,v12)=1, sTargetDim12, v12), v12);\r\nv13 = IF(nMappedDim13 = 1, IF(v13 @= sSourceDim13 % elisanc(sDim13,sSourceDim13,v13)=1, sTargetDim13, v13), v13);\r\nv14 = IF(nMappedDim14 = 1, IF(v14 @= sSourceDim14 % elisanc(sDim14,sSourceDim14,v14)=1, sTargetDim14, v14), v14);\r\nv15 = IF(nMappedDim15 = 1, IF(v15 @= sSourceDim15 % elisanc(sDim15,sSourceDim15,v15)=1, sTargetDim15, v15), v15);\r\nv16 = IF(nMappedDim16 = 1, IF(v16 @= sSourceDim16 % elisanc(sDim16,sSourceDim16,v16)=1, sTargetDim16, v16), v16);\r\nv17 = IF(nMappedDim17 = 1, IF(v17 @= sSourceDim17 % elisanc(sDim17,sSourceDim17,v17)=1, sTargetDim17, v17), v17);\r\nv18 = IF(nMappedDim18 = 1, IF(v18 @= sSourceDim18 % elisanc(sDim18,sSourceDim18,v18)=1, sTargetDim18, v18), v18);\r\nv19 = IF(nMappedDim19 = 1, IF(v19 @= sSourceDim19 % elisanc(sDim19,sSourceDim19,v19)=1, sTargetDim19, v19), v19);\r\nv20 = IF(nMappedDim20 = 1, IF(v20 @= sSourceDim20 % elisanc(sDim20,sSourceDim20,v20)=1, sTargetDim20, v20), v20);\r\nv21 = IF(nMappedDim21 = 1, IF(v21 @= sSourceDim21 % elisanc(sDim21,sSourceDim21,v21)=1, sTargetDim21, v21), v21);\r\nv22 = IF(nMappedDim22 = 1, IF(v22 @= sSourceDim22 % elisanc(sDim22,sSourceDim22,v22)=1, sTargetDim22, v22), v22);\r\nv23 = IF(nMappedDim23 = 1, IF(v23 @= sSourceDim23 % elisanc(sDim23,sSourceDim23,v23)=1, sTargetDim23, v23), v23);\r\nv24 = IF(nMappedDim24 = 1, IF(v24 @= sSourceDim24 % elisanc(sDim23,sSourceDim24,v24)=1, sTargetDim24, v24), v24);\r\nv25 = IF(nMappedDim25 = 1, IF(v25 @= sSourceDim25 % elisanc(sDim25,sSourceDim25,v25)=1, sTargetDim25, v25), v25);\r\nv26 = IF(nMappedDim26 = 1, IF(v26 @= sSourceDim26 % elisanc(sDim26,sSourceDim26,v26)=1, sTargetDim26, v26), v26);\r\nv27 = IF(nMappedDim27 = 1, IF(v27 @= sSourceDim27 % elisanc(sDim27,sSourceDim27,v27)=1, sTargetDim27, v27), v27);\r\n\r\n\r\n### Write data from source version to target version ###\r\n\r\n# Selects the correct CellPut formula depending upon the number of dimensions in the cube\r\n# and whether the value is numeric or string ( max 27 dims catered for in this code )\r\n# value type determined by element type of last dimension in cube\r\n# could have used Value_is_String = 1 and NValue/SValue but this works just as well\r\n\r\n\r\nIf( nDimensionCount = 2 );\r\n    If( CellIsUpdateable( pCube, v1, v2 ) = 1 );\r\n        sElType = DType( sDim2, v2 );\r\n        IF( SubSt( pCube, 1, 17 ) @= '}ElementSecurity_');\r\n            v3 = IF( v3 @= '', 'NONE', v3 );\r\n            ElementSecurityPut( v3, sDim1, v1, v2 );\r\n        ELSEIF( sElType @= 'AA' );\r\n            AttrPutS( v3, sDim1, v1, v2, 1 );\r\n        ELSEIF( sElType @= 'AS' );\r\n            AttrPutS( v3, sDim1, v1, v2 );\r\n        ELSEIF( sElType @= 'AN' );\r\n            AttrPutN( StringToNumberEx( v3, sDecimalSeparator, sThousandSeparator ) * nFactor, sDim1, v1, v2 );\r\n        ElseIf( sElType @= 'S' );\r\n            CellPutS( v3, pCube, v1, v2 );\r\n        Else;\r\n            IF( pCumulate = 1);\r\n                nObal = CellGetN( pCube, v1, v2 );\r\n                nCbal = nObal + StringToNumberEx( v3, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n            ELSE;\r\n                nCbal = StringToNumberEx( v3, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n            Endif;\r\n            CellPutN( nCbal, pCube, v1, v2 );\r\n        EndIf;\r\n    EndIf;\r\nElseIf( nDimensionCount = 3 );\r\n    If( CellIsUpdateable( pCube, v1, v2, v3 ) = 1 );\r\n        sElType = DType( sDim3, v3 );\r\n        If( sElType @<> 'S' );\r\n            IF( pCumulate = 1);\r\n                nObal = CellGetN( pCube, v1, v2, v3 );\r\n                nCbal = nObal + StringToNumberEx( v4, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n            ELSE;\r\n                nCbal = StringToNumberEx( v4, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n            Endif;\r\n            CellPutN( nCbal, pCube, v1, v2, v3 );\r\n        Else;\r\n            CellPutS( v4, pCube, v1, v2, v3 );\r\n        EndIf;\r\n    EndIf;\r\nElseIf( nDimensionCount = 4 );\r\n    If( CellIsUpdateable( pCube, v1, v2, v3, v4 ) = 1 );\r\n        sElType = DType( sDim4, v4 );\r\n        If( sElType @<> 'S' );\r\n            IF( pCumulate = 1);\r\n                nObal = CellGetN( pCube, v1, v2, v3, v4);\r\n                nCbal = nObal + StringToNumberEx( v5, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n            ELSE;\r\n                nCbal = StringToNumberEx( v5, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n            Endif;\r\n            CellPutN( nCbal, pCube, v1, v2, v3, v4);\r\n        Else;\r\n            CellPutS( v5, pCube, v1, v2, v3, v4);\r\n        EndIf;\r\n    EndIf;\r\nElseIf( nDimensionCount = 5 );\r\n    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5 ) = 1 );\r\n      sElType = DType( sDim5, v5 );\r\n      If( sElType @<> 'S' );\r\n        IF(pCumulate = 1);\r\n          nObal = CellGetN( pCube, v1, v2, v3, v4, v5 );\r\n          nCbal = nObal + StringToNumberEx( v6, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        ELSE;\r\n          nCbal = StringToNumberEx( v6, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        Endif;\r\n        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5 );\r\n      Else;\r\n        CellPutS( v6, pCube, v1, v2, v3, v4, v5 );\r\n      EndIf;\r\n    EndIf;\r\n  ElseIf( nDimensionCount = 6 );\r\n    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6 ) = 1 );\r\n      sElType = DType( sDim6, v6 );\r\n      If( sElType @<> 'S' );\r\n        IF( pCumulate = 1);\r\n          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6 );\r\n          nCbal = nObal + StringToNumberEx( v7, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        ELSE;\r\n          nCbal = StringToNumberEx( v7, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        Endif;\r\n        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6 );\r\n      Else;\r\n        CellPutS( v7, pCube, v1, v2, v3, v4, v5, v6 );\r\n      EndIf;\r\n    EndIf;\r\n  ElseIf( nDimensionCount = 7 );\r\n    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7 ) = 1 );\r\n      sElType = DType( sDim7, v7 );\r\n      If( sElType @<> 'S' );\r\n        IF( pCumulate = 1);\r\n          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7 );\r\n          nCbal = nObal + StringToNumberEx( v8, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        ELSE;\r\n          nCbal = StringToNumberEx( v8, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        Endif;\r\n        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7 );\r\n      Else;\r\n        CellPutS( v8, pCube, v1, v2, v3, v4, v5, v6, v7 );\r\n      EndIf;\r\n    EndIf;\r\n  ElseIf( nDimensionCount = 8 );\r\n    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8 ) = 1 );\r\n      sElType = DType( sDim8, v8 );\r\n      If( sElType @<> 'S' );\r\n        IF( pCumulate = 1);\r\n          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8 );\r\n          nCbal = nObal + StringToNumberEx( v9, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        ELSE;\r\n          nCbal = StringToNumberEx( v9, sDecimalSeparator, sThousandSeparator )* nFactor;\r\n        Endif;\r\n        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8 );\r\n      Else;\r\n        CellPutS( v9, pCube, v1, v2, v3, v4, v5, v6, v7, v8 );\r\n      EndIf;\r\n    EndIf;\r\n  ElseIf( nDimensionCount = 9 );\r\n    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9 ) = 1 );\r\n      sElType = DType( sDim9, v9 );\r\n      If( sElType @<> 'S' );\r\n        IF( pCumulate = 1);\r\n          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9 );\r\n          nCbal = nObal + StringToNumberEx( v10, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        ELSE;\r\n          nCbal = StringToNumberEx( v10, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        Endif;\r\n        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9 );\r\n      Else;\r\n        CellPutS( v10, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9 );\r\n      EndIf;\r\n    EndIf;\r\n  ElseIf( nDimensionCount = 10 );\r\n    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10 ) = 1 );\r\n      sElType = DType( sDim10, v10 );\r\n      If( sElType @<> 'S' );\r\n        IF( pCumulate = 1);\r\n          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10 );\r\n          nCbal = nObal + StringToNumberEx( v11, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        ELSE;\r\n          nCbal = StringToNumberEx( v11, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        Endif;\r\n        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10 );\r\n      Else;\r\n        CellPutS( v11, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10 );\r\n      EndIf;\r\n    EndIf;\r\n  ElseIf( nDimensionCount = 11 );\r\n    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11 ) = 1 );\r\n      sElType = DType( sDim11, v11 );\r\n      If( sElType @<> 'S' );\r\n        IF( pCumulate = 1);\r\n          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11 );\r\n          nCbal = nObal + StringToNumberEx( v12, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        ELSE;\r\n          nCbal = StringToNumberEx( v12, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        Endif;\r\n        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11 );\r\n      Else;\r\n        CellPutS( v12, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11 );\r\n      EndIf;\r\n    EndIf;\r\n  ElseIf( nDimensionCount = 12 );\r\n    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12 ) = 1 );\r\n      sElType = DType( sDim12, v12 );\r\n      If( sElType @<> 'S' );\r\n        IF( pCumulate = 1);\r\n          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12 );\r\n          nCbal = nObal + StringToNumberEx( v13, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        ELSE;\r\n          nCbal = StringToNumberEx( v13, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        Endif;\r\n        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12 );\r\n      Else;\r\n        CellPutS( v13, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12 );\r\n      EndIf;\r\n    EndIf;\r\n  ElseIf( nDimensionCount = 13 );\r\n    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13 ) = 1 );\r\n      sElType = DType( sDim13, v13 );\r\n      If( sElType @<> 'S' );\r\n        IF( pCumulate = 1);\r\n          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13 );\r\n          nCbal = nObal + StringToNumberEx( v14, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        ELSE;\r\n          nCbal = StringToNumberEx( v14, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        Endif;\r\n        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13 );\r\n      Else;\r\n        CellPutS( v14, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13 );\r\n      EndIf;\r\n    EndIf;\r\n  ElseIf( nDimensionCount = 14 );\r\n    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14 ) = 1 );\r\n      sElType = DType( sDim14, v14 );\r\n      If( sElType @<> 'S' );\r\n        IF( pCumulate = 1);\r\n          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14 );\r\n          nCbal = nObal + StringToNumberEx( v15, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        ELSE;\r\n          nCbal = StringToNumberEx( v15, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        Endif;\r\n        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14 );\r\n      Else;\r\n        CellPutS( v15, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14 );\r\n      EndIf;\r\n    EndIf;\r\n  ElseIf( nDimensionCount = 15 );\r\n    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 ) = 1 );\r\n      sElType = DType( sDim15, v15 );\r\n      If( sElType @<> 'S' );\r\n        IF( pCumulate = 1);\r\n          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 );\r\n          nCbal = nObal + StringToNumberEx( v16, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        ELSE;\r\n          nCbal = StringToNumberEx( v16, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        Endif;\r\n        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 );\r\n      Else;\r\n        CellPutS( v16, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 );\r\n      EndIf;\r\n    EndIf;\r\n  ElseIf( nDimensionCount = 16 );\r\n    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16 ) = 1 );\r\n      sElType = DType( sDim16, v16 );\r\n      If( sElType @<> 'S' );\r\n        IF( pCumulate = 1);\r\n          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16 );\r\n          nCbal = nObal + StringToNumberEx( v17, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        ELSE;\r\n          nCbal = StringToNumberEx( v17, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        Endif;\r\n        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16 );\r\n      Else;\r\n        CellPutS( v17, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16 );\r\n      EndIf;\r\n    EndIf;\r\n  ElseIf( nDimensionCount = 17 );\r\n    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17 ) = 1 );\r\n      sElType = DType( sDim17, v17 );\r\n      If( sElType @<> 'S' );\r\n        IF( pCumulate = 1);\r\n          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17 );\r\n          nCbal = nObal + StringToNumberEx( v18, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        ELSE;\r\n          nCbal = StringToNumberEx( v18, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        Endif;\r\n        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17 );\r\n      Else;\r\n        CellPutS( v18, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17 );\r\n      EndIf;\r\n    EndIf;\r\n  ElseIf( nDimensionCount = 18 );\r\n    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18 ) = 1 );\r\n      sElType = DType( sDim18, v18 );\r\n      If( sElType @<> 'S' );\r\n        IF( pCumulate = 1);\r\n          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18 );\r\n          nCbal = nObal + StringToNumberEx( v19, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        ELSE;\r\n          nCbal = StringToNumberEx( v19, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        Endif;\r\n        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18 );\r\n      Else;\r\n        CellPutS( v19, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18 );\r\n      EndIf;\r\n    EndIf;\r\n  ElseIf( nDimensionCount = 19 );\r\n    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19 ) = 1 );\r\n      sElType = DType( sDim19, v19 );\r\n      If( sElType @<> 'S' );\r\n        IF( pCumulate = 1);\r\n          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19 );\r\n          nCbal = nObal + StringToNumberEx( v20, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        ELSE;\r\n          nCbal = StringToNumberEx( v20, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        Endif;\r\n        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19 );\r\n      Else;\r\n        CellPutS( v20, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19 );\r\n      EndIf;\r\n    EndIf;\r\n  ElseIf( nDimensionCount = 20 );\r\n    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20 ) = 1 );\r\n      sElType = DType( sDim20, v20 );\r\n      If( sElType @<> 'S' );\r\n        IF( pCumulate = 1);\r\n          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20 );\r\n          nCbal = nObal + StringToNumberEx( v21, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        ELSE;\r\n          nCbal = StringToNumberEx( v21, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        Endif;\r\n        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20 );\r\n      Else;\r\n        CellPutS( v21, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20 );\r\n      EndIf;\r\n    EndIf;\r\n  ElseIf( nDimensionCount = 21 );\r\n    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21 ) = 1 );\r\n      sElType = DType( sDim21, v21 );\r\n      If( sElType @<> 'S' );\r\n        IF( pCumulate = 1);\r\n          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21 );\r\n          nCbal = nObal + StringToNumberEx( v22, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        ELSE;\r\n          nCbal = StringToNumberEx( v22, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        Endif;\r\n        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21 );\r\n      Else;\r\n        CellPutS( v22, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21 );\r\n      EndIf;\r\n    EndIf;\r\n  ElseIf( nDimensionCount = 22 );\r\n    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22 ) = 1 );\r\n      sElType = DType( sDim22, v22 );\r\n      If( sElType @<> 'S' );\r\n        IF( pCumulate = 1);\r\n          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22 );\r\n          nCbal = nObal + StringToNumberEx( v23, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        ELSE;\r\n          nCbal = StringToNumberEx( v23, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        Endif;\r\n        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22 );\r\n      Else;\r\n        CellPutS( v23, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22 );\r\n      EndIf;\r\n    EndIf;\r\n  ElseIf( nDimensionCount = 23 );\r\n    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21,\r\n    v22, v23 ) = 1 );\r\n      sElType = DType( sDim23, v23 );\r\n      If( sElType @<> 'S' );\r\n        IF( pCumulate >= 1);\r\n          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23 );\r\n          nCbal = nObal + StringToNumberEx( v24, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        ELSE;\r\n          nCbal = StringToNumberEx( v24, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        Endif;\r\n        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23 );\r\n      Else;\r\n        CellPutS( v24, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23 );\r\n      EndIf;\r\n    EndIf;\r\n  ElseIf( nDimensionCount = 24 );\r\n    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24 ) = 1 );\r\n      sElType = DType( sDim24, v24 );\r\n      If( sElType @<> 'S' );\r\n        IF( pCumulate = 1);\r\n          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24 );\r\n          nCbal = nObal + StringToNumberEx( v25, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        ELSE;\r\n          nCbal = StringToNumberEx( v25, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        Endif;\r\n        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24 );\r\n      Else;\r\n        CellPutS( v25, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24 );\r\n      EndIf;\r\n    EndIf;\r\n  ElseIf( nDimensionCount = 25 );\r\n    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25 ) = 1 );\r\n      sElType = DType( sDim25, v25 );\r\n      If( sElType @<> 'S' );\r\n        IF( pCumulate = 1);\r\n          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25 );\r\n          nCbal = nObal + StringToNumberEx( v26, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        ELSE;\r\n          nCbal = StringToNumberEx( v26, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        Endif;\r\n        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25 );\r\n      Else;\r\n        CellPutS( v26, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25 );\r\n      EndIf;\r\n    EndIf;\r\nElseIf( nDimensionCount = 26 );\r\n    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21,\r\n    v22, v23, v24, v25, v26 ) = 1 );\r\n      sElType = DType( sDim26, v26 );\r\n      If( sElType @<> 'S' );\r\n        IF( pCumulate = 1);\r\n          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26 );\r\n          nCbal = nObal + StringToNumberEx( v27, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        ELSE;\r\n          nCbal = StringToNumberEx( v27, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        Endif;\r\n        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26 );\r\n      Else;\r\n        CellPutS( v27, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26 );\r\n      EndIf;\r\n    EndIf;\r\nElseIf( nDimensionCount = 27 );\r\n    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27 ) = 1 );\r\n      sElType = DType( sDim27, v27 );\r\n      If( sElType @<> 'S' );\r\n        IF( pCumulate >= 1);\r\n          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27 );\r\n          nCbal = nObal + StringToNumberEx( v28, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        ELSE;\r\n          nCbal = StringToNumberEx( v28, sDecimalSeparator, sThousandSeparator ) * nFactor;\r\n        Endif;\r\n        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27 );\r\n      Else;\r\n        CellPutS( v28, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27 );\r\n      EndIf;\r\n    EndIf;\r\n\r\n  EndIf;\r\n\r\n\r\n### End Data ###",
    "DataSource": {
        "Type": "?",
        "asciiDecimalSeparator": ".",
        "asciiDelimiterChar": ",",
        "asciiHeaderRecords": 0,
        "asciiQuoteCharacter": "\"",
        "asciiThousandSeparator": ",",
        "dataSourceNameForClient": "zzSYS 50 Dim Cube",
        "dataSourceNameForServer": "zzSYS 50 Dim Cube"
    },
    "EpilogProcedure": "#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n\r\n#################################################################################################\r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock Ver 4.0~~##\r\n#################################################################################################\r\n\r\n# Zero out source cube #\r\nIF( pZeroSource = 1 & nErrors = 0 );\r\n    sProc = '}bedrock.cube.data.clear';\r\n    nRet = ExecuteProcess( sProc,\r\n        'pLogOutput', pLogOutput,\r\n        'pStrictErrorHandling', pStrictErrorHandling,\r\n        'pCube', pCube,\r\n        'pView', cViewSource,\r\n        'pFilter', sFilter,\r\n        'pDimDelim', pDimDelim,\r\n        'pEleStartDelim', pEleStartDelim,\r\n        'pEleDelim', pEleDelim,\r\n        'pTemp', pTemp,\r\n        'pCubeLogging', pCubeLogging,\r\n        'pSandbox', pSandbox\r\n    );\r\n    If(nRet <> 0);\r\n        sMessage = 'Error clearing the source view.';\r\n        nErrors = nErrors + 1;\r\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n        ProcessError();\r\n    EndIf;\r\nEndIf;\r\n\r\n\r\nIf( pCubeLogging <= 1 );\r\n    CubeSetLogChanges( pCube, IF(sCubeLogging@='YES',1,0) );\r\nEndIf;\r\n\r\n### Delete export file if used\r\nIf( pFile = 1 );\r\n  If( sOS @= 'Linux' );\r\n    TM1RunCmd = 'rm \"' | cFile | '\"';\r\n  Else;\r\n    TM1RunCmd = 'CMD.EXE /C \"DEL \"' | cFile | '\" \"';\r\n  EndIf;\r\n  EXECUTECOMMAND ( TM1RunCmd , 0 );\r\nEndIf;\r\n\r\n### Delete thread control file if used\r\nIf( pThreadControlFile @<> '' );\r\n    LogOutput( 'INFO', 'Removing thread control file: ' | pThreadControlFile );\r\n    ASCIIDelete( cDir | pThreadControlFile | '.txt' );\r\nEndIf;\r\n\r\n### Wait for all parallel threads to finish if using pFilterParallel\r\nIf( pFilterParallel @<> '' );\r\n    sThreadFilePattern = GetProcessName() | '_ThreadControlFile_' | cRandomInt | '_' | '*.txt';\r\n    LogOutput( 'INFO', 'Checking for: ' | sThreadFilePattern );\r\n    i = 1;\r\n    While( i < pMaxWaitSeconds );\r\n        sThreadCheck = WildcardFileSearch( cDir | sThreadFilePattern, '' );\r\n        If( sThreadCheck @<> '' );\r\n            Sleep( 1 );\r\n        Else;\r\n            Break;\r\n        EndIf;\r\n\r\n    i = i + 1;\r\n    End;\r\nEndIf;\r\n\r\n### Return code & final error message handling\r\nIf( nErrors > 0 );\r\n    sMessage = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\r\n    nProcessReturnCode = 0;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\r\n    If( pStrictErrorHandling = 1 );\r\n        ProcessQuit;\r\n    EndIf;\r\nElse;\r\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully copied data from %pSrcView% view to the %pTgtView% view in the %pCube% cube.' );\r\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\r\n    nProcessReturnCode = 1;\r\n    If( pLogoutput = 1 );\r\n        LogOutput('INFO', Expand( sProcessAction ) );\r\n    EndIf;\r\nEndIf;\r\n\r\n### End Epilog ###",
    "HasSecurityAccess": true,
    "MetadataProcedure": "#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n",
    "Name": "}bedrock.cube.data.copy",
    "Parameters": [
        {
            "Name": "pLogOutput",
            "Prompt": "OPTIONAL: Write parameters and action summary to server message log (Boolean True = 1)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pStrictErrorHandling",
            "Prompt": "OPTIONAL: On encountering any error exit with major error status by ProcessQuit after writing to the server message log (Boolean True = 1)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pCube",
            "Prompt": "REQUIRED: Cube",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pSrcView",
            "Prompt": "OPTIONAL: Temporary view name for source",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pTgtView",
            "Prompt": "OPTIONAL: Temporary view name for target",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pFilter",
            "Prompt": "OPTIONAL: Filter Unmapped Dimensions using format: Year\u00a6 2006 + 2007 & Scenario\u00a6 Actual + Budget etc",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pFilterParallel",
            "Prompt": "OPTIONAL: Parallelization Filter: Month:Q1+Q2+Q3+Q4 (Blank=run single threaded). Single dimension parallel slices. Will be added to filter single element at a time. Dimension must not be part of filter",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pParallelThreads",
            "Prompt": "Maximum number of threads to run when parallel processing is enabled ( if <2 will execute one thread but parallel filter is still applied )",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pEleMapping",
            "Prompt": "REQUIRED: Map source elements to target elements using format Dim1ToCopy\u00a6SourceElement->TargetElement & Dim2ToCopy\u00a6Source Element->TargetElement etc",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pMappingDelim",
            "Prompt": "OPTIONAL: Delimiter between source element and target element in pEleMapping  (default value if blank = '->')",
            "Type": "String",
            "Value": "->"
        },
        {
            "Name": "pDimDelim",
            "Prompt": "OPTIONAL: Delimiter for start of Dimension/Element set  (default value if blank = '&')",
            "Type": "String",
            "Value": "&"
        },
        {
            "Name": "pEleStartDelim",
            "Prompt": "OPTIONAL: Delimiter for start of element list  (default value if blank = '\u00a6')",
            "Type": "String",
            "Value": "\u00a6"
        },
        {
            "Name": "pEleDelim",
            "Prompt": "OPTIONAL: Delimiter between elements (default value if blank = '+')",
            "Type": "String",
            "Value": "+"
        },
        {
            "Name": "pFactor",
            "Prompt": "OPTIONAL: Multiply source value by factor (1 keeps the value as is). To modify existing values make the target element the same as the source with pZeroTarget = 0",
            "Type": "Numeric",
            "Value": "1"
        },
        {
            "Name": "pSuppressConsol",
            "Prompt": "OPTIONAL: Suppress Consolidated Cells (Skip = 1)",
            "Type": "Numeric",
            "Value": "1"
        },
        {
            "Name": "pSuppressConsolStrings",
            "Prompt": "OPTIONAL: Suppress Consolidated String Cells (Skip = 1)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pSuppressRules",
            "Prompt": "OPTIONAL: Suppress Rules (Skip = 1)",
            "Type": "Numeric",
            "Value": "1"
        },
        {
            "Name": "pSuppressZero",
            "Prompt": "OPTIONAL: Suppress Null Cells (Skip = 1)",
            "Type": "Numeric",
            "Value": "1"
        },
        {
            "Name": "pCumulate",
            "Prompt": "OPTIONAL: 1 = Add source to existing value in target (if zero out target = 0 False). 0 = Replace target with source.",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pZeroTarget",
            "Prompt": "OPTIONAL: Zero out Target Element PRIOR to Copy? (Boolean 1=True)",
            "Type": "Numeric",
            "Value": "1"
        },
        {
            "Name": "pZeroSource",
            "Prompt": "OPTIONAL: Zero out Source Element AFTER Copy? (Boolean 1=True)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pTemp",
            "Prompt": "OPTIONAL: Delete temporary view and Subset ( 0 = Retain View and Subsets 1 = Delete View and Subsets 2 = Delete View only )",
            "Type": "Numeric",
            "Value": "1"
        },
        {
            "Name": "pCubeLogging",
            "Prompt": "Required: Cube Logging (0 = No transaction logging 1 = Logging of transactions 2 = Ignore Cube Logging - No Action Taken parameter does not work with Parallel thread))",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pSandbox",
            "Prompt": "OPTIONAL: To use sandbox not base data enter the sandbox name (invalid name will result in process error)",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pFile",
            "Prompt": "OPTIONAL: Copy via file export and import. Reduces locks (0 = no 1= use file and delete it 2= use file and retain it)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pDelim",
            "Prompt": "OPTIONAL: For pFile > 0. AsciiOutput delimiter character (Default = '' exactly 3 digits = ASCII code)",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pQuote",
            "Prompt": "OPTIONAL: For pFile > 0. AsciiOutput quote character (Default = '\"\"' exactly 3 digits = ASCII code)",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pDecimalSeparator",
            "Prompt": "OPTIONAL: For pFile > 0. Decimal separator for conversion of NumberToStringEx and StringToNumberEx (default = '.' exactly 3 digits = ASCII code)",
            "Type": "String",
            "Value": "."
        },
        {
            "Name": "pThousandSeparator",
            "Prompt": "OPTIONAL: For pFile > 0. Thousand separator for conversion of NumberToStringEx and StringToNumberEx (default = '' exactly 3 digits = ASCII code)",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pSubN",
            "Prompt": "OPTIONAL: Create N level subset for all dims not mentioned in pFilter",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pThreadMode",
            "Prompt": "DO NOT USE: Internal parameter only please do not use",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pThreadControlFile",
            "Prompt": "DO NOT USE: Internal parameter only please do not use",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pMaxWaitSeconds",
            "Prompt": "OPTIONAL: Used with parallel to define wait time",
            "Type": "Numeric",
            "Value": "1800"
        }
    ],
    "PrologProcedure": "#Region CallThisProcess\r\n# A snippet of code provided as an example how to call this process should the developer be working on a system without access to an editor with auto-complete.\r\nIf( 1 = 0 );\r\n    ExecuteProcess( '}bedrock.cube.data.copy', 'pLogOutput', pLogOutput,\r\n      'pStrictErrorHandling', pStrictErrorHandling,\r\n    \t'pCube', '', 'pSrcView', '', 'pTgtView', '', 'pFilter', '',\r\n    \t'pFilterParallel', '', 'pParallelThreads', 0,\r\n    \t'pEleMapping', '', 'pMappingDelim', '->',\r\n    \t'pDimDelim', '&', 'pEleStartDelim', '\u00a6', 'pEleDelim', '+',\r\n    \t'pFactor', 1, 'pSuppressConsol', 1, 'pSuppressConsolStrings', 0, 'pSuppressRules', 1, 'pSuppressZero', 1, 'pCumulate', 0,\r\n    \t'pZeroTarget', 1, 'pZeroSource', 0,\r\n    \t'pTemp', 1, 'pCubeLogging', 0, 'pSandbox', '',\r\n    \t'pFile', 0, 'pDelim', ',', 'pQuote', '\"', 'pDecimalSeparator', '.', 'pThousandSeparator', ',', 'pSubN', 0\r\n    );\r\nEndIf;\r\n#EndRegion CallThisProcess\r\n\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n#################################################################################################\r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock Ver 4.0~~##\r\n#################################################################################################\r\n\r\n#Region @DOC\r\n# Description:\r\n# This TI is intended to copy data from one element of a dimension to another in the same cube.\r\n\r\n# Use case: Mainly used in production environments.\r\n# 1/ Typically, this would be used to archive a Budget or Forecast element of a version dimension.\r\n# 2/ Could also be used to prepopulate a version from a prior year.\r\n\r\n# Note:\r\n# Naturally, a valid cube name (pCube) is required. otherwise the process will abort.\r\n# Element mapping (pEleMapping) is also required, otherwise the process will abort.\r\n# A filter parameter (pFilter) can also be used to filter dimensions that have not been mapped.\r\n# Source (pSrcView) & target (pTgtView) views will be assigned temporary names if left blank.\r\n# All other parameters may be left as is but be sure to use them appropriately when specifying pEleMapping & pFilter parameters.\r\n# - Since this TI has a view as a data source, it requires the implicit variables NValue, SValue and Value_is_String.\r\n# - To edit this TI in Architect a tmp cube with minimum 24 dims is needed as the preview data source or set the data\r\n#   source to ASCII and manually edit the TI in notepad after saving to add back the required implicit view variables.\r\n# - If using the pFilterParallel parameter the **single dimension** used as the \"parallelization slicer\" cannot appear in\r\n#   the pFilter and pEleMapping parameters.\r\n# - When using parallelization via the *RunProcess* function the elements listed in pFilterParallel will be split one_at_a_time\r\n#   and passed to a recursive call of the process being added to pFilter.\r\n#EndRegion @DOC\r\n\r\nIf( pThreadControlFile @<> '' );\r\n    LogOutput( 'INFO', 'Executed as subTI with Thread Control File: ' | pThreadControlFile );\r\nEndIf;\r\n\r\n##Global Variables\r\nStringGlobalVariable('sProcessReturnCode');\r\nNumericGlobalVariable('nProcessReturnCode');\r\nnProcessReturnCode = 0;\r\n# Target Filter Variable for shell processes\r\nStringGlobalVariable('sTargetFilter');\r\n\r\n### Constants ###\r\ncThisProcName   = GetProcessName();\r\ncUserName       = TM1User();\r\ncTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\r\ncRandomInt      = NumberToString( INT( RAND( ) * 1000 ));\r\ncTempSub        = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\r\ncMsgErrorLevel  = 'ERROR';\r\ncMsgErrorContent= 'Process:%cThisProcName% ErrorMsg:%sMessage%';\r\ncLogInfo        = 'Process:%cThisProcName% run with parameters pCube:%pCube%, pSrcView:%pSrcView%, pTgtView:%pTgtView%, pFilter:%pFilter%, pFilterParallel:%pFilterParallel%, pParallelThreads:%pParallelThreads%, pEleMapping:%pEleMapping%, pMappingDelim:%pMappingDelim%, pDimDelim:%pDimDelim%, pEleStartDelim:%pEleStartDelim%, pEleDelim:%pEleDelim%, pFactor:%pFactor%, pSuppressConsol:%pSuppressConsol%, pSuppressConsolStrings:%pSuppressConsolStrings%, pSuppressRules:%pSuppressRules%, pSuppressZero:%pSuppressZero%, pCumulate:%pCumulate%, pZeroTarget:%pZeroTarget%, pZeroSource:%pZeroSource%, pTemp:%pTemp%, pCubeLogging:%pCubeLogging%, pSandbox:%pSandbox%, pFile:%pFile%.';\r\ncDefaultView    = Expand( '%cThisProcName%_%cTimeStamp%_%cRandomInt%' );\r\n\r\n## LogOutput parameters\r\nIF( pLogoutput = 1 );\r\n    LogOutput('INFO', Expand( cLogInfo ) );\r\nENDIF;\r\n\r\n#Disable logic for pCubeLogic for prararrel thread\r\nIF (pParallelThreads > 0);\r\n  pCubeLogging = 2;\r\nEndif;\r\n\r\n# Variables\r\nnDataCount      = 0;\r\nnExistingSourceFlag = 0;\r\nnAttrCubeFlag   = 0;\r\ncSuffixSource   = 'S';\r\ncSuffixTarget   = 'T';\r\ncPrefixElementAttributes = '}ElementAttributes_';\r\ncDimCountMax    = 27;\r\nsDimCountMax    = NumberToString( cDimCountMax );\r\nnFactor = If( pFactor = 0, 1, pFactor );\r\ncLenASCIICode = 3;\r\n\r\n## check operating system\r\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\r\n  sOS = 'Windows';\r\n  sOSDelim = '\\';\r\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0 );\r\n  sOS = 'Linux';\r\n  sOSDelim = '/';\r\nElse;\r\n  sOS = 'Windows';\r\n  sOSDelim = '\\';\r\nEndIf;\r\n\r\n# Validate file delimiter & quote character\r\nIf( pDelim @= '' );\r\n    pDelim = ',';\r\nElse;\r\n    # If length of pDelim is exactly 3 chars and each of them is decimal digit, then the pDelim is entered as ASCII code\r\n    nValid = 0;\r\n    If ( LONG(pDelim) = cLenASCIICode );\r\n      nChar = 1;\r\n      While ( nChar <= cLenASCIICode );\r\n        If( CODE( pDelim, nChar ) >= CODE( '0', 1 ) & CODE( pDelim, nChar ) <= CODE( '9', 1 ) );\r\n          nValid = 1;\r\n        Else;\r\n          nValid = 0;\r\n          Break;\r\n        EndIf;\r\n        nChar = nChar + 1;\r\n      End;\r\n    EndIf;\r\n    If ( nValid<>0 );\r\n      pDelim=CHAR(StringToNumber( pDelim ));\r\n    Else;\r\n      pDelim = SubSt( Trim( pDelim ), 1, 1 );\r\n    EndIf;\r\nEndIf;\r\n\r\nIf( pQuote @= '' );\r\n    ## Use no quote character\r\nElse;\r\n    # If length of pQuote is exactly 3 chars and each of them is decimal digit, then the pQuote is entered as ASCII code\r\n    nValid = 0;\r\n    If ( LONG(pQuote) = cLenASCIICode );\r\n      nChar = 1;\r\n      While ( nChar <= cLenASCIICode );\r\n        If( CODE( pQuote, nChar ) >= CODE( '0', 1 ) & CODE( pQuote, nChar ) <= CODE( '9', 1 ) );\r\n          nValid = 1;\r\n        Else;\r\n          nValid = 0;\r\n          Break;\r\n        EndIf;\r\n        nChar = nChar + 1;\r\n      End;\r\n    EndIf;\r\n    If ( nValid<>0 );\r\n      pQuote=CHAR(StringToNumber( pQuote ));\r\n    Else;\r\n      pQuote = SubSt( Trim( pQuote ), 1, 1 );\r\n    EndIf;\r\nEndIf;\r\n\r\n## File location for indirect data copy\r\ncDir    = '.' | sOSDelim;\r\ncFileName = LOWER(pCube) | cTimeStamp | cRandomInt | '.csv';\r\ncFile   = cDir | cFileName;\r\ncTitleRows = 1;\r\ncDelimiter = pDelim;\r\ncQuote = pQuote;\r\n\r\n# nMappedDimX is a binary switch used to keep track of which dimensions have been mapped from the source to the target\r\nnMappedDim1 = 0;\r\nnMappedDim2 = 0;\r\nnMappedDim3 = 0;\r\nnMappedDim4 = 0;\r\nnMappedDim5 = 0;\r\nnMappedDim6 = 0;\r\nnMappedDim7 = 0;\r\nnMappedDim8 = 0;\r\nnMappedDim9 = 0;\r\nnMappedDim10 = 0;\r\nnMappedDim11 = 0;\r\nnMappedDim12 = 0;\r\nnMappedDim13 = 0;\r\nnMappedDim14 = 0;\r\nnMappedDim15 = 0;\r\nnMappedDim16 = 0;\r\nnMappedDim17 = 0;\r\nnMappedDim18 = 0;\r\nnMappedDim19 = 0;\r\nnMappedDim20 = 0;\r\nnMappedDim21 = 0;\r\nnMappedDim22 = 0;\r\nnMappedDim23 = 0;\r\nnMappedDim24 = 0;\r\nnMappedDim25 = 0;\r\nnMappedDim26 = 0;\r\nnMappedDim27 = 0;\r\n\r\n### Determine dimensions in target cube - we need to know this to test the cell type before loading ###\r\nsDim1 = TabDim( pCube, 1 );\r\nsDim2 = TabDim( pCube, 2 );\r\nsDim3 = TabDim( pCube, 3 );\r\nsDim4 = TabDim( pCube, 4 );\r\nsDim5 = TabDim( pCube, 5 );\r\nsDim6 = TabDim( pCube, 6 );\r\nsDim7 = TabDim( pCube, 7 );\r\nsDim8 = TabDim( pCube, 8 );\r\nsDim9 = TabDim( pCube, 9 );\r\nsDim10 = TabDim( pCube, 10 );\r\nsDim11 = TabDim( pCube, 11 );\r\nsDim12 = TabDim( pCube, 12 );\r\nsDim13 = TabDim( pCube, 13 );\r\nsDim14 = TabDim( pCube, 14 );\r\nsDim15 = TabDim( pCube, 15 );\r\nsDim16 = TabDim( pCube, 16 );\r\nsDim17 = TabDim( pCube, 17 );\r\nsDim18 = TabDim( pCube, 18 );\r\nsDim19 = TabDim( pCube, 19 );\r\nsDim20 = TabDim( pCube, 20 );\r\nsDim21 = TabDim( pCube, 21 );\r\nsDim22 = TabDim( pCube, 22 );\r\nsDim23 = TabDim( pCube, 23 );\r\nsDim24 = TabDim( pCube, 24 );\r\nsDim25 = TabDim( pCube, 25 );\r\nsDim26 = TabDim( pCube, 26 );\r\nsDim27 = TabDim( pCube, 27 );\r\n\r\n###########################\r\n### Validate Parameters ###\r\n###########################\r\nnErrors = 0;\r\n\r\n## Default filter delimiters\r\nIf( pDimDelim     @= '' );\r\n    pDimDelim     = '&';\r\nEndIf;\r\n\r\nIf( pEleStartDelim@= '' );\r\n    pEleStartDelim= '\u00a6';\r\nEndIf;\r\n\r\nIf( pEleDelim     @= '' );\r\n    pEleDelim     = '+';\r\nEndIf;\r\n\r\nIf( pMappingDelim     @= '' );\r\n    pMappingDelim     = '->';\r\nEndIf;\r\n\r\nIf( pDecimalSeparator @= '' );\r\n \tpDecimalSeparator = '.';\r\nEndIf;\r\nIf ( LONG(pDecimalSeparator) = cLenASCIICode );\r\n  nValid = 0;\r\n  nChar = 1;\r\n  While ( nChar <= cLenASCIICode );\r\n    If( CODE( pDecimalSeparator, nChar ) >= CODE( '0', 1 ) & CODE( pDecimalSeparator, nChar ) <= CODE( '9', 1 ) );\r\n      nValid = 1;\r\n    Else;\r\n      nValid = 0;\r\n      Break;\r\n    EndIf;\r\n    nChar = nChar + 1;\r\n  End;\r\n  If ( nValid<>0 );\r\n    pDecimalSeparator = CHAR(StringToNumber( pDecimalSeparator ));\r\n  Else;\r\n    pDecimalSeparator = SubSt( Trim( pDecimalSeparator ), 1, 1 );\r\n  EndIf;\r\nEndIf;\r\nsDecimalSeparator = pDecimalSeparator;\r\n\r\nIf( pThousandSeparator @= '' );\r\n \tpThousandSeparator = ',';\r\nEndIf;\r\nIf ( LONG(pThousandSeparator) = cLenASCIICode );\r\n  nValid = 0;\r\n  nChar = 1;\r\n  While ( nChar <= cLenASCIICode );\r\n    If( CODE( pThousandSeparator, nChar ) >= CODE( '0', 1 ) & CODE( pThousandSeparator, nChar ) <= CODE( '9', 1 ) );\r\n      nValid = 1;\r\n    Else;\r\n      nValid = 0;\r\n      Break;\r\n    EndIf;\r\n    nChar = nChar + 1;\r\n  End;\r\n  If ( nValid<>0 );\r\n    pThousandSeparator = CHAR(StringToNumber( pThousandSeparator ));\r\n  Else;\r\n    pThousandSeparator = SubSt( Trim( pThousandSeparator ), 1, 1 );\r\n  EndIf;\r\nEndIf;\r\nsThousandSeparator = pThousandSeparator;\r\n\r\n# Validate cube\r\nIf( Trim( pCube ) @= '' );\r\n    nErrors     = 1;\r\n    sMessage    = 'No cube specified.';\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nElseIf( CubeExists( pCube ) = 0 );\r\n    nErrors     = nErrors + 1;\r\n    sMessage    = Expand( 'Invalid source cube specified: %pCube%.');\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\n### Determine number of dims in target cube ###\r\nnCount          = 1;\r\nWhile( TabDim( pCube, nCount ) @<> '' );\r\n    sDimension  = TabDim( pCube, nCount );\r\n    nCount      = nCount + 1;\r\nEnd;\r\nnDimensionCount = nCount - 1;\r\n\r\n## If dimension count exceeds the current maximum then terminate process\r\nIf( nDimensionCount > cDimCountMax );\r\n    nErrors     = nErrors + 1;\r\n    sMessage    = 'Cube has too many dimensions: %pCube%. Max %sDimCountMax% dims catered for, TI must be altered to accommodate.';\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\n## Validate the View parameter\r\nIf( TRIM(pSrcView) @<> '' & TRIM(pSrcView) @= TRIM(pTgtView) );\r\n    nErrors     = nErrors + 1;\r\n    sMessage    = Expand( 'Source and Target Views can not be the same: %pSrcView%.' ) ;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\n## Validate the View parameter\r\nIf( TRIM( pSrcView) @= '' );\r\n  cViewSource   = Expand( '%cDefaultView%_%cSuffixSource%' ) ;\r\nElse ;\r\n  cViewSource   = pSrcView ;\r\n  nExistingSourceFlag = 1;\r\nEndIf;\r\n\r\n## Validate the View parameter\r\nIf( TRIM( pTgtView ) @= '' );\r\n  cViewTarget   = Expand( '%cDefaultView%_%cSuffixTarget%' ) ;\r\nElse ;\r\n  cViewTarget   = pTgtView ;\r\nEndIf;\r\n\r\n# Validate parallelization filter\r\nIf( Scan( pEleStartDelim, pFilterParallel ) > 0 );\r\n    sDimParallel = SubSt( pFilterParallel, 1, Scan( pEleStartDelim, pFilterParallel ) - 1 );\r\n    If( Scan( Lower(sDimParallel) | pEleStartDelim, Lower(pFilter) ) > 0 );\r\n        sMessage = 'Parallelization dimension %sDimParallel% cannot exist in filter.';\r\n        nErrors = nErrors + 1;\r\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n    EndIf;\r\n    If( Scan( Lower(sDimParallel) | pEleStartDelim, Lower(pEleMapping) ) > 0 );\r\n        sMessage = 'Parallelization dimension %sDimParallel% cannot exist in element mapping.';\r\n        nErrors = nErrors + 1;\r\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n    EndIf;\r\nEndIf;\r\n\r\n# Validate Max Threads\r\nIf( pParallelThreads > 0 );\r\n  nMaxThreads = pParallelThreads;\r\nElse;\r\n  nMaxThreads = 1;\r\nEndIf;\r\n\r\n# Validate Mapping parameter\r\nIf( pDimDelim @= pEleStartDelim % pDimDelim @= pEleDelim % pEleStartDelim @= pEleDelim );\r\n    sMessage = 'The delimiters cannot me the same.';\r\n    nErrors = nErrors + 1;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\n# Validate Mapping parameter\r\nIf( TRIM( pEleMapping ) @<> '' & TRIM( pMappingDelim) @= '');\r\n    nErrors = nErrors + 1;\r\n    sMessage = 'Mapping Delimiter & Element Mapping can not both be empty.';\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndif;\r\n\r\n# Validate Sandbox\r\nIf( TRIM( pSandbox ) @<> '' );\r\n    If( ServerSandboxExists( pSandbox ) = 0 );\r\n        SetUseActiveSandboxProperty( 0 );\r\n        nErrors = nErrors + 1;\r\n        sMessage = Expand('Sandbox %pSandbox% is invalid for the current user.');\r\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n    Else;\r\n        ServerActiveSandboxSet( pSandbox );\r\n        SetUseActiveSandboxProperty( 1 );\r\n    EndIf;\r\nElse;\r\n    SetUseActiveSandboxProperty( 0 );\r\nEndIf;\r\n\r\n### Check for errors before continuing\r\nIf( nErrors <> 0 );\r\n  If( pStrictErrorHandling = 1 );\r\n      ProcessQuit;\r\n  Else;\r\n      ProcessBreak;\r\n  EndIf;\r\nEndIf;\r\n\r\n########## pEleMapping ######################################################\r\n### Split ElementMapping parameter and create variables to be substituted ###\r\n################################################################################################# #############\r\nsElementMapping     = TRIM( pEleMapping );\r\nsMappingDelimiter   = TRIM( pMappingDelim );\r\nsElementStartDelim  = TRIM( pEleStartDelim );\r\nsDelimDim           = TRIM( pDimDelim );\r\nsDecimalSeparator   = TRIM(pDecimalSeparator);\r\nsThousandSeparator  = TRIM(pThousandSeparator);\r\nsFilter             = TRIM( pFilter);\r\nsTargetFilter       = '';\r\nnSuppressConsol     = pSuppressConsol;\r\nnChar               = 1;\r\nnCharCount          = LONG( sElementMapping );\r\n\r\n# If there's no element mapping then the process can be used to multiply existing value by a factor\r\nIf( nCharCount > 0 );\r\n\r\n  sWord = '';\r\n  sLastDelim = '';\r\n\r\n  # Add a trailing element delimiter so that the last element is picked up\r\n  If( nCharCount > 0 );\r\n    sElementMapping = sElementMapping | sMappingDelimiter ;\r\n    nCharCount      = nCharCount + LONG(sMappingDelimiter );\r\n  EndIf;\r\n\r\n  WHILE (nChar <= nCharCount);\r\n    sChar = SUBST( sElementMapping, nChar, 1);\r\n\r\n    # Used for delimiters, required for multiple character delimiters\r\n    sDelim = '';\r\n    nAddExtra = 0;\r\n\r\n    # Ignore spaces\r\n    IF (TRIM(sChar) @<> '' );\r\n\r\n      ### Dimension Name ###\r\n\r\n      # If the delimiter is more than 1 character peek ahead the same amount\r\n      # Ignore the first character\r\n      sDelim = sChar;\r\n      nCount = LONG(sElementStartDelim) - 1;\r\n      If( nCount > 0 & nChar + nCount <= nCharCount );\r\n        # Add the extra characters\r\n        sDelim = sDelim | SUBST( sElementMapping, nChar + 1, nCount);\r\n        # Move to the end of the delimter\r\n        nAddExtra = nCount;\r\n      EndIf;\r\n\r\n      If( sDelim @= sElementStartDelim );\r\n\r\n        sChar = sDelim;\r\n\r\n        If( sLastDelim @<> '' & sLastDelim @<> sDelimDim );\r\n            sMessage = Expand ( 'The name of a dimension must follow a dimension delimiter %sDelimDim%' );\r\n            nErrors = nErrors + 1;\r\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n            #ProcessError();\r\n        EndIf;\r\n\r\n        sDimension = sWord;\r\n\r\n        If( DimensionExists( sDimension ) = 0 );\r\n            # The dimension does not exist in the model. Cancel process\r\n            sMessage = Expand( 'Dimension: %sDimension% does not exist');\r\n            nErrors = nErrors + 1;\r\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n            #ProcessError();\r\n        EndIf;\r\n\r\n        # Check that the dimension is in the cube\r\n         i = 1;\r\n         iMax = 30;\r\n         sDimInCube = 'No';\r\n         While( i <= iMax );\r\n           sDimensionOfCube = TabDim( pCube, i );\r\n           If(sDimension @= sDimensionOfCube);\r\n             sDimInCube = 'Yes';\r\n             # record where the loop stops\r\n             nIndex = i;\r\n             i = 100;\r\n             Else;\r\n             i = i + 1;\r\n           EndIf;\r\n        End;\r\n\r\n        If( sDimInCube @<> 'Yes' );\r\n            # The dimension does not exist in the cube. Cancel process\r\n            sMessage = Expand( 'Dimension %sDimension% does not exist in this cube');\r\n            nErrors = nErrors + 1;\r\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n            #ProcessError();\r\n        EndIf;\r\n\r\n        ### Dimension exists so add it to the filters\r\n        IF(LONG(sFilter) > 0 & sLastDelim @= '');\r\n          sTargetFilter = sFilter | sDelimDim | sDimension | sElementStartDelim;\r\n          sFilter = sFilter | sDelimDim | sDimension | sElementStartDelim;\r\n          ElseiF(LONG(sFilter) > 0 & sLastDelim@<>'');\r\n          sFilter = sFilter | sDelimDim | sDimension | sElementStartDelim;\r\n          sTargetFilter = sTargetFilter | sDelimDim | sDimension | sElementStartDelim;\r\n          Else;\r\n          sFilter = sDimension | sElementStartDelim;\r\n          sTargetFilter = sDimension | sElementStartDelim;\r\n        EndIf;\r\n\r\n        #Reset the source and target elements\r\n        sSource = '';\r\n        sTarget = '';\r\n\r\n        # The variable nElementCount is used to keep track of how many elements there are per dimension\r\n        # the first element is the source\r\n        # the second element is the target\r\n        # There shouldn't be any more than 2 elements per dimension\r\n\r\n        # A new dimension has been found so reset the element count so\r\n        # the code can tell how many elements have been specified for each dimension\r\n        # There should just be 2\r\n\r\n        nElementCount = 1;\r\n        sLastDelim = sChar;\r\n\r\n        # Clear the word\r\n        sWord = '';\r\n\r\n      Else;\r\n\r\n        # Reset extra chars\r\n        nAddExtra = 0;\r\n\r\n        ### Check both dim delimiter and element delimiter ###\r\n        nIsDelimiter = 0;\r\n\r\n        # Check dim delim\r\n        # If the delimiter is more than 1 character peek ahead the same amount\r\n        # Ignore the first character\r\n        sDelim = sChar;\r\n        nCount = LONG(sDelimDim) - 1;\r\n        If( nCount > 0 & nChar + nCount <= nCharCount );\r\n          # Add the extra characters\r\n          sDelim = sDelim | SUBST( sElementMapping, nChar + 1, nCount);\r\n          # Move to the end of the delimter\r\n          nAddExtra = nCount;\r\n        EndIf;\r\n\r\n        If( sDelim @= sDelimDim );\r\n          nIsDelimiter = 1;\r\n          sChar = sDelim;\r\n        Else;\r\n          # Reset extra chars\r\n          nAddExtra = 0;\r\n\r\n          ## Check element delimiter\r\n\r\n          # If the delimiter is more than 1 character peek ahead the same amount\r\n          # Ignore the first character\r\n          sDelim = sChar;\r\n          nCount = LONG(sMappingDelimiter) - 1;\r\n          If( nCount > 0 & nChar + nCount <= nCharCount );\r\n            # Add the extra characters\r\n            sDelim = sDelim | SUBST( sElementMapping, nChar + 1, nCount);\r\n            # Move to the end of the delimter\r\n            nAddExtra = nCount;\r\n          EndIf;\r\n\r\n          If( sDelim @= sMappingDelimiter  );\r\n            nIsDelimiter = 1;\r\n            sChar = sDelim;\r\n          Else;\r\n            # Reset extra chars\r\n            nAddExtra = 0;\r\n          EndIf;\r\n\r\n        EndIf;\r\n\r\n        If ( nIsDelimiter = 1 );\r\n\r\n          If( sLastDelim @= '' % sLastDelim @= sDelimDim );\r\n            sMessage = 'An element start delimiter must follow a dimension name: ' |  sChar | ' (' | NumberToString(nChar) | ')';\r\n            nErrors = nErrors + 1;\r\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n            #ProcessError();\r\n          EndIf;\r\n\r\n          # an element has been found!\r\n          sElement = sWord;\r\n\r\n          If( DIMIX( sDimension, sElement ) = 0 );\r\n            # The element does not exist in the dimension. Cancel process\r\n            sMessage = Expand( 'Element: %sElement% does not exist in dimension %sDimension%' );\r\n            nErrors = nErrors + 1;\r\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n          EndIf;\r\n\r\n          # Allow consolidations only if pSuppressConsol is not set to 1\r\n          # Consolidations may be made allowable\r\n          # so that you can copy strings between c levels\r\n          # or copy from a consolidated source element to an n level target element\r\n\r\n          ### Check for errors before continuing\r\n          If( nErrors <> 0 );\r\n              If( pStrictErrorHandling = 1 );\r\n                  ProcessQuit;\r\n              Else;\r\n                  ProcessBreak;\r\n              EndIf;\r\n          EndIf;\r\n\r\n          If ( DTYPE( sDimension, sElement) @= 'C' );\r\n              IF( nElementCount = 1 );\r\n                If( pSuppressConsol <> 1 );\r\n                  nSuppressConsol = 0;\r\n                EndIf;\r\n                pSubN = 1;\r\n              Else;\r\n                sMessage = Expand( 'Target element: %sElement% for dimension %sDimension% is consolidated' );\r\n                nErrors = nErrors + 1;\r\n                LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n                #ProcessBreak;\r\n              Endif;\r\n          Endif;\r\n\r\n          # Add the element to the source or target depending on whether it's the first or the second element\r\n          # Get principal name\r\n          # in case source element and this element are using different aliases\r\n\r\n          sElement = DimensionElementPrincipalName(sDimension,sElement);\r\n\r\n          # first element\r\n          IF(nElementCount = 1);\r\n\r\n            sSource = sElement;\r\n            sFilter = sFilter | sElement;\r\n\r\n          # second element\r\n          ElseIf(nElementCount = 2);\r\n\r\n            sTarget = sElement;\r\n            sTargetFilter = sTargetFilter | sElement;\r\n\r\n          Else;\r\n\r\n            sMessage = Expand( 'There should only be 2 elements per dimension: %sDimension% , a source and a target');\r\n            nErrors = nErrors + 1;\r\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n            #ProcessError();\r\n\r\n          EndIf;\r\n\r\n          If(nIndex = 1);\r\n            nMappedDim1 = 1;\r\n            sSourceDim1 = sSource;\r\n            sTargetDim1 = sTarget;\r\n          ElseIf(nIndex = 2);\r\n            nMappedDim2 = 1;\r\n            sSourceDim2 = sSource;\r\n            sTargetDim2 = sTarget;\r\n          ElseIf(nIndex = 3);\r\n            nMappedDim3 = 1;\r\n            sSourceDim3 = sSource;\r\n            sTargetDim3 = sTarget;\r\n          ElseIf(nIndex = 4);\r\n            nMappedDim4 = 1;\r\n            sSourceDim4 = sSource;\r\n            sTargetDim4 = sTarget;\r\n          ElseIf(nIndex = 5);\r\n            nMappedDim5 = 1;\r\n            sSourceDim5 = sSource;\r\n            sTargetDim5 = sTarget;\r\n          ElseIf(nIndex = 6);\r\n            nMappedDim6 = 1;\r\n            sSourceDim6 = sSource;\r\n            sTargetDim6 = sTarget;\r\n          ElseIf(nIndex = 7);\r\n            nMappedDim7 = 1;\r\n            sSourceDim7 = sSource;\r\n            sTargetDim7 = sTarget;\r\n          ElseIf(nIndex = 8);\r\n            nMappedDim8 = 1;\r\n            sSourceDim8 = sSource;\r\n            sTargetDim8 = sTarget;\r\n          ElseIf(nIndex = 9);\r\n            nMappedDim9 = 1;\r\n            sSourceDim9 = sSource;\r\n            sTargetDim9 = sTarget;\r\n          ElseIf(nIndex = 10);\r\n            nMappedDim10 = 1;\r\n            sSourceDim10 = sSource;\r\n            sTargetDim10 = sTarget;\r\n          ElseIf(nIndex = 11);\r\n            nMappedDim11 = 1;\r\n            sSourceDim11 = sSource;\r\n            sTargetDim11 = sTarget;\r\n          ElseIf(nIndex = 12);\r\n            nMappedDim12 = 1;\r\n            sSourceDim12 = sSource;\r\n            sTargetDim12 = sTarget;\r\n          ElseIf(nIndex = 13);\r\n            nMappedDim13 = 1;\r\n            sSourceDim13 = sSource;\r\n            sTargetDim13 = sTarget;\r\n          ElseIf(nIndex = 14);\r\n            nMappedDim14 = 1;\r\n            sSourceDim14 = sSource;\r\n            sTargetDim14 = sTarget;\r\n          ElseIf(nIndex = 15);\r\n            nMappedDim15 = 1;\r\n            sSourceDim15 = sSource;\r\n            sTargetDim15 = sTarget;\r\n          ElseIf(nIndex = 16);\r\n            nMappedDim16 = 1;\r\n            sSourceDim16 = sSource;\r\n            sTargetDim16 = sTarget;\r\n          ElseIf(nIndex = 17);\r\n            nMappedDim17 = 1;\r\n            sSourceDim17 = sSource;\r\n            sTargetDim17 = sTarget;\r\n          ElseIf(nIndex = 18);\r\n            nMappedDim18 = 1;\r\n            sSourceDim18 = sSource;\r\n            sTargetDim18 = sTarget;\r\n          ElseIf(nIndex = 19);\r\n            nMappedDim19 = 1;\r\n            sSourceDim19 = sSource;\r\n            sTargetDim19 = sTarget;\r\n          ElseIf(nIndex = 20);\r\n            nMappedDim20 = 1;\r\n            sSourceDim20 = sSource;\r\n            sTargetDim20 = sTarget;\r\n          ElseIf(nIndex = 21);\r\n            nMappedDim21 = 1;\r\n            sSourceDim21 = sSource;\r\n            sTargetDim21 = sTarget;\r\n          ElseIf(nIndex = 22);\r\n            nMappedDim22 = 1;\r\n            sSourceDim22 = sSource;\r\n            sTargetDim22 = sTarget;\r\n          ElseIf(nIndex = 23);\r\n            nMappedDim23 = 1;\r\n            sSourceDim23 = sSource;\r\n            sTargetDim23 = sTarget;\r\n          ElseIf(nIndex = 24);\r\n            nMappedDim24 = 1;\r\n            sSourceDim24 = sSource;\r\n            sTargetDim24 = sTarget;\r\n          ElseIf(nIndex = 25);\r\n            nMappedDim25 = 1;\r\n            sSourceDim25 = sSource;\r\n            sTargetDim25 = sTarget;\r\n          ElseIf(nIndex = 26);\r\n            nMappedDim26 = 1;\r\n            sSourceDim26 = sSource;\r\n            sTargetDim26 = sTarget;\r\n          ElseIf(nIndex = 27);\r\n            nMappedDim27 = 1;\r\n            sSourceDim27 = sSource;\r\n            sTargetDim27 = sTarget;\r\n          EndIf;\r\n\r\n          sLastDelim = sChar;\r\n\r\n          # Clear the word\r\n          sWord = '';\r\n\r\n          nElementCount = nElementCount + 1;\r\n\r\n        Else;\r\n          sWord = sWord | sChar;\r\n        EndIf;\r\n\r\n      EndIf;\r\n\r\n    EndIf;\r\n\r\n    nChar = nChar + nAddExtra + 1;\r\n\r\n  END;\r\nENDIF;\r\n\r\n\r\n### Check that there if a dimension is used, there is a source element and a target element\r\ncSourceVariableStem = 'sSourceDim';\r\ncTargetVariableStem = 'sTargetDim';\r\ncMappedDimVariableStem = 'nMappedDim';\r\n\r\nnCounter = 1;\r\nWHILE(nCounter <= nDimensionCount);\r\n\r\n  sMappedDimVariable = 'nMappedDim ' | NumberToString(nCounter);\r\n  sDimensionUsedPadded = Expand('%' | sMappedDimVariable | '%');\r\n\r\n  nMappedDim = StringToNumber(Trim(sDimensionUsedPadded));\r\n  If(nMappedDim = 1);\r\n    sDim = TabDim( pCube, nCounter );\r\n    sSourceVariable = cSourceVariableStem | NumberToString(nCounter);\r\n    sSourcePadded = Expand('%' | sSourceVariable | '%');\r\n    sSource = Trim(sSourcePadded);\r\n\r\n    sTargetVariable = cTargetVariableStem | NumberToString(nCounter);\r\n    sTargetPadded = Expand('%' | sTargetVariable | '%');\r\n    sTarget = Trim(sTargetPadded);\r\n\r\n    If(sSource @='' % sTarget @='');\r\n      sMessage = 'Source and/or target element is blank for dimension ' | sDim;\r\n      nErrors = nErrors + 1;\r\n      LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n      #ProcessError();\r\n    EndIf;\r\n\r\n  EndIf;\r\n\r\nnCounter = nCounter + 1;\r\n\r\nEND;\r\n\r\n### Check for errors before continuing\r\nIf( nErrors <> 0 );\r\n  DataSourceType = 'NULL';\r\n  If( pStrictErrorHandling = 1 );\r\n      ProcessQuit;\r\n  Else;\r\n      ProcessBreak;\r\n  EndIf;\r\nEndIf;\r\n\r\n# Branch depending on whether to do recursive calls to self on independent threads or run all in this thread\r\nIf( Scan( pEleStartDelim, pFilterParallel ) > 0 );\r\n  sDimParallel = SubSt( pFilterParallel, 1, Scan( pEleStartDelim, pFilterParallel ) - 1 );\r\n  sElementList = SubSt( pFilterParallel, Scan( pEleStartDelim, pFilterParallel ) + Long( pEleStartDelim ), Long( pFilterParallel ) );\r\n  If( SubSt( sElementList, Long( sElementList ), 1 ) @<> pEleDelim );\r\n      sElementList = sElementList | pEleDelim;\r\n  EndIf;\r\n  ## Counting elements in element list\r\n  sElementListCount = sElementList;\r\n  nElements = 0;\r\n  While( Scan( pEleDelim, sElementListCount ) > 0 );\r\n    nElements = nElements + 1;\r\n    sElementListCount = SubSt( sElementListCount, Scan( pEleDelim, sElementListCount ) + Long( pEleDelim ), Long( sElementListCount ) );\r\n  End;\r\n  IF( Mod( nElements, nMaxThreads ) = 0 );\r\n    nElemsPerThread = INT( nElements / nMaxThreads );\r\n  ELSE;\r\n    nElemsPerThread = INT( nElements / nMaxThreads ) + 1;\r\n  ENDIF;\r\n  nThreadElCounter = 0;\r\n  While( Scan( pEleDelim, sElementList ) > 0 );\r\n    sSlicerEle = SubSt( sElementList, 1, Scan( pEleDelim, sElementList ) - 1 );\r\n    sElementList = SubSt( sElementList, Scan( pEleDelim, sElementList ) + Long( pEleDelim ), Long( sElementList ) );\r\n    # Do recursive process call with new RunProcess function\r\n    nThreadElCounter = nThreadElCounter + 1;\r\n    sDimDelim = If(pFilter @= '', '', pDimDelim );\r\n    IF( nThreadElCounter = 1 );\r\n      sFilter = Expand('%pFilter%%sDimDelim%%sDimParallel%%pEleStartDelim%%sSlicerEle%');\r\n    ELSE;\r\n      sFilter = Expand('%sFilter%%pEleDelim%%sSlicerEle%');\r\n    ENDIF;\r\n    IF( nThreadElCounter >= nElemsPerThread );\r\n            nThreadID = INT( RAND( ) * 10000 + 1) + Numbr(cTimeStamp);\r\n      sThreadControlFile = GetProcessName() | '_ThreadControlFile_' | cRandomInt | '_' | NumberToString(nThreadID) | '_' | cTimeStamp;\r\n      AsciiOutput( cDir | sThreadControlFile | '.txt', '' );\r\n      LogOutput( 'INFO', 'Executing subTI with Thread ID: ' | NumberToString(nThreadID) );\r\n      RunProcess( cThisProcName, 'pLogoutput', pLogoutput,\r\n      \t'pCube', pCube, 'pSrcView', pSrcView, 'pTgtView', pTgtView,\r\n      \t'pFilter', sFilter, 'pFilterParallel', '', 'pEleMapping', pEleMapping, 'pMappingDelim', pMappingDelim,\r\n      \t'pDimDelim', pDimDelim, 'pEleStartDelim', pEleStartDelim, 'pEleDelim', pEleDelim,\r\n      \t'pFactor', pFactor, 'pSuppressConsol', pSuppressConsol, 'pSuppressConsolStrings', pSuppressConsolStrings, 'pSuppressRules', pSuppressRules, 'pSuppressZero', pSuppressZero, 'pCumulate', pCumulate,\r\n      \t'pZeroTarget', pZeroTarget, 'pZeroSource', pZeroSource, 'pTemp', pTemp, 'pCubeLogging', pCubeLogging, 'pSandbox', pSandbox, 'pFile', pFile, 'pDecimalSeparator', pDecimalSeparator, 'pThousandSeparator', pThousandSeparator,\r\n        'pThreadMode', 1, 'pThreadControlFile', sThreadControlFile\r\n      );\r\n  \t  nThreadElCounter = 0;\r\n  \t  sFilter = '';\r\n  \t  nThreadID = INT( RAND( ) * 10000 ) + 1;\r\n        sThreadControlFile = GetProcessName() | '_ThreadControlFile_' | cRandomInt | '_' | NumberToString(nThreadID);\r\n        AsciiOutput( cDir | sThreadControlFile | '.txt', '' );\r\n        LogOutput( 'INFO', 'Executing subTI with Thread ID: ' | NumberToString(nThreadID) );\r\n  \t ENDIF;\r\n  End;\r\n  ## Process last elements - only when filter is not empty (there are still elements)\r\n  IF( sFilter @<> '' );\r\n    RunProcess( cThisProcName, 'pLogoutput', pLogoutput,\r\n    \t'pCube', pCube, 'pSrcView', pSrcView, 'pTgtView', pTgtView,\r\n    \t'pFilter', sFilter, 'pFilterParallel', '', 'pEleMapping', pEleMapping, 'pMappingDelim', pMappingDelim,\r\n    \t'pDimDelim', pDimDelim, 'pEleStartDelim', pEleStartDelim, 'pEleDelim', pEleDelim,\r\n    \t'pFactor', pFactor, 'pSuppressConsol', pSuppressConsol, 'pSuppressConsolStrings', pSuppressConsolStrings, 'pSuppressRules', pSuppressRules, 'pSuppressZero', pSuppressZero, 'pCumulate', pCumulate,\r\n    \t'pZeroTarget', pZeroTarget, 'pZeroSource', pZeroSource, 'pTemp', pTemp, 'pCubeLogging', pCubeLogging, 'pSandbox', pSandbox, 'pFile', pFile, 'pDecimalSeparator', pDecimalSeparator, 'pThousandSeparator', pThousandSeparator,\r\n      'pThreadMode', 1, 'pThreadControlFile', sThreadControlFile\r\n    );\r\n  ENDIF;\r\n  DataSourceType = 'NULL';\r\nElse;\r\n  ### Create View of target to zero out\r\n  ### Check that there's something in sTargetFilter so the cube doesn't accidentally get wiped out\r\n\r\n  If(pZeroTarget = 1 & LONG(sTargetFilter)> 0);\r\n\r\n    sProc = '}bedrock.cube.data.clear';\r\n    nRet = ExecuteProcess( sProc,\r\n    'pLogOutput', pLogOutput,\r\n    'pStrictErrorHandling', pStrictErrorHandling,\r\n    'pCube', pCube,\r\n    'pView', cViewTarget,\r\n    'pFilter', sTargetFilter,\r\n    'pDimDelim', pDimDelim,\r\n    'pEleStartDelim', pEleStartDelim,\r\n    'pEleDelim', pEleDelim,\r\n    'pCubeLogging', pCubeLogging,\r\n    'pTemp', pTemp,\r\n    'pSandbox', pSandbox\r\n    );\r\n\r\n    IF(nRet <> 0);\r\n        sMessage = 'Error clearing the target view.';\r\n        nErrors = nErrors + 1;\r\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n        If( pStrictErrorHandling = 1 );\r\n            ProcessQuit;\r\n        Else;\r\n            ProcessBreak;\r\n        EndIf;\r\n    ENDIF;\r\n\r\n  Endif;\r\n\r\n  If ( pCubeLogging <= 1 );\r\n    sCubeLogging = CellGetS('}CubeProperties', pCube, 'LOGGING' );\r\n    CubeSetLogChanges( pCube, pCubeLogging);\r\n  EndIf;\r\n\r\n  If( pFile = 0 );\r\n\r\n    ### Create View of Source ###\r\n\r\n    nRet = ExecuteProcess('}bedrock.cube.view.create',\r\n      'pLogOutput', pLogOutput,\r\n      'pStrictErrorHandling', pStrictErrorHandling,\r\n      'pCube', pCube,\r\n      'pView', cViewSource,\r\n      'pFilter', sFilter,\r\n      'pSuppressZero', pSuppressZero,\r\n      'pSuppressConsol', nSuppressConsol,\r\n      'pSuppressRules', pSuppressRules,\r\n      'pSuppressConsolStrings', pSuppressConsolStrings,\r\n      'pDimDelim', pDimDelim,\r\n      'pEleStartDelim', pEleStartDelim,\r\n      'pEleDelim', pEleDelim ,\r\n      'pTemp', pTemp,\r\n      'pSubN', pSubN\r\n      );\r\n\r\n    IF(nRet <> 0);\r\n          sMessage = 'Error creating the view from the filter.';\r\n          nErrors = nErrors + 1;\r\n          LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n          If( pStrictErrorHandling = 1 );\r\n              ProcessQuit;\r\n          Else;\r\n              ProcessBreak;\r\n          EndIf;\r\n    ENDIF;\r\n\r\n\r\n    ### Assign Datasource ###\r\n    DataSourceType          = 'VIEW';\r\n    DatasourceNameForServer = pCube;\r\n    DatasourceNameForClient = pCube;\r\n    DatasourceCubeView      = cViewSource;\r\n    nThreadMode = 1;\r\n  Else;\r\n    ### Export Data to file ###\r\n\r\n    nRet = ExecuteProcess('}bedrock.cube.data.export',\r\n       'pLogoutput', pLogOutput,\r\n       'pStrictErrorHandling', pStrictErrorHandling,\r\n       'pCube', pCube,\r\n       'pView', cViewSource,\r\n       'pFilter', sFilter,\r\n       'pFilterParallel', '',\r\n       'pParallelThreads', 0,\r\n       'pDimDelim', pDimDelim,\r\n       'pEleStartDelim', pEleStartDelim,\r\n       'pEleDelim', pEleDelim,\r\n       'pSuppressZero', pSuppressZero,\r\n       'pSuppressConsol', nSuppressConsol,\r\n       'pSuppressRules', pSuppressRules,\r\n       'pSuppressConsolStrings', pSuppressConsolStrings,\r\n       'pZeroSource', 0,\r\n       'pCubeLogging', pCubeLogging,\r\n       'pTemp', pTemp,\r\n       'pFilePath', cDir,\r\n       'pFileName', cFileName,\r\n       'pDelim', cDelimiter,\r\n       'pDecimalSeparator', sDecimalSeparator,\r\n       'pThousandSeparator', sThousandSeparator,\r\n       'pQuote', cQuote,\r\n       'pTitleRecord', cTitleRows,\r\n       'pSandbox', pSandbox\r\n      );\r\n\r\n    IF(nRet <> 0);\r\n          sMessage = 'Error exporting data to file.';\r\n          nErrors = nErrors + 1;\r\n          LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n          If( pStrictErrorHandling = 1 );\r\n              ProcessQuit;\r\n          Else;\r\n              ProcessBreak;\r\n          EndIf;\r\n    ENDIF;\r\n\r\n    If(FileExists(cFile) = 0);\r\n      # If the file does not exist, it means that nothing got exported, so there is nothing to import\r\n      If( pLogoutput = 1 );\r\n        LogOutput('INFO', Expand( 'Process:%cThisProcName% is skipping import as export file %cFile% was not found.' ) );\r\n      EndIf;\r\n      DataSourceType = 'NULL';\r\n    Else;\r\n      ### Assign Datasource ###\r\n      DataSourceType                  = 'CHARACTERDELIMITED';\r\n      DatasourceNameForServer         = cFile;\r\n      DatasourceNameForClient         = cFile;\r\n      DatasourceASCIIHeaderRecords    = cTitleRows;\r\n      DatasourceASCIIDelimiter        = cDelimiter;\r\n      DatasourceASCIIQuoteCharacter   = cQuote;\r\n    EndIf;\r\n\r\n    nThreadMode = 1;\r\n\r\n  EndIf;\r\n\r\nEndIf;\r\n\r\n### End Prolog ###\r\n",
    "UIData": "CubeAction=1511\fDataAction=1503\fCubeLogChanges=0\f",
    "Variables": [
        {
            "EndByte": 0,
            "Name": "V1",
            "Position": 1,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V2",
            "Position": 2,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V3",
            "Position": 3,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V4",
            "Position": 4,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V5",
            "Position": 5,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V6",
            "Position": 6,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V7",
            "Position": 7,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V8",
            "Position": 8,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V9",
            "Position": 9,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V10",
            "Position": 10,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V11",
            "Position": 11,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V12",
            "Position": 12,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V13",
            "Position": 13,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V14",
            "Position": 14,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V15",
            "Position": 15,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V16",
            "Position": 16,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V17",
            "Position": 17,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V18",
            "Position": 18,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V19",
            "Position": 19,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V20",
            "Position": 20,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V21",
            "Position": 21,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V22",
            "Position": 22,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V23",
            "Position": 23,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V24",
            "Position": 24,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V25",
            "Position": 25,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V26",
            "Position": 26,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V27",
            "Position": 27,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V28",
            "Position": 28,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V29",
            "Position": 29,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V30",
            "Position": 30,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V31",
            "Position": 31,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V32",
            "Position": 32,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V33",
            "Position": 33,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V34",
            "Position": 34,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V35",
            "Position": 35,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V36",
            "Position": 36,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V37",
            "Position": 37,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V38",
            "Position": 38,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V39",
            "Position": 39,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V40",
            "Position": 40,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V41",
            "Position": 41,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V42",
            "Position": 42,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V43",
            "Position": 43,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V44",
            "Position": 44,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V45",
            "Position": 45,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V46",
            "Position": 46,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V47",
            "Position": 47,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V48",
            "Position": 48,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V49",
            "Position": 49,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "V50",
            "Position": 50,
            "StartByte": 0,
            "Type": "String"
        },
        {
            "EndByte": 0,
            "Name": "Value",
            "Position": 51,
            "StartByte": 0,
            "Type": "Numeric"
        }
    ],
    "VariablesUIData": []
}