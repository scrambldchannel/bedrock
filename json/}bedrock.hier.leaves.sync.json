{
    "DataProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n",
    "DataSource": {
        "Type": "?",
        "asciiDecimalSeparator": ".",
        "asciiDelimiterChar": ",",
        "asciiHeaderRecords": 0,
        "asciiQuoteCharacter": "\"",
        "asciiThousandSeparator": ",",
        "dataSourceNameForClient": "}Dimensions",
        "dataSourceNameForServer": "}Dimensions"
    },
    "EpilogProcedure": "#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n#################################################################################################\r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock Ver 4.0~~##\r\n#################################################################################################\r\n\r\n### If errors occurred terminate process with a major error status ###\r\nIf( nErrors <> 0 );\r\n    sMessage = 'the process incurred at least 1 major error and consequently aborted. Please see above lines in this file for more details.';\r\n    nProcessReturnCode = 0;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% aborted. Check tm1server.log for details.' );\r\n    If( pStrictErrorHandling = 1 );\r\n        ProcessQuit;\r\n    EndIf;\r\nEndIf;\r\n\r\n### Return Code\r\nIf ( nDims <> 0 );\r\n  sDims = NumberToString( nDims );\r\n  sDimsChanged = NumberToString( nDimsChanged );\r\n  If ( nDimsChanged > 0 );\r\n    sProcessAction = Expand( 'Modified [%sDimsChanged%] dimensions out of [%sDims%] matching the filter.' );\r\n  Else;\r\n    sProcessAction = Expand( 'Scanned [%sDims%] dimensions, all are ok.' );\r\n  EndIf;\r\nElse;\r\n  sProcessAction = 'No dimensions/hierarchies are matching supplied parameters. Nothing modified.';\r\nEndIf;\r\nsProcessReturnCode  = Expand( '%sProcessReturnCode% %sProcessAction%' );\r\nnProcessReturnCode  = 1;\r\nIf( pLogoutput <> 0 );\r\n    LogOutput( cMsgInfoLevel, Expand( sProcessAction ) );\r\nEndIf;\r\n\r\n### END EPILOG",
    "HasSecurityAccess": true,
    "MetadataProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n# Get dimension & hierarchy from vDimHier\r\nnDelimHier  = SCAN( ':', vDimHier );\r\nIf ( nDelimHier <> 0 );\r\n    sDim    = SUBST( vDimHier, 1, nDelimHier - 1);\r\n    sHier   = SUBST( vDimHier, nDelimHier + 1, LONG( vDimHier ) - nDelimHier );\r\nElse;\r\n    sDim    = vDimHier;\r\n    sHier   = vDimHier;\r\nEndIf;\r\n\r\nIf ( sHier  @= cHierLeaves );\r\n    ItemSkip;\r\nEndIf;\r\n\r\n# Set check counters\r\nIf( sDim @<> sDimPrev );\r\n    nDims   = nDims + 1;\r\nEndIf;\r\nnElems      = 0;\r\nnLeaves     = 0;\r\n\r\n# Add leaves which exist in hierarchy but (somehow) don't exist in Leaves hierarchy to Leaves\r\nnElem = 1;\r\nnMaxElem = ElementCount( sDim, sHier );\r\nWhile ( nElem <= nMaxElem );\r\n    sElem = ElementName( sDim, sHier, nElem );\r\n    sType = ElementType( sDim, sHier, sElem );\r\n    If ( ElementLevel( sDim, sHier, sElem ) = 0 & HierarchyExists( sDim, cHierLeaves ) = 1 );\r\n        If ( ElementIndex( sDim, cHierLeaves, sElem ) = 0 & ( sType @= 'N' % sType @= 'S' ) );\r\n            HierarchyElementInsert( sDim, cHierLeaves, '', sElem, sType );\r\n            nElems = nElems + 1;\r\n            If ( pLogOutput <> 0 );\r\n                LogOutput( cMsgInfoLevel, Expand( 'Adding element [%sElem%] of [%sType%] type into [%cHierLeaves%], element was found in hierarchy [%sHier%].' ) );\r\n            EndIf;\r\n        EndIf;\r\n    EndIf;\r\n    nElem = nElem + 1;\r\nEnd;\r\n\r\n# Add leaves not existing in hierarchy to the 'ORPHAN LEAVES' consolidation\r\nIf( pReverse = 1 & HierarchyExists( sDim, cHierLeaves ) = 1 );\r\n    nLeaf = 1;\r\n    nMaxLeaves = ElementCount( sDim, cHierLeaves );\r\n    While ( nLeaf <= nMaxLeaves );\r\n        sLeaf = ElementName( sDim, cHierLeaves, nLeaf );\r\n        sType = ElementType( sDim, cHierLeaves, sLeaf );\r\n        If ( ElementIndex( sDim, sHier, sLeaf ) = 0 );\r\n            HierarchyElementInsert( sDim, sHier, '', cRollupOrphan, 'C' );\r\n            HierarchyElementInsert( sDim, sHier, '', sLeaf, sType );\r\n            If( sType @= 'N' );\r\n                HierarchyElementComponentAdd( sDim, sHier, cRollupOrphan, sLeaf, 1 );\r\n            EndIf;\r\n            nLeaves = nLeaves + 1;\r\n            If ( pLogOutput <> 0 );\r\n                LogOutput( cMsgInfoLevel, Expand( 'Adding leaf [%sLeaf%] into hierarchy [%sHier%].' ) );\r\n            EndIf;\r\n        EndIf;\r\n        nLeaf = nLeaf + 1;\r\n    End;\r\nEndIf;\r\n\r\n# Summary information printout\r\nIf( nElems  > 0 );\r\n    sElems  = NumberToString( nElems );\r\n    If ( pLogOutput <> 0 );\r\n        LogOutput( cMsgInfoLevel, Expand( 'Added [%sElems%] elements from hierarchy [%sHier%] into [%cHierLeaves%] hierarchy of [%sDim%] dimension.' ) );\r\n    EndIf;\r\nEndIf;\r\nIf( nLeaves > 0 );\r\n    sLeaves = NumberToString( nLeaves );\r\n    If ( pLogOutput <> 0 );\r\n        LogOutput( cMsgInfoLevel, Expand( 'Added [%sLeaves%] leaves into hierarchy [%sHier%] of [%sDim%] dimension.' ) );\r\n    EndIf;\r\nEndIf;\r\nIf( sDim @<> sDimPrev & (nElems + nLeaves) > 0 );\r\n    nDimsChanged = nDimsChanged + 1;\r\nEndIf;\r\nsDimPrev    = sDim;\r\n\r\n### END METADATA",
    "Name": "}bedrock.hier.leaves.sync",
    "Parameters": [
        {
            "Name": "pLogOutput",
            "Prompt": "OPTIONAL: Write parameters and action summary to server message log (Boolean True = 1)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pStrictErrorHandling",
            "Prompt": "OPTIONAL: On encountering any error exit with major error status by ProcessQuit after writing to the server message log (Boolean True = 1)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pDim",
            "Prompt": "REQUIRED: Dimension accepts wildcards (all dimensions = *)",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pHier",
            "Prompt": "OPTIONAL: Hierarchy accepts wildcards (all hierarchies = *)",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pDelim",
            "Prompt": "OPTIONAL: Delimiter character (default value if blank = '&')",
            "Type": "String",
            "Value": "&"
        },
        {
            "Name": "pReverse",
            "Prompt": "OPTIONAL: If true then also add any elements from the Leaves hierarchy not existing in the specified hierarchies to those hierarchies (under a consolidation bucket 'ORPHAN LEAVES')",
            "Type": "Numeric",
            "Value": "0"
        }
    ],
    "PrologProcedure": "#Region CallThisProcess\r\n# A snippet of code provided as an example how to call this process should the developer be working on a system without access to an editor with auto-complete.\r\nIf( 1 = 0 );\r\n    ExecuteProcess( '}bedrock.hier.leaves.sync', 'pLogOutput', pLogOutput, 'pStrictErrorHandling', pStrictErrorHandling,\r\n\t    'pDim', '', 'pHier', '', 'pDelim', '&', 'pReverse', 0\r\n\t);\r\nEndIf;\r\n#EndRegion CallThisProcess\r\n\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n#################################################################################################\r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock Ver 4.0~~##\r\n#################################################################################################\r\n\r\n#Region @DOC\r\n# Description:\r\n# In certain circumstances the Leaves hierarchy can become *out of sync* with the same named hierarchy and other alternate hierarchies\r\n# and *not contain all leaf elements*. Should this happen this process will heal such dimensions and restore the synced state where\r\n# the Leaves hierarchy contains the collection of all leaf elements from all hiearchies of a dimension.\r\n# For the set of dimensions and hierarchies defined by the pDim & pHier parameters this process checks that all leaf elements from each\r\n# hierarchy also exists in the Leaves hierarchy of the specified dimension(s).\r\n#\r\n# If the leaf element does not exist in the Leaves hierarchy then the element is inserted into Leaves.\r\n#\r\n# Use case:\r\n# 1. Primarily intended to identify dimensions with maintenance issues during development/prototyping.\r\n# 2. Can also be used for trouble-shooting in productive instances.\r\n#\r\n#EndRegion @DOC\r\n\r\n### Global Variables\r\nStringGlobalVariable('sProcessReturnCode');\r\nNumericGlobalVariable('nProcessReturnCode');\r\nnProcessReturnCode= 0;\r\n\r\n### Constants\r\ncThisProcName     = GetProcessName();\r\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\r\ncRandomInt        = NumberToString( INT( RAND( ) * 1000 ));\r\ncTempSub          = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\r\ncTempSubDim       = cThisProcName |'_Dim_'| cTimeStamp |'_'| cRandomInt;\r\ncUserName         = TM1User();\r\ncMsgErrorLevel    = 'ERROR';\r\ncMsgInfoLevel     = 'INFO';\r\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\r\ncLogInfo          = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%.';\r\ncAll              = '*';\r\ncDimDimensions    = '}Dimensions';\r\ncCharAny          = '?';\r\ncStringAny        = '*';\r\ncHierLeaves       = 'Leaves';\r\ncRollupOrphan     = 'ORPHAN LEAVES';\r\n\r\n### LogOutput parameters\r\nIF( pLogoutput >= 1 );\r\n  LogOutput('INFO', Expand( cLogInfo ) );\r\nENDIF;\r\n\r\n### Validate Parameters\r\nsDimPrev          = '';\r\nnErrors           = 0;\r\nnDims             = 0;\r\nnDimsChanged      = 0;\r\nnElems            = 0;\r\nnLeaves           = 0;\r\n\r\nIf( Scan( '*', pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0 & Scan( ':', pDim ) > 0 & pHier @= '' );\r\n  # A hierarchy has been passed as dimension. Handle the input error by splitting dim:hier into dimension & hierarchy\r\n  pHier = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\r\n  pDim = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\r\nEndIf;\r\n\r\n### Validate delimiter\r\nIf( Trim( pDelim ) @= '' );\r\n  pDelim = '&';\r\nEndIf;\r\n\r\n### Validate dimension\r\nIf( Trim( pDim ) @= '' );\r\n  nErrors = 1;\r\n  sMessage = 'No dimension specified.';\r\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\n### Validate reverse sync option\r\nIf( pReverse <> 1 );\r\n  pReverse = 0;\r\nEndIf;\r\n\r\n### If errors occurred terminate process with a major error status ###\r\nIf( nErrors <> 0 );\r\n  If( pStrictErrorHandling = 1 );\r\n      ProcessQuit;\r\n  Else;\r\n      ProcessBreak;\r\n  EndIf;\r\nEndIf;\r\n\r\n### Handle All dimensions or a dimension list, including all available hierarchies\r\nIf ( TRIM( pDim ) @= cAll );\r\n  sMDX1 = Expand( '{TM1SUBSETALL([%cDimDimensions%])}' );\r\nElse;\r\n  sDimTokenizer = TRIM( pDim );\r\n  sMDX = '';\r\n  ### Loop and tokenize dimension list\r\n  While ( sDimTokenizer @<> '' );\r\n    nPos = SCAN( pDelim, sDimTokenizer );\r\n    If ( nPos = 0 );\r\n      nPos = LONG( sDimTokenizer ) + 1;\r\n    EndIf;\r\n    sSearchDim = TRIM( SUBST( sDimTokenizer, 1, nPos - 1 ) );\r\n    If( sMDX @= '' );\r\n      sMDX = Expand( '{TM1FILTERBYPATTERN( {TM1SUBSETALL([%cDimDimensions%])}, \"%sSearchDim%*\" )}' );\r\n    Else;\r\n      sMDX = Expand( '%sMDX% + {TM1FILTERBYPATTERN( {TM1SUBSETALL([%cDimDimensions%])}, \"%sSearchDim%\" )}' );\r\n    EndIf;\r\n    ### Consume dimension and delimiter\r\n    sDimTokenizer = TRIM( DELET( sDimTokenizer, 1, nPos + LONG( pDelim ) - 1 ) );\r\n  End;\r\n  sMDX1 = Expand( '{%sMDX%}' );\r\nEndIf;\r\n\r\n### Handle All hierarchies or a hierarchy list\r\n### We will filter hierarchies in this step from base set created previously\r\nIf ( TRIM( pHier ) @= cAll );\r\n  sMDX = sMDX1;\r\nElse;\r\n  sHierTokenizer = TRIM( pHier );\r\n  If( sHierTokenizer @= '' );\r\n    # if pHier blank then we need only same named hierarchies - that means to exclude elements that have : in their names\r\n    sMDX = Expand( '{FILTER( %sMDX1%, INSTR([%cDimDimensions%].CurrentMember.Name, '':'' ) = 0 )}' );\r\n  Else;\r\n    sMDX = '';\r\n    ### Loop and tokenize hierarchy list\r\n    While ( sHierTokenizer @<> '' );\r\n      nPos = SCAN( pDelim, sHierTokenizer );\r\n      If ( nPos = 0 );\r\n        nPos = LONG( sHierTokenizer ) + 1;\r\n      EndIf;\r\n      sSearchHier = TRIM( SUBST( sHierTokenizer, 1, nPos - 1 ) );\r\n      If( sMDX @= '' );\r\n        sMDX = Expand( '{TM1FILTERBYPATTERN( %sMDX1%, \"*:%sSearchHier%\" )}' );\r\n      Else;\r\n        sMDX = Expand( '%sMDX% + {TM1FILTERBYPATTERN( %sMDX1%, \"*:%sSearchHier%\" )}' );\r\n      EndIf;\r\n      ### Consume hierarchy and delimiter\r\n      sHierTokenizer = TRIM( DELET( sHierTokenizer, 1, nPos + LONG( pDelim ) - 1 ) );\r\n    End;\r\n    sMDX = Expand( '{%sMDX%}' );\r\n  EndIf;\r\nEndIf;\r\n\r\nsMDX = Expand(' {EXCEPT( %sMDX%, {TM1FILTERBYPATTERN( {TM1SUBSETALL([%cDimDimensions%])}, \"*:Leaves\" )} )}');\r\nsMDXF = Expand( '{ORDER( %sMDX%, [%cDimDimensions%].CurrentMember.Name, ASC )}' );\r\n\r\n### Create dimension:hierarchy subset\r\nIf ( SubsetExists( cDimDimensions, cTempSub ) = 0 );\r\n    SubsetCreatebyMDX( cTempSub, sMDXF, cDimDimensions, 1 );\r\nElse;\r\n    SubsetMDXSet( cDimDimensions, cTempSub, sMDXF );\r\nEndIf;\r\n\r\nDatasourceNameForServer = cDimDimensions;\r\nDatasourceNameForClient = cDimDimensions;\r\nDataSourceType = 'SUBSET';\r\nDatasourceDimensionSubset = cTempSub;\r\n\r\n### END PROLOG",
    "UIData": "CubeAction=1511\fDataAction=1503\fCubeLogChanges=0\f",
    "Variables": [
        {
            "EndByte": 0,
            "Name": "vDimHier",
            "Position": 1,
            "StartByte": 0,
            "Type": "String"
        }
    ],
    "VariablesUIData": []
}