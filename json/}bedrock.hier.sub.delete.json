{
    "DataProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n",
    "DataSource": {
        "Type": "None"
    },
    "EpilogProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n#################################################################################################\r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock Ver 4.0~~##\r\n#################################################################################################\r\n\r\n### Return code & final error message handling\r\nIf( nErrors > 0 );\r\n    sMessage = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\r\n    nProcessReturnCode = 0;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\r\n    If( pStrictErrorHandling = 1 );\r\n        ProcessQuit;\r\n    EndIf;\r\nElse;\r\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully deleted subset %pSub% from dimension %pDim%.' );\r\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\r\n    nProcessReturnCode = 1;\r\n    If( pLogoutput = 1 );\r\n        LogOutput('INFO', Expand( sProcessAction ) );\r\n    EndIf;\r\nEndIf;\r\n\r\n### End Epilog ###",
    "HasSecurityAccess": true,
    "MetadataProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n",
    "Name": "}bedrock.hier.sub.delete",
    "Parameters": [
        {
            "Name": "pLogOutput",
            "Prompt": "OPTIONAL: Write parameters and action summary to server message log (Boolean True = 1)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pStrictErrorHandling",
            "Prompt": "OPTIONAL: On encountering any error exit with major error status by ProcessQuit after writing to the server message log (Boolean True = 1)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pDim",
            "Prompt": "OPTIONAL: Dimension name (if * then ALL dimensions )",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pHier",
            "Prompt": "OPTIONAL: Hierarchy name (if * then ALL hierarchies for the specified dimensions)",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pSub",
            "Prompt": "REQUIRED: Filter on subsets (delimiter separated list of subset names accepts wildcards)",
            "Type": "String",
            "Value": "}Bedrock*"
        },
        {
            "Name": "pDelim",
            "Prompt": "OPTIONAL: Delimiter character for subset list (required if pSub parameter is used)",
            "Type": "String",
            "Value": "&"
        },
        {
            "Name": "pMode",
            "Prompt": "OPTIONAL: <=1 destroy subset 2 delete all elements",
            "Type": "Numeric",
            "Value": "0"
        }
    ],
    "PrologProcedure": "#Region CallThisProcess\r\n# A snippet of code provided as an example how to call this process should the developer be working on a system without access to an editor with auto-complete.\r\nIf( 1 = 0 );\r\n    ExecuteProcess( '}bedrock.hier.sub.delete', 'pLogOutput', pLogOutput,\r\n      'pStrictErrorHandling', pStrictErrorHandling,\r\n    \t'pDim', '', 'pHier', '', 'pSub', '',\r\n    \t'pDelim', '&', 'pMode', 0\r\n\t);\r\nEndIf;\r\n#EndRegion CallThisProcess\r\n\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n#################################################################################################\r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock Ver 4.0~~##\r\n#################################################################################################\r\n\r\n#Region @DOC\r\n# Description:\r\n# This process deletes public subsets from selected dimension and hierarchies. Dimensions, hierarchies\r\n# and subsets can be specified as a delimited list. Wildcards are accepted as `*` and `?` characters.\r\n\r\n# Note:\r\n# - pDim: To specify which dimensions to delete subsets from use the pDim parameter.\r\n#   - To delete subsets from a single dimension only just specify that dimension name e.g. `Product`.\r\n#   - To delete subsets from multiple dimensions specify each dimension name separated by a delimiter\r\n#     e.g. `Product & Customer & Account`.\r\n#   - To delete subsets from all dimensions then leave pDim parameter blank or supply `ALL`.\r\n#   - If any invalid dimensions are specified they will be skipped but the process will continue to\r\n#     process the other dimensions.\r\n#   - When specifying dimension names wildcards are permitted and all dimensions that match the\r\n#     wildcard search string will be searched - for syntax see below pSub parameter.\r\n# - pHier: To specify which hierarchies to delete subsets from use the pHier parameter.\r\n#   - To specify default hierachy, leave parameter value empty.\r\n#   - To specify all available hierarchies, set parameter value to `*`.\r\n#   - When specifying hierarchy names wildcards are permitted and all hierachies that match the wildcard\r\n#     search string will be searched - for syntax see below pSub parameter.\r\n# - pSub: To specify which subsets to delete use the pSub parameter.\r\n#   - This parameter must be specified, a blank value will cause the process to terminate.\r\n#   - To delete a single subset only just specify that subset name e.g. `SmallProducts`.\r\n#   - To delete multiple subsets specify each subset name separated by a delimiter\r\n#     e.g. `SmallProducts & LargeProducts`.\r\n# - pDelim: The delimiter is used when specifying multiple dimensions and/or multiple subsets.\r\n#   - The default delimiter is `&`.\r\n#   - Any delimiter can be used by specifying a value for pDelim.\r\n#   - Choose a delimiter that won't be used in either the wildcard search strings or dimension names.\r\n# - pMode:\r\n#   - When set to value less or equal to `1`: all found subsets will be destroyed.\r\n#   - When set to value of `2`: all found subsets will be emptied.\r\n# __Example__:\r\n# - When specifying subset names wildcards are permitted and all subsets that match the wildcard\r\n#   search string will be deleted:\r\n#     - The wildcard search string follows the same format as wildcards used in Subset Editor.\r\n#     - To delete all subsets that __start__ with a specific string use a trailing `*` e.g. `Bedrock*`.\r\n#     - To delete all subsets that __end__ in a specific string use a leading `*` e.g. `*Bedrock`.\r\n#     - To delete all subsets that __contain__ a specific string use leading and trailing `*`'s e.g. `*Bedrock*`.\r\n#     - To delete a single specific subset only don't use `*`'s at all e.g. `Bedrock`.\r\n#     - To specify multiple search stings list them all separated by a delimiter e.g. `Bedrock* & *Temp & *Test*`.\r\n#     - Similarly you can use `?` as wildcard specifying one character - usage is similar as above specified examples for `*`.\r\n#     - Specific subset names and wildcard based names can both be used together e.g. `SalesByProduct;Bedrock*`\r\n#EndRegion @DOC\r\n\r\n### Global Variables\r\n\r\nStringGlobalVariable('sProcessReturnCode');\r\nNumericGlobalVariable('nProcessReturnCode');\r\nnProcessReturnCode= 0;\r\n\r\n### Constants\r\n\r\ncThisProcName     = GetProcessName();\r\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\r\ncRandomInt        = NumberToString( INT( RAND( ) * 1000 ));\r\ncTempSub          = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\r\ncTempSubDim       = cThisProcName |'_Dim_'| cTimeStamp |'_'| cRandomInt;\r\ncUserName         = TM1User();\r\ncMsgErrorLevel    = 'ERROR';\r\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\r\ncLogInfo          = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%, pSub:%pSub%, pMode:%pMode%.';\r\ncAll              = 'ALL';\r\ncDimDimensions    = '}Dimensions';\r\ncCharAny          = '?';\r\ncStringAny        = '*';\r\ncCharDimHier      = ':';\r\n\r\n### Flag - quit before parsing of parameters\r\nnSkipParsing      = 0;\r\nsProcessAction    = '';\r\n\r\n### LogOutput parameters\r\nIF( pLogoutput = 1 );\r\n  LogOutput('INFO', Expand( cLogInfo ) );\r\nENDIF;\r\n\r\n### Validate Parameters\r\n\r\nnErrors = 0;\r\n\r\nIf( Scan( '*', pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0 & Scan( ':', pDim ) > 0 & pHier @= '' );\r\n    # A hierarchy has been passed as dimension. Handle the input error by splitting dim:hier into dimension & hierarchy\r\n    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\r\n    pDim        = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\r\nEndIf;\r\n\r\n### Validate delimiter\r\nIf( Trim( pDelim ) @= '' );\r\n  pDelim = '&';\r\nEndIf;\r\n\r\n### Validate dimension\r\nIf( Trim( pDim ) @= '' );\r\n  nErrors = 1;\r\n  sMessage = 'No dimension specified';\r\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n  If( pStrictErrorHandling = 1 );\r\n      ProcessQuit;\r\n  Else;\r\n      ProcessBreak;\r\n  EndIf;\r\nEndIf;\r\nIf( SCAN( cCharAny, pDim ) = 0 & SCAN( cStringAny, pDim ) = 0 & SCAN( pDelim, pDim ) = 0 & SCAN( cCharDimHier, pDim ) > 0 & pHier @= '' );\r\n    pHier = SubSt( pDim, SCAN( cCharDimHier, pDim ) + 1, Long( pDim ) );\r\n    pDim = SubSt( pDim, 1, SCAN( cCharDimHier, pDim ) - 1 );\r\nEndIf;\r\n\r\n## Validate Hierarchy\r\n\r\nIF(pHier @= 'Leaves' );\r\n  nErrors = 1;\r\n  sMessage = 'Invalid  Hierarchy: ' | pDim |':'|pHier;\r\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\nIf( Trim( pHier ) @<> '' );\r\n  sHier = pHier;\r\nEndIf;\r\n\r\n### Validate subset\r\nIf( Trim( pSub ) @= '' );\r\n  nErrors = 1;\r\n  sMessage = 'No subsets specified';\r\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n  If( pStrictErrorHandling = 1 );\r\n      ProcessQuit;\r\n  Else;\r\n      ProcessBreak;\r\n  EndIf;\r\nEndIf;\r\n\r\n### Destroy subset if exactly specified in parameters - important for recursive calls\r\nIf ( SCAN( cCharAny, pDim ) = 0 & SCAN( cStringAny, pDim ) = 0 & SCAN( pDelim, pDim ) = 0 &\r\n     SCAN( cCharAny, pHier ) = 0 & SCAN( cStringAny, pHier ) = 0 & SCAN( pDelim, pHier ) = 0 &\r\n     SCAN( cCharAny, pSub ) = 0 & SCAN( cStringAny, pSub ) = 0 & SCAN( pDelim, pSub ) = 0 );\r\n  If ( DimensionExists( pDim ) = 0 );\r\n    nErrors = 1;\r\n    sMessage = Expand( 'Dimension %pDim% doesn''t exist.' );\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n    If( pStrictErrorHandling = 1 );\r\n        ProcessQuit;\r\n    Else;\r\n        ProcessBreak;\r\n    EndIf;\r\n  EndIf;\r\n  If ( pHier @<> '' & HierarchyExists( pDim, pHier ) = 0 );\r\n    nErrors = 1;\r\n    sMessage = Expand( 'Hierarchy %pHier% doesn''t exist in dimension %pDim%.' );\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n    If( pStrictErrorHandling = 1 );\r\n        ProcessQuit;\r\n    Else;\r\n        ProcessBreak;\r\n    EndIf;\r\n  EndIf;\r\n  If ( HierarchySubsetExists( pDim, pHier, pSub ) = 0 );\r\n    nErrors = 1;\r\n    sMessage = Expand( 'Subset %pSub% doesn''t exist in hierarchy %pHier% of dimension %pDim%.' );\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n    If( pStrictErrorHandling = 1 );\r\n        ProcessQuit;\r\n    Else;\r\n        ProcessBreak;\r\n    EndIf;\r\n  EndIf;\r\n  If ( pHier @= '' );\r\n    pHier = pDim;\r\n  EndIf;\r\n  If ( pMode <= 1 );\r\n    HierarchySubsetDestroy( pDim, pHier, pSub );\r\n    sProcessAction = Expand( 'Destroyed subset %pSub% on dimension %pDim% in hierarchy %pHier%.' );\r\n  ElseIf ( pMode = 2 );\r\n    HierarchySubsetDeleteAllElements( pDim, pHier, pSub );\r\n    sProcessAction = Expand( 'Deleted all elements from subset %pSub% on dimension %pDim% in hierarchy %pHier%.' );\r\n  EndIf;\r\n  ### We don't need to parse any parameters as this was exact match, so we will finish processing\r\n  nSkipParsing = 1;\r\nEndIf;\r\n\r\n### Need to process parameters before cleaning\r\nIf ( nSkipParsing = 0 );\r\n\r\n  ### Validate all dimension case\r\n  If( Trim( pDim ) @= '*' );\r\n    pDim = cAll;\r\n  EndIf;\r\n\r\n  ### Handle All dimensions or a dimension list\r\n  ### We will exclude hierarchies in this step and will filter them in connection with subsets in later steps\r\n  If ( TRIM( pDim ) @= cAll );\r\n    sMDX = Expand( '{FILTER(TM1SUBSETALL([%cDimDimensions%]), INSTR([%cDimDimensions%].CurrentMember.Name, '':'' ) = 0 )}' );\r\n  Else;\r\n    sDimTokenizer = TRIM( pDim );\r\n    sMDX = '';\r\n    ### Loop and tokenize dimension list\r\n    While ( sDimTokenizer @<> '' );\r\n      nPos = SCAN( pDelim, sDimTokenizer );\r\n      If ( nPos = 0 );\r\n        nPos = LONG( sDimTokenizer ) + 1;\r\n      EndIf;\r\n      sSearchDim = TRIM( SUBST( sDimTokenizer, 1, nPos - 1 ) );\r\n      If( sMDX @= '' );\r\n        sMDX = Expand( '{TM1FILTERBYPATTERN({FILTER(TM1SUBSETALL([%cDimDimensions%]), INSTR([%cDimDimensions%].CurrentMember.Name, '':'' ) = 0 )}, \"%sSearchDim%\")}' );\r\n      Else;\r\n        sMDX = Expand( '%sMDX% + {TM1FILTERBYPATTERN({FILTER(TM1SUBSETALL([%cDimDimensions%]), INSTR([%cDimDimensions%].CurrentMember.Name, '':'' ) = 0 )}, \"%sSearchDim%\")}' );\r\n      EndIf;\r\n      ### Consume dimension and delimiter\r\n      sDimTokenizer = TRIM( DELET( sDimTokenizer, 1, nPos + LONG( pDelim ) - 1 ) );\r\n    End;\r\n    sMDX = Expand( '{%sMDX%}' );\r\n  EndIf;\r\n\r\n  ### Create dimensions subset\r\n  If ( SubsetExists( cDimDimensions, cTempSub ) = 1 );\r\n    SubsetMDXSet( cDimDimensions, cTempSub, sMDX );\r\n  Else;\r\n    SubsetCreatebyMDX( cTempSub, sMDX, cDimDimensions, 1 );\r\n  EndIf;\r\n  nMaxDim = SubsetGetSize( cDimDimensions, cTempSub );\r\n\r\n  ### Loop through dimensions\r\n  nCurDim = 1;\r\n  While ( nCurDim <= nMaxDim );\r\n    sCurDim = SubsetGetElementName( cDimDimensions, cTempSub, nCurDim );\r\n    sCurSubDim = Expand( '}Subsets_%sCurDim%' );\r\n    ### We will lookup subsets in }Subsets_ dimension of current dim\r\n    If ( DimensionExists( sCurSubDim ) <> 0 );\r\n      If ( pHier @= '' );\r\n        sHier = sCurDim;\r\n      Else;\r\n        sHier = pHier;\r\n      EndIf;\r\n      sHierTokenizer = TRIM( sHier );\r\n      sMDX = '';\r\n      ### Loop and tokenize hierarchies list\r\n      While ( sHierTokenizer @<> '' );\r\n        nPos = SCAN( pDelim, sHierTokenizer );\r\n        If ( nPos = 0 );\r\n          nPos = LONG( sHierTokenizer ) + 1;\r\n        EndIf;\r\n        sSearchHier = TRIM( SUBST( sHierTokenizer, 1, nPos - 1 ) );\r\n        sSubTokenizer = TRIM( pSub );\r\n        ### Loop and tokenize subset list\r\n        While ( sSubTokenizer @<> '' );\r\n          nPos1 = SCAN( pDelim, sSubTokenizer );\r\n          If ( nPos1 = 0 );\r\n            nPos1 = LONG( sSubTokenizer ) + 1;\r\n          EndIf;\r\n          sSearchSubset = TRIM( SUBST( sSubTokenizer, 1, nPos1 - 1 ) );\r\n          If ( sSearchHier @<> '*' );\r\n            If ( sSearchHier @= sCurDim );\r\n              sSearchMDX = sSearchSubset;\r\n            Else;\r\n              sSearchMDX = Expand( '%sSearchHier%:%sSearchSubset%' );\r\n            EndIf;\r\n            If( sMDX @= '' );\r\n              sMDX = Expand( '{TM1FILTERBYPATTERN(TM1SUBSETALL( [%sCurSubDim%] ), \"%sSearchMDX%\")}' );\r\n            Else;\r\n              sMDX = Expand( '%sMDX% + {TM1FILTERBYPATTERN(TM1SUBSETALL( [%sCurSubDim%] ), \"%sSearchMDX%\")}' );\r\n            EndIf;\r\n          Else;\r\n            # We need to handle special case of * specified as hierarchy filter - this is interpreted as ALL hierarchies - otherwise we would be skipping default hierarchy\r\n            sSearchMDX1 = Expand( '%sSearchHier%:%sSearchSubset%' );\r\n            sSearchMDX2 = Expand( '%sSearchSubset%' );\r\n            If( sMDX @= '' );\r\n              sMDX = Expand( '{TM1FILTERBYPATTERN(TM1SUBSETALL( [%sCurSubDim%] ), \"%sSearchMDX1%\")} + {TM1FILTERBYPATTERN(TM1SUBSETALL( [%sCurSubDim%] ), \"%sSearchMDX2%\")}' );\r\n            Else;\r\n              sMDX = Expand( '%sMDX% + {TM1FILTERBYPATTERN(TM1SUBSETALL( [%sCurSubDim%] ), \"%sSearchMDX1%\")} + {TM1FILTERBYPATTERN(TM1SUBSETALL( [%sCurSubDim%] ), \"%sSearchMDX2%\")}' );\r\n            EndIf;\r\n          EndIf;\r\n          ### Consume subset and delimiter\r\n          sSubTokenizer = TRIM( DELET( sSubTokenizer, 1, nPos1 + LONG( pDelim ) - 1 ) );\r\n        End;\r\n        ### Consume hierarchy and delimiter\r\n        sHierTokenizer = TRIM( DELET( sHierTokenizer, 1, nPos + LONG( pDelim )- 1 ) );\r\n      End;\r\n      ### Query the hierarchies/subsets\r\n      If ( SubsetExists( sCurSubDim, cTempSub ) = 1 );\r\n        SubsetMDXSet( sCurSubDim, cTempSub, sMDX );\r\n      Else;\r\n        SubsetCreatebyMDX( cTempSub, sMDX, sCurSubDim, 1 );\r\n      EndIf;\r\n      nMaxSubs = SubsetGetSize( sCurSubDim, cTempSub );\r\n      nCurSubs = nMaxSubs;\r\n      While ( nCurSubs >= 1 );\r\n        sCurSubs = SubsetGetElementName( sCurSubDim, cTempSub, nCurSubs );\r\n        nColPos = SCAN( ':', sCurSubs );\r\n        If ( nColPos = 0 );\r\n          sHierarchy = sCurDim;\r\n          sSubset = sCurSubs;\r\n        Else;\r\n          sHierarchy = SUBST( sCurSubs, 1, nColPos - 1 );\r\n          sSubset = SUBST( sCurSubs, nColPos + 1, LONG(sCurSubs) - nColPos );\r\n        EndIf;\r\n        If ( pMode <= 1 );\r\n          ### Recursive call to consume process error in this process and not to broadcast it to the parent caller process\r\n          ExecuteProcess( cThisProcName,\r\n            'pStrictErrorHandling', pStrictErrorHandling,\r\n            'pLogOutput', pLogOutput,\r\n            'pDim', sCurDim,\r\n            'pHier', sHierarchy,\r\n            'pSub', sSubset,\r\n            'pDelim', pDelim,\r\n            'pMode', pMode\r\n          );\r\n        ElseIf ( pMode = 2 );\r\n          ### No need for a recursive call as we suppose this call is not going to raise a process error - this will save processing time significantly\r\n          HierarchySubsetDeleteAllElements( pDim, pHier, pSub );\r\n          sProcessAction = Expand( 'Deleted all elements from subset %pSub% on dimension %pDim% in hierarchy %pHier%.' );\r\n        EndIf;\r\n        nCurSubs = nCurSubs - 1;\r\n      End;\r\n    EndIf;\r\n    nCurDim = nCurDim + 1;\r\n  End;\r\nEndIf;\r\n\r\n### End Prolog ###",
    "UIData": "CubeAction=1511\fDataAction=1503\fCubeLogChanges=0\f",
    "Variables": [],
    "VariablesUIData": []
}