{
    "DataProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n",
    "DataSource": {
        "Type": "None"
    },
    "EpilogProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n#################################################################################################\r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock Ver 4.0~~##\r\n#################################################################################################\r\n\r\n### Return code & final error message handling\r\nIf( nErrors > 0 );\r\n    sMessage = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\r\n    nProcessReturnCode = 0;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\r\n    If( pStrictErrorHandling = 1 );\r\n        ProcessQuit;\r\n    EndIf;\r\nElse;\r\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully cleared data out of the %pCube% cube(s).' );\r\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\r\n    nProcessReturnCode = 1;\r\n    If( pLogoutput = 1 );\r\n        LogOutput('INFO', Expand( sProcessAction ) );\r\n    EndIf;\r\nEndIf;\r\n\r\n### End Epilog ###",
    "HasSecurityAccess": true,
    "MetadataProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n",
    "Name": "}bedrock.cube.data.clear",
    "Parameters": [
        {
            "Name": "pLogOutput",
            "Prompt": "OPTIONAL: Write parameters and action summary to server message log (Boolean True = 1)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pStrictErrorHandling",
            "Prompt": "OPTIONAL: On encountering any error exit with major error status by ProcessQuit after writing to the server message log (Boolean True = 1)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pCube",
            "Prompt": "REQUIRED: Cube Name (wildcard * and/or cube1 & cube2 list)",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pView",
            "Prompt": "OPTIONAL: View name to be cleared (uses pFilter if pView not specified else clears entire cube)",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pFilter",
            "Prompt": "Optional but ignored if view is specified: Year\u00a6 2006 + 2007 & Scenario\u00a6 Actual + Budget & Organization\u00a6 North America Operations",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pFilterParallel",
            "Prompt": "OPTIONAL: Parallelization Filter: Month:Q1+Q2+Q3+Q4 (Blank=run single threaded). Single dimension parallel slices. Will be added to filter single element at a time. Dimension must not be part of filter",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pParallelThreads",
            "Prompt": "OPTIONAL: Ignored if pFilterParallel is empty. Maximum number of threads to run when parallel processing is enabled ( if <2 will execute one thread but parallel filter is still applied )",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pDimDelim",
            "Prompt": "OPTIONAL: Delimiter for start of Dimension/Element set  (default value if blank = '&')",
            "Type": "String",
            "Value": "&"
        },
        {
            "Name": "pEleStartDelim",
            "Prompt": "OPTIONAL: Delimiter for start of element list  (default value if blank = '\u00a6')",
            "Type": "String",
            "Value": "\u00a6"
        },
        {
            "Name": "pEleDelim",
            "Prompt": "OPTIONAL: Delimiter between elements (default value if blank = '+')",
            "Type": "String",
            "Value": "+"
        },
        {
            "Name": "pSuppressConsolStrings",
            "Prompt": "OPTIONAL: Suppress Consolidated String Cells (Skip = 1)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pCubeLogging",
            "Prompt": "Required: Cube Logging (0 = No transaction logging 1 = Logging of transactions 2 = Ignore Cube Logging - No Action Taken)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pTemp",
            "Prompt": "OPTIONAL: Make Views and subsets Temporary (1=Temporary)",
            "Type": "Numeric",
            "Value": "1"
        },
        {
            "Name": "pSandbox",
            "Prompt": "OPTIONAL: To use sandbox not base data enter the sandbox name (invalid name will result in process error)",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pSubN",
            "Prompt": "OPTIONAL: Create N level subset for all dims not mentioned in pFilter",
            "Type": "Numeric",
            "Value": "0"
        }
    ],
    "PrologProcedure": "#Region CallThisProcess\r\n# A snippet of code provided as an example how to call this process should the developer be working on a system without access to an editor with auto-complete.\r\nIf( 1 = 0 );\r\n    ExecuteProcess( '}bedrock.cube.data.clear', 'pLogOutput', pLogOutput,\r\n      'pStrictErrorHandling', pStrictErrorHandling,\r\n    \t'pCube', '', 'pView', '', 'pFilter', '',\r\n    \t'pFilterParallel', '', 'pParallelThreads', 0,\r\n    \t'pDimDelim', '&', 'pEleStartDelim', '\u00a6', 'pEleDelim', '+', 'pSuppressConsolStrings', 0,\r\n    \t'pCubeLogging', 0, 'pTemp', 1, 'pSandbox', pSandbox, 'pSubN', 0\r\n\t);\r\nEndIf;\r\n#EndRegion CallThisProcess\r\n\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n#################################################################################################\r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock Ver 4.0~~##\r\n#################################################################################################\r\n\r\n#Region @DOC\r\n# Description:\r\n# This process could be used extensively by custom TIs in production to clear certain data out of a cube before copying data to that cube.\r\n\r\n# Use case: Primarily for production systems.\r\n# 1/ In production system this is a \"workhorse\" process called from the prolog of most custom processes prior to querying a data source to refresh cube data.\r\n# 2/ During development/prototyping can be run manually to clear out a portion of a cube.\r\n\r\n# Note:\r\n# Wildcards can be used or a list of cubes specified to clear data out of multiple cubes simultaneouly.\r\n# If no cube (pCube) or an invalid cube is specified, the process will abort.\r\n# CAUTION: If no view (pView) or filter (pFilter) is specified, the entire cube(s) will be cleared out.\r\n# If a valid view is specified the process will simply zero out that view and ignore any filter (pFilter) specified.\r\n# If no valid view is specified then a temporary view will be built using the filter and its data deleted.\r\n# The filter can handle specific element references for any number of dimensions and elements.\r\n# - The pFilter parameter contains the dimension and elements to be used for filtering.\r\n# - The dimension parameters do not need to be given in the index order of dimensions in the cube.\r\n# - The dimension name is specified as the first member of the delimited string of elements.\r\n# If using the pFilterParallel parameter the **single dimension** used as the \"parallelization slicer\" cannot appear in\r\n# the pFilter parameters.\r\n# When using parallelization via the *RunProcess* function the elements listed in pFilterParallel will be split one_at_a_time\r\n# and passed to a recursive call of the process being added to pFilter.\r\n#EndRegion @DOC\r\n\r\n### Global Variables\r\nStringGlobalVariable('sProcessReturnCode');\r\nNumericGlobalVariable('nProcessReturnCode');\r\nnProcessReturnCode= 0;\r\n\r\n### Constants ###\r\ncThisProcName   = GetProcessName();\r\ncUserName       = TM1User();\r\ncMsgErrorLevel  = 'ERROR';\r\ncMsgErrorContent= 'Process:%cThisProcName% ErrorMsg:%sMessage%';\r\ncLogInfo        = 'Process:%cThisProcName% run with parameters pCube:%pCube%, pView:%pView%, pFilter:%pFilter%, pFilterParallel:%pFilterParallel%, pParallelThreads:%pParallelThreads%, pDimDelim:%pDimDelim%, pEleStartDelim:%pEleStartDelim%, pEleDelim:%pEleDelim%, pSuppressConsolStrings:%pSuppressConsolStrings%, pCubeLogging:%pCubeLogging%, pTemp:%pTemp%, pSandbox:%pSandbox%';\r\ncTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\r\ncRandomInt      = NumberToString( INT( RAND( ) * 1000 ));\r\ncDefaultView    = Expand( '%cThisProcName%_%cTimeStamp%_%cRandomInt%' );\r\ncTempSub        = cDefaultView | '_Temp';\r\n\r\n## LogOutput parameters\r\nIF( pLogoutput = 1 );\r\n  LogOutput('INFO', Expand( cLogInfo ) );\r\nENDIF;\r\n\r\n# Trim delimiters\r\nsDelimDim           = TRIM(pDimDelim);\r\nsElementStartDelim  = TRIM(pEleStartDelim);\r\nsDelimElem          = TRIM(pEleDelim);\r\n\r\n### Validate Parameters ###\r\nnErrors = 0;\r\n\r\n## Default filter delimiters\r\nIf( pDimDelim     @= '' );\r\n  pDimDelim     = '&';\r\nEndIf;\r\nIf( pEleStartDelim@= '' );\r\n  pEleStartDelim= '\u00a6';\r\nEndIf;\r\nIf( pEleDelim     @= '' );\r\n  pEleDelim     = '+';\r\nEndIf;\r\n\r\n# Check the delimiters\r\nIf( Trim( pFilter ) @<> '' );\r\n If( sDelimDim @= sElementStartDelim % sDelimDim @= sDelimElem % sElementStartDelim @= sDelimElem );\r\n    sMessage = 'The delimiters cannot be the same.';\r\n    nErrors = nErrors + 1;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n  EndIf;\r\nEndIf;\r\n\r\n# consolidated strings\r\nIf( pSuppressConsolStrings <> 0 );\r\n    pSuppressConsolStrings = 1;\r\nEndIf;\r\n\r\n# Validate cubelogging parameter\r\nIf( pCubeLogging <> 0 & pCubeLogging <> 1 & pCubeLogging <> 2);\r\n  sMessage = 'The cube logging parameter incorrect';\r\n  nErrors = nErrors + 1;\r\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\n# If no cube has been specified then terminate process\r\nIf( Trim( pCube ) @= '' );\r\n  sMessage = 'No cube(s) specified.';\r\n  nErrors = nErrors + 1;\r\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\n# Validate parallelization filter\r\nIf( Scan( pEleStartDelim, pFilterParallel ) > 0 );\r\n  sDimParallel = SubSt( pFilterParallel, 1, Scan( pEleStartDelim, pFilterParallel ) - 1 );\r\n  If( Scan( Lower(sDimParallel) | pEleStartDelim, Lower(pFilter) ) > 0 );\r\n    sMessage = 'Parallelization dimension %sDimParallel% cannot exist in filter.';\r\n    nErrors = nErrors + 1;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n  EndIf;\r\nEndIf;\r\n\r\n# Validate Max Threads\r\nIf( pParallelThreads >= 1 );\r\n  nMaxThreads = Round(pParallelThreads);\r\nElse;\r\n  # Single thread mode\r\n  nMaxThreads = 1;\r\nEndIf;\r\n\r\n# Validate Sandbox\r\nIf( TRIM( pSandbox ) @<> '' );\r\n    If( ServerSandboxExists( pSandbox ) = 0 );\r\n        SetUseActiveSandboxProperty( 0 );\r\n        nErrors = nErrors + 1;\r\n        sMessage = Expand('Sandbox %pSandbox% is invalid for the current user.');\r\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n    Else;\r\n        ServerActiveSandboxSet( pSandbox );\r\n        SetUseActiveSandboxProperty( 1 );\r\n    EndIf;\r\nElse;\r\n    SetUseActiveSandboxProperty( 0 );\r\nEndIf;\r\n\r\n### Check for errors before continuing\r\nIf( nErrors <> 0 );\r\n  If( pStrictErrorHandling = 1 );\r\n      ProcessQuit;\r\n  Else;\r\n      ProcessBreak;\r\n  EndIf;\r\nEndIf;\r\n\r\n# Loop through cubes in pCube\r\nsCubes = pCube;\r\nnCubeDelimiterIndex = 1;\r\n# Get 1st cube\r\nWhile( nCubeDelimiterIndex <> 0 );\r\n\r\n  # Extract 1st cube > sCube\r\n  nCubeDelimiterIndex = Scan( pDimDelim, sCubes );\r\n  If( nCubeDelimiterIndex = 0 );\r\n    sCube   = sCubes;\r\n  Else;\r\n    sCube   = Trim( SubSt( sCubes, 1, nCubeDelimiterIndex - 1 ) );\r\n    sCubes  = Trim( Subst( sCubes, nCubeDelimiterIndex + Long(pDimDelim), Long( sCubes ) ) );\r\n  EndIf;\r\n\r\n  bParallel = 0;\r\n\r\n  # Check if sCube has wildcard\r\n  If( Scan( '*', sCube ) = 0);\r\n    # Validate cube\r\n    If( CubeExists(sCube) = 0 );\r\n      nErrors     = 1;\r\n      sMessage    = Expand( 'Cube %sCube% does not exist.' );\r\n      LogOutput( 'ERROR', Expand( cMsgErrorContent ) );\r\n      If( pStrictErrorHandling = 1 );\r\n          ProcessQuit;\r\n      Else;\r\n          ProcessBreak;\r\n      EndIf;\r\n    Else;\r\n      If( Scan( pEleStartDelim, pFilterParallel ) > 0 );\r\n        nDim = 1;\r\n        sDim = TABDIM( sCube, nDim);\r\n        While ( sDim @<> '' );\r\n          sDim = TABDIM( sCube, nDim);\r\n          If ( sDim @= sDimParallel );\r\n            bParallel = 1;\r\n            sDim = '';\r\n          EndIf;\r\n          nDim = nDim + 1;\r\n        End;\r\n      EndIf;\r\n      If( bParallel = 1 );\r\n        sDimParallel = SubSt( pFilterParallel, 1, Scan( pEleStartDelim, pFilterParallel ) - 1 );\r\n        sElementList = SubSt( pFilterParallel, Scan( pEleStartDelim, pFilterParallel ) + 1, Long( pFilterParallel ) );\r\n        If( SubSt( sElementList, Long( sElementList ), 1 ) @<> pEleDelim );\r\n            sElementList = sElementList | pEleDelim;\r\n        EndIf;\r\n        ## Counting elements in element list\r\n        sElementListCount = sElementList;\r\n        nElements = 0;\r\n        While( Scan( pEleDelim, sElementListCount ) > 0 );\r\n          nElements = nElements + 1;\r\n          sElementListCount = SubSt( sElementListCount, Scan( pEleDelim, sElementListCount ) + 1, Long( sElementListCount ) );\r\n        End;\r\n        IF( Mod( nElements, nMaxThreads ) = 0 );\r\n          nElemsPerThread = INT( nElements / nMaxThreads );\r\n        ELSE;\r\n          nElemsPerThread = INT( nElements / nMaxThreads ) + 1;\r\n        ENDIF;\r\n        nThreadElCounter = 0;\r\n        While( Scan( pEleDelim, sElementList ) > 0 );\r\n          sSlicerEle = SubSt( sElementList, 1, Scan( pEleDelim, sElementList ) - 1 );\r\n          sElementList = SubSt( sElementList, Scan( pEleDelim, sElementList ) + 1, Long( sElementList ) );\r\n          # Do recursive process call with new RunProcess function\r\n          nThreadElCounter = nThreadElCounter + 1;\r\n          sDimDelim = If(pFilter @= '', '', pDimDelim );\r\n          IF( nThreadElCounter = 1 );\r\n            sFilter = Expand('%pFilter%%sDimDelim%%sDimParallel%%pEleStartDelim%%sSlicerEle%');\r\n          ELSE;\r\n            sFilter = Expand('%sFilter%%pEleDelim%%sSlicerEle%');\r\n          ENDIF;\r\n          IF( nThreadElCounter >= nElemsPerThread );\r\n            RunProcess( cThisProcName, 'pLogoutput', pLogoutput,\r\n        \t    'pCube', pCube, 'pView', pView, 'pFilter', sFilter, 'pFilterParallel', '',\r\n        \t    'pDimDelim', pDimDelim, 'pEleStartDelim', pEleStartDelim, 'pEleDelim', pEleDelim,\r\n        \t    'pSuppressConsolStrings', pSuppressConsolStrings, 'pCubeLogging', pCubeLogging, 'pTemp', pTemp, 'pSandbox', pSandbox\r\n        \t  );\r\n        \t  nThreadElCounter = 0;\r\n        \t  sFilter = '';\r\n        \t ENDIF;\r\n        End;\r\n        ## Process last elements - only when filter is not empty (there are still elements) otherwise the entire cube is emptied\r\n        IF( sFilter @<> '' );\r\n          RunProcess( cThisProcName, 'pLogoutput', pLogoutput,\r\n      \t    'pCube', pCube, 'pView', pView, 'pFilter', sFilter, 'pFilterParallel', '',\r\n      \t    'pDimDelim', pDimDelim, 'pEleStartDelim', pEleStartDelim, 'pEleDelim', pEleDelim,\r\n      \t    'pSuppressConsolStrings', pSuppressConsolStrings, 'pCubeLogging', pCubeLogging, 'pTemp', pTemp, 'pSandbox', pSandbox\r\n      \t  );\r\n    \t  ENDIF;\r\n      Else;\r\n        ## Validate the View & filter parameter\r\n        If( Trim( pView ) @= '' & Trim( pFilter ) @= '' & Trim( pSandbox ) @= '' );\r\n          sMessage  = Expand('No view OR filter specified so the entire %sCube% cube has been cleared.');\r\n\t  IF( pLogoutput = 1 );\r\n          \tLogOutput( 'INFO' , Expand( 'Process:%cThisProcName% Message:%sMessage%' ) );\r\n\t  ENDIF;\r\n          CubeClearData( sCube );\r\n        Else;\r\n          # Use different view/subset for different cubes\r\n          sTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\r\n          sRandomInt      = NumberToString( INT( RAND( ) * 1000 ));\r\n          cDefaultView    = Expand( '%cThisProcName%_%sTimeStamp%_%sRandomInt%' );\r\n          #cTempSub        = cDefaultView;\r\n\r\n          If( Trim( pView ) @= '' );\r\n            cView   = cDefaultView ;\r\n          Else;\r\n            cView = Trim( pView );\r\n          EndIf;\r\n\r\n          # Clear view\r\n          If( ViewExists( sCube , cView ) = 0 );\r\n            ## Validate that a Filter has been provided so that a view can be created.\r\n            If( Trim( pFilter ) @= '' );\r\n              sMessage = Expand('View %cView% does not exist in the %sCube% cube AND no Filter has not been specified in order to create a view.');\r\n              LogOutput( 'INFO' , Expand( cMsgErrorContent ) );\r\n              #ProcessBreak;\r\n            EndIf;\r\n\r\n            ### Create View using filter (temp view, therefore no need to destroy) ###\r\n            sProc = '}bedrock.cube.view.create';\r\n            nRet = ExecuteProcess( sProc,\r\n                    'pLogOutput', pLogOutput,\r\n                    'pStrictErrorHandling', pStrictErrorHandling,\r\n                    'pCube', sCube, 'pView', cView, 'pFilter', pFilter,\r\n                    'pSuppressZero', 1, 'pSuppressConsol', 1, 'pSuppressRules', 1, 'pSuppressConsolStrings', pSuppressConsolStrings,\r\n                    'pDimDelim', pDimDelim, 'pEleStartDelim', pEleStartDelim, 'pEleDelim', pEleDelim,\r\n                    'pTemp', pTemp, 'pSubN', pSubN\r\n                   );\r\n\r\n              # Validate Sandbox\r\n              If( TRIM( pSandbox ) @<> '' );\r\n              If( ServerSandboxExists( pSandbox ) = 0 );\r\n                SetUseActiveSandboxProperty( 0 );\r\n                nErrors = nErrors + 1;\r\n                sMessage = Expand('Sandbox %pSandbox% is invalid for the current user.');\r\n                LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n              Else;\r\n                ServerActiveSandboxSet( pSandbox );\r\n                SetUseActiveSandboxProperty( 1 );\r\n              EndIf;\r\n              Else;\r\n                 SetUseActiveSandboxProperty( 0 );\r\n              EndIf;\r\n\r\n            ### Zero Out View ###\r\n            If ( nRet = ProcessExitNormal() );\r\n              If ( pCubeLogging <= 1 );\r\n                sCubeLogging = CellGetS('}CubeProperties', sCube, 'LOGGING' );\r\n                CubeSetLogChanges( sCube, pCubeLogging);\r\n              EndIf;\r\n              ViewZeroOut( sCube, cView );\r\n              sMessage = Expand( 'Succeeded in creating the %cView% view in the %sCube% cube and data has been cleared.' );\r\n\t      IF( pLogoutput = 1 );\r\n              \tLogOutput( 'INFO', Expand( 'Process:%cThisProcName% Message:%sMessage%' ) );\r\n\t      ENDIF;\r\n              If ( pCubeLogging <= 1 );\r\n                CubeSetLogChanges( sCube, IF(sCubeLogging@='YES',1,0) );\r\n              EndIf;\r\n            Else;\r\n              nErrors = nErrors + 1;\r\n              sMessage = Expand( 'Creating view by %sProc% has failed. Nothing has been cleared in the %sCube% cube.' );\r\n              LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n            EndIf;\r\n          Else;\r\n            If ( pCubeLogging <= 1 );\r\n              sCubeLogging = CellGetS('}CubeProperties', sCube, 'LOGGING' );\r\n              CubeSetLogChanges( sCube, pCubeLogging);\r\n            EndIf;\r\n            ViewZeroOut( sCube, cView );\r\n            If ( pCubeLogging <= 1 );\r\n              CubeSetLogChanges( sCube, IF(sCubeLogging@='YES',1,0) );\r\n            EndIf;\r\n          Endif;\r\n        Endif;\r\n      EndIf;\r\n    Endif;\r\n  Else;\r\n    # Create subset of cubes using Wildcard to loop through cubes in pCube with wildcard\r\n    sCubeExp = '\"'|sCube|'\"';\r\n    sMdx = '{TM1FILTERBYPATTERN( {TM1SUBSETALL( [}Cubes] )},'|sCubeExp| ')}';\r\n    If( SubsetExists( '}Cubes' , cTempSub ) = 1 );\r\n      # If a delimited list of cube names includes wildcards then we may have to re-use the subset multiple times\r\n      SubsetMDXSet( '}Cubes' , cTempSub, sMDX );\r\n    Else;\r\n      # temp subset, therefore no need to destroy in epilog\r\n      SubsetCreatebyMDX( cTempSub, sMDX, '}Cubes' , 1 );\r\n    EndIf;\r\n\r\n    # Loop through cubes in subset created based on wildcard\r\n    nCountCube = SubsetGetSize( '}Cubes' , cTempSub );\r\n    While( nCountCube >= 1 );\r\n      # Use different view/subset for different cubes\r\n      sTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\r\n      sRandomInt      = NumberToString( INT( RAND( ) * 1000 ));\r\n      cDefaultView    = Expand( '%cThisProcName%_%sTimeStamp%_%sRandomInt%' );\r\n      sCube           = SubsetGetElementName( '}Cubes' , cTempSub, nCountCube );\r\n      # Validate cube name  Not necessary as derived from subset of }Cubes\r\n      If( CubeExists(sCube) = 0 );\r\n        nErrors = 1;\r\n        sMessage = Expand( '%sCube% does not exist.' );\r\n        LogOutput( 'ERROR', Expand( cMsgErrorContent ) );\r\n      Else;\r\n        If( Scan( pEleStartDelim, pFilterParallel ) > 0 );\r\n          nDim = 1;\r\n          sDim = TABDIM( sCube, nDim);\r\n          While ( sDim @<> '' );\r\n            sDim = TABDIM( sCube, nDim);\r\n            If ( sDim @= sDimParallel );\r\n              bParallel = 1;\r\n              sDim = '';\r\n            EndIf;\r\n            nDim = nDim + 1;\r\n          End;\r\n        EndIf;\r\n        If( bParallel = 1 );\r\n          sDimParallel = SubSt( pFilterParallel, 1, Scan( pEleStartDelim, pFilterParallel ) - 1 );\r\n          sElementList = SubSt( pFilterParallel, Scan( pEleStartDelim, pFilterParallel ) + 1, Long( pFilterParallel ) );\r\n          If( SubSt( sElementList, Long( sElementList ), 1 ) @<> pEleDelim );\r\n              sElementList = sElementList | pEleDelim;\r\n          EndIf;\r\n        ## Counting elements in element list\r\n        sElementListCount = sElementList;\r\n        nElements = 0;\r\n        While( Scan( pEleDelim, sElementListCount ) > 0 );\r\n          nElements = nElements + 1;\r\n          sElementListCount = SubSt( sElementListCount, Scan( pEleDelim, sElementListCount ) + 1, Long( sElementListCount ) );\r\n        End;\r\n        IF( Mod( nElements, nMaxThreads ) = 0 );\r\n          nElemsPerThread = INT( nElements / nMaxThreads );\r\n        ELSE;\r\n          nElemsPerThread = INT( nElements / nMaxThreads ) + 1;\r\n        ENDIF;\r\n        nThreadElCounter = 0;\r\n          While( Scan( pEleDelim, sElementList ) > 0 );\r\n            sSlicerEle = SubSt( sElementList, 1, Scan( pEleDelim, sElementList ) - 1 );\r\n            sElementList = SubSt( sElementList, Scan( pEleDelim, sElementList ) + 1, Long( sElementList ) );\r\n            # Do recursive process call with new RunProcess function\r\n          nThreadElCounter = nThreadElCounter + 1;\r\n          sDimDelim = If(pFilter @= '', '', pDimDelim );\r\n          IF( nThreadElCounter = 1 );\r\n            sFilter = Expand('%pFilter%%sDimDelim%%sDimParallel%%pEleStartDelim%%sSlicerEle%');\r\n          ELSE;\r\n            sFilter = Expand('%sFilter%%pEleDelim%%sSlicerEle%');\r\n          ENDIF;\r\n          IF( nThreadElCounter >= nElemsPerThread );\r\n            RunProcess( cThisProcName, 'pLogoutput', pLogoutput,\r\n        \t    'pCube', pCube, 'pView', pView, 'pFilter', sFilter, 'pFilterParallel', '',\r\n        \t    'pDimDelim', pDimDelim, 'pEleStartDelim', pEleStartDelim, 'pEleDelim', pEleDelim,\r\n        \t    'pSuppressConsolStrings', pSuppressConsolStrings, 'pCubeLogging', pCubeLogging, 'pTemp', pTemp, 'pSandbox', pSandbox\r\n        \t  );\r\n        \t  nThreadElCounter = 0;\r\n        \t  sFilter = '';\r\n        \t ENDIF;\r\n        End;\r\n        ## Process last elements\r\n        IF( sFilter @<> '' );\r\n          RunProcess( cThisProcName, 'pLogoutput', pLogoutput,\r\n      \t    'pCube', pCube, 'pView', pView, 'pFilter', sFilter, 'pFilterParallel', '',\r\n      \t    'pDimDelim', pDimDelim, 'pEleStartDelim', pEleStartDelim, 'pEleDelim', pEleDelim,\r\n      \t    'pSuppressConsolStrings', pSuppressConsolStrings, 'pCubeLogging', pCubeLogging, 'pTemp', pTemp, 'pSandbox', pSandbox\r\n      \t  );\r\n    \t  ENDIF;\r\n        Else;\r\n          ## Validate the View & filter parameter\r\n          If( Trim( pView ) @= '' & Trim( pFilter ) @= '' & Trim( pSandbox ) @= '' );\r\n            # Clear entire cube\r\n            sMessage  = Expand('No view OR filter specified so the entire %sCube% cube has been cleared.');\r\n\t    IF( pLogoutput = 1 );\r\n            \tLogOutput( 'INFO' , Expand( 'Process:%cThisProcName% Message:%sMessage%' ) );\r\n\t    ENDIF;\r\n            CubeClearData( sCube );\r\n          Else;\r\n            # Clear view cView\r\n            If( Trim( pView ) @= '' );\r\n              cView   = cDefaultView ;\r\n            Else;\r\n              cView = Trim( pView );\r\n            EndIf;\r\n\r\n            If( ViewExists( sCube, cView ) = 0 );\r\n              ## Validate that a Filter has been provided so that a view can be created.\r\n              If( Trim( pFilter ) @= '' );\r\n                sMessage = Expand('View %cView% does not exist for %sCube% AND no Filter has not been specified in order to create a view.');\r\n                LogOutput( 'ERROR' , Expand( cMsgErrorContent ) );\r\n                #ProcessBreak;\r\n              EndIf;\r\n\r\n              ### Create View using filter (temp view, therefore no need to destroy) ###\r\n              sProc = '}bedrock.cube.view.create';\r\n              nRet = ExecuteProcess( sProc,\r\n                  'pLogOutput', pLogOutput,\r\n                  'pStrictErrorHandling', pStrictErrorHandling,\r\n                  'pCube', sCube, 'pView', cView, 'pFilter', pFilter,\r\n                  'pSuppressZero', 1, 'pSuppressConsol', 1, 'pSuppressRules', 1, 'pSuppressConsolStrings', pSuppressConsolStrings,\r\n                  'pDimDelim', pDimDelim, 'pEleStartDelim', pEleStartDelim, 'pEleDelim', pEleDelim,\r\n                  'pTemp', pTemp, 'pSubN', pSubN\r\n                  );\r\n\r\n              # Validate Sandbox\r\n              If( TRIM( pSandbox ) @<> '' );\r\n              If( ServerSandboxExists( pSandbox ) = 0 );\r\n                SetUseActiveSandboxProperty( 0 );\r\n                nErrors = nErrors + 1;\r\n                sMessage = Expand('Sandbox %pSandbox% is invalid for the current user.');\r\n                LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n              Else;\r\n                ServerActiveSandboxSet( pSandbox );\r\n                SetUseActiveSandboxProperty( 1 );\r\n              EndIf;\r\n              Else;\r\n                 SetUseActiveSandboxProperty( 0 );\r\n              EndIf;\r\n\r\n\r\n              ### Zero Out View ###\r\n              IF ( nRet = ProcessExitNormal() );\r\n                If ( pCubeLogging <= 1 );\r\n                  sCubeLogging = CellGetS('}CubeProperties', sCube, 'LOGGING' );\r\n                  CubeSetLogChanges( sCube, pCubeLogging);\r\n                EndIf;\r\n                ViewZeroOut( sCube, cView );\r\n                sMessage = Expand( 'Succeeded in creating the %cView% view in the %sCube% cube and data has been cleared.' );\r\n\t\tIF( pLogoutput = 1 );\r\n                    LogOutput( 'INFO', Expand( 'Process:%cThisProcName% Message:%sMessage%' ) );\r\n\t\tENDIF;\r\n                If ( pCubeLogging <= 1 );\r\n                  CubeSetLogChanges( sCube, IF(sCubeLogging@='YES',1,0) );\r\n                EndIf;\r\n              ELSE;\r\n                nErrors = nErrors + 1;\r\n                sMessage = Expand( 'Creating view by %sProc% has failed. Nothing has been cleared in the %sCube% cube.' );\r\n                LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n              ENDIF;\r\n            Else;\r\n              If ( pCubeLogging <= 1 );\r\n                sCubeLogging = CellGetS('}CubeProperties', sCube, 'LOGGING' );\r\n                CubeSetLogChanges( sCube, pCubeLogging);\r\n              EndIf;\r\n              ViewZeroOut( sCube, cView );\r\n              If ( pCubeLogging <= 1 );\r\n                CubeSetLogChanges( sCube, IF(sCubeLogging@='YES',1,0) );\r\n              EndIf;\r\n            Endif;\r\n          EndIf;\r\n        EndIf;\r\n        nCountCube = nCountCube - 1;\r\n        # Use different view/subset for different cubes\r\n        sTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\r\n        sRandomInt      = NumberToString( INT( RAND( ) * 1000 ));\r\n        cDefaultView    = Expand( '%cThisProcName%_%sTimeStamp%_%sRandomInt%' );\r\n        #cTempSub        = cDefaultView;\r\n      EndIf;\r\n    End;\r\n  EndIf;\r\nEnd;\r\n\r\n### End Prolog ###",
    "Variables": []
}