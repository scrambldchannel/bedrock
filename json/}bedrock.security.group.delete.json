{
    "DataProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n",
    "DataSource": {
        "Type": "None"
    },
    "EpilogProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n#################################################################################################\r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock Ver 4.0~~##\r\n#################################################################################################\r\n\r\n### Return code & final error message handling\r\nIf( nErrors > 0 );\r\n    sMessage = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\r\n    nProcessReturnCode = 0;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\r\n    If( pStrictErrorHandling = 1 );\r\n        ProcessQuit;\r\n    EndIf;\r\nElse;\r\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully deleted group %pGroup% from dimension %cGroupDim%.' );\r\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\r\n    nProcessReturnCode = 1;\r\n    If( pLogoutput = 1 );\r\n        LogOutput('INFO', Expand( sProcessAction ) );\r\n    EndIf;\r\nEndIf;\r\n\r\n### End Epilog ###\r\n",
    "HasSecurityAccess": true,
    "MetadataProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n",
    "Name": "}bedrock.security.group.delete",
    "Parameters": [
        {
            "Name": "pLogOutput",
            "Prompt": "OPTIONAL: Write parameters and action summary to server message log (Boolean True = 1)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pStrictErrorHandling",
            "Prompt": "OPTIONAL: On encountering any error exit with major error status by ProcessQuit after writing to the server message log (Boolean True = 1)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pGroup",
            "Prompt": "REQUIRED: Groups (Separated by Delimiter Accepts Wild card)",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pDelim",
            "Prompt": "OPTIONAL: Delimiter character (Defaults to & if left blank)",
            "Type": "String",
            "Value": "&"
        }
    ],
    "PrologProcedure": "#Region CallThisProcess\r\n# A snippet of code provided as an example how to call this process should the developer be working on a system without access to an editor with auto-complete.\r\nIf( 1 = 0 );\r\n    ExecuteProcess( '}bedrock.security.group.delete', 'pLogOutput', pLogOutput,\r\n      'pStrictErrorHandling', pStrictErrorHandling,\r\n\t    'pGroup', '', 'pDelim', '&'\r\n\t);\r\nEndIf;\r\n#EndRegion CallThisProcess\r\n\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n#################################################################################################\r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock Ver 4.0~~##\r\n#################################################################################################\r\n\r\n#Region @DOC\r\n# Description:\r\n# This process will delete client groups.\r\n\r\n# Use case: Intended for development or production.\r\n# 1/ Clean up security groups after go live.\r\n# 2/ Delete obsolete security groups as business needs change.\r\n\r\n# Note:\r\n# Naturally, a group (pGroup) is mandatory otherwise the process will abort:\r\n# - Multiple groups can be specified separated by a delimiter.\r\n# - If group does not exist then it will be skipped.\r\n# - If multiple groups are specified and some don't exist and some do, then the ones that do exist will still be deleted.\r\n#EndRegion @DOC\r\n\r\n##Global Variables\r\nStringGlobalVariable('sProcessReturnCode');\r\nNumericGlobalVariable('nProcessReturnCode');\r\nnProcessReturnCode= 0;\r\n\r\n### Constants ###\r\ncThisProcName           = GetProcessName();\r\ncTimeStamp              = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\r\ncRandomInt              = NumberToString( INT( RAND( ) * 1000 ));\r\ncTempSub                = cThisProcName | '_' | cTimeStamp | '_' | cRandomInt;\r\ncTempFile               = GetProcessErrorFileDirectory | cTempSub | '.csv';\r\ncGroupDim               = '}Groups';\r\ncGroupHier              = cGroupDim;\r\ncUserName               = TM1User();\r\ncMsgErrorLevel          = 'ERROR';\r\ncMsgErrorContent        = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\r\ncLogInfo                = 'Process:%cThisProcName% run with parameters pGroup:%pGroup%, pDelim:%pDelim%.';\r\ncBuiltInGroups          = 'ADMIN&SecurityAdmin&DataAdmin&OperationsAdmin&';\r\n\r\n## LogOutput parameters\r\nIF( pLogoutput = 1 );\r\n    LogOutput('INFO', Expand( cLogInfo ) );\r\nENDIF;\r\n\r\n### Validate Parameters ###\r\nnErrors = 0;\r\n# If blank delimiter specified then convert to default\r\nIf( pDelim @= '' );\r\n    pDelim              = '&';\r\nEndIf;\r\n\r\n# If no groups have been specified then terminate process\r\nIf( Trim( pGroup ) @= '' );\r\n    nErrors             = 1;\r\n    sMessage            = 'No groups specified.';\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\n### Check for errors before continuing\r\nIf( nErrors <> 0 );\r\n  If( pStrictErrorHandling = 1 );\r\n      ProcessQuit;\r\n  Else;\r\n      ProcessBreak;\r\n  EndIf;\r\nEndIf;\r\n\r\n# Check alias exists\r\nIf( DimensionExists('}ElementAttributes_'|cGroupDim) = 0 % DimIx('}ElementAttributes_'|cGroupDim, '}TM1_DefaultDisplayValue') = 0 );\r\n    AttrInsert( cGroupDim, '', '}TM1_DefaultDisplayValue', 'A' );\r\nEndIf;\r\n\r\n### Split pGroups into individual groups and delete ###\r\nsGroups                 = pGroup;\r\nnDelimiterIndex         = 1;\r\nWhile( nDelimiterIndex <> 0 );\r\n  nDelimiterIndex = Scan( pDelim, sGroups );\r\n  If( nDelimiterIndex = 0 );\r\n        sGroup          = sGroups;\r\n  Else;\r\n        sGroup          = Trim( SubSt( sGroups, 1, nDelimiterIndex - 1 ) );\r\n        sGroups         = Trim( Subst( sGroups, nDelimiterIndex + Long(pDelim), Long( sGroups ) ) );\r\n  EndIf;\r\n\r\n  If( Scan( '*', sGroup ) = 0);\r\n    # Don't attempt to delete a blank group\r\n    If( sGroup @<> '' );\r\n        If( DimIx( '}Groups', sGroup ) > 0 );\r\n            If( nErrors = 0 );\r\n                If( Scan( Upper( sGroup ) |'&', Upper( cBuiltInGroups ) ) = 0 );\r\n                    DeleteGroup( sGroup );\r\n                Else;\r\n                    nErrors = 1;\r\n                    sMessage= Expand('Attempt to delete built-in group %sGroup%.');\r\n                    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n                EndIf;\r\n            EndIf;\r\n            If( nErrors > 0 );\r\n                ItemReject( Expand( cMsgErrorContent ) );\r\n            EndIf;\r\n        EndIf;\r\n    EndIf;\r\n  Else;\r\n    # Wildcard search string\r\n    iCount = 0;\r\n    iCheck = 1;\r\n    sChar = sGroup;\r\n    While (iCheck > 0);\r\n      iCheck = Scan('*',sChar);\r\n      If( iCheck > 0 );\r\n        iCount = iCount + 1;\r\n        sChar = Subst(sChar,iCheck+1,(long(sChar)-iCheck));\r\n      Endif;\r\n    End;\r\n    If(iCount = 1);\r\n      ##If the wilcardsearch is *String, below code will get executed\r\n      if(Subst(sGroup,iCount,1) @= '*');\r\n        sGroup1 = '\"'| Subst(sGroup,iCount+1,(Long(sGroup)- iCount))|'\"';\r\n        sTempCount = NumbertoString(Long(sGroup)-iCount);\r\n        sMdx = '{FILTER({TM1SUBSETALL(['|cGroupDim|'].['|cGroupHier|'])},\r\n                (Right( ['|cGroupDim|'].['|cGroupHier|'].[}TM1_DefaultDisplayValue],'| sTempCount|') ='|sGroup1|'))}+\r\n                {FILTER({TM1SUBSETALL(['|cGroupDim|'].['|cGroupHier|'])},\r\n                (Right( ['|cGroupDim|'].['|cGroupHier|'].CurrentMember.Name,'| sTempCount|') ='|sGroup1|'))}';\r\n        If( SubsetExists( cGroupDim, cTempSub ) = 1 );\r\n            # If a delimited list of Groups includes wildcards then we may have to re-use the subset multiple times\r\n            SubsetMDXSet( cGroupDim, cTempSub, sMDX );\r\n        Else;\r\n            # temp subset, therefore no need to destroy in epilog\r\n            SubsetCreatebyMDX( cTempSub, sMDX, cGroupDim, 1 );\r\n        EndIf;\r\n\r\n        nHier_Sub_Size = HierarchySubsetGetSize(cGroupDim, cGroupHier, cTempSub);\r\n        nCount = nHier_Sub_Size;\r\n        While (nCount >= 1);\r\n          sTemp = HierarchySubsetElementGetIndex (cGroupDim, cGroupHier, cTempSub, '', 1);\r\n          sElement = HierarchySubsetGetElementName(cGroupDim, cGroupHier, cTempSub, nCount);\r\n          If( Scan( Upper( sElement ) |'&', Upper( cBuiltInGroups ) ) = 0 );\r\n            DeleteGroup( sElement );\r\n          Else;\r\n            sMessage= 'Attempt to delete built-in group %sGroup%.';\r\n            LogOutput( 'WARN', Expand( cMsgErrorContent ) );\r\n          EndIF;\r\n          nCount = nCount -1;\r\n        End;\r\n        ##If the wilcardsearch is String*, below code will get executed\r\n        ElseIf(Subst(sGroup,Long(sGroup),1) @= '*');\r\n        sGroup1 = '\"'| Subst(sGroup,iCount,(Long(sGroup)- iCount))|'\"';\r\n        sMdx = '{FILTER({TM1SUBSETALL(['|cGroupDim|'].['|cGroupHier|'])},\r\n                (INSTR('| NumbertoString(iCount)|', ['|cGroupDim|'].['|cGroupHier|'].[}TM1_DefaultDisplayValue],'|sGroup1|') ='| NumbertoString(iCount)|'))}+\r\n                {FILTER({TM1SUBSETALL(['|cGroupDim|'].['|cGroupHier|'])},\r\n                (INSTR('| NumbertoString(iCount)|', ['|cGroupDim|'].['|cGroupHier|'].CurrentMember.Name,'|sGroup1|') ='| NumbertoString(iCount)|'))}';\r\n        If( SubsetExists( cGroupDim, cTempSub ) = 1 );\r\n            # If a delimited list of Groups includes wildcards then we may have to re-use the subset multiple times\r\n            SubsetMDXSet( cGroupDim, cTempSub, sMDX );\r\n        Else;\r\n            # temp subset, therefore no need to destroy in epilog\r\n            SubsetCreatebyMDX( cTempSub, sMDX, cGroupDim, 1 );\r\n        EndIf;\r\n\r\n        nHier_Sub_Size = HierarchySubsetGetSize(cGroupDim, cGroupHier, cTempSub);\r\n        nCount = nHier_Sub_Size;\r\n        While (nCount >= 1);\r\n          sTemp = HierarchySubsetElementGetIndex (cGroupDim, cGroupHier, cTempSub, '', 1);\r\n          sElement = HierarchySubsetGetElementName(cGroupDim, cGroupHier, cTempSub, nCount);\r\n          If( Scan( Upper( sElement ) |'&', Upper( cBuiltInGroups ) ) = 0 );\r\n            DeleteGroup( sElement );\r\n          Else;\r\n            sMessage= 'Attempt to delete built-in group %sGroup%.';\r\n            LogOutput( 'WARN', Expand( cMsgErrorContent ) );\r\n          EndIF;\r\n          nCount = nCount -1;\r\n        End;\r\n      Endif;\r\n    Else;\r\n      ##If the wilcardsearch is *String*, below code will get executed\r\n      sGroup1 = '\"'| Subst(sGroup,iCount,(Long(sGroup)- iCount))|'\"';\r\n      sMdx = '{FILTER({TM1SUBSETALL(['|cGroupDim|'].['|cGroupHier|'])},\r\n              (INSTR(1,['|cGroupDim|'].['|cGroupHier|'].[}TM1_DefaultDisplayValue],'|sGroup1|') <> 0))}+\r\n              {FILTER({TM1SUBSETALL(['|cGroupDim|'].['|cGroupHier|'])},\r\n              (INSTR(1,['|cGroupDim|'].['|cGroupHier|'].CurrentMember.Name,'|sGroup1|') <> 0))}';\r\n      If( SubsetExists( cGroupDim, cTempSub ) = 1 );\r\n            # If a delimited list of Groups includes wildcards then we may have to re-use the subset multiple times\r\n            SubsetMDXSet( cGroupDim, cTempSub, sMDX );\r\n        Else;\r\n            # temp subset, therefore no need to destroy in epilog\r\n            SubsetCreatebyMDX( cTempSub, sMDX, cGroupDim, 1 );\r\n        EndIf;\r\n\r\n      nHier_Sub_Size = HierarchySubsetGetSize(cGroupDim, cGroupHier, cTempSub);\r\n      nCount = nHier_Sub_Size;\r\n      While (nCount >= 1);\r\n        sTemp = HierarchySubsetElementGetIndex (cGroupDim, cGroupHier, cTempSub, '', 1);\r\n        sElement = HierarchySubsetGetElementName(cGroupDim, cGroupHier, cTempSub, nCount);\r\n          If( Scan( Upper( sElement ) |'&', Upper( cBuiltInGroups ) ) = 0 );\r\n            DeleteGroup( sElement );\r\n          Else;\r\n            sMessage= 'Attempt to delete built-in group %sGroup%.';\r\n            LogOutput( 'WARN', Expand( cMsgErrorContent ) );\r\n          EndIF;\r\n        nCount = nCount -1;\r\n      End;\r\n    Endif;\r\n  EndIf;\r\nEnd;\r\n\r\nIf( nErrors = 0 );\r\n  DimensionSortOrder( '}Groups', 'ByName', 'Ascending', 'ByName' , 'Ascending' );\r\nEndIf;\r\n\r\n\r\n### End Prolog ###\r\n573,4",
    "Variables": []
}