{
    "DataProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n",
    "DataSource": {
        "Type": "?",
        "asciiDecimalSeparator": ".",
        "asciiDelimiterChar": ",",
        "asciiHeaderRecords": 0,
        "asciiQuoteCharacter": "\"",
        "asciiThousandSeparator": ",",
        "dataSourceNameForClient": "}Dimensions",
        "dataSourceNameForServer": "}Dimensions"
    },
    "EpilogProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n#################################################################################################\r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock Ver 4.0.0~~##\r\n#################################################################################################\r\n\r\n### If errors occurred terminate process with a major error status ###\r\nIf( nErrors <> 0 );\r\n  sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% incurred at least 1 major error and consequently aborted.' );\r\n  nProcessReturnCode = 0;\r\n  LogOutput( 'ERROR', Expand( sProcessReturnCode | ' Please see above lines in this file for more details.' ) );\r\n  If( pStrictErrorHandling = 1 );\r\n      ProcessQuit;\r\n  EndIf;\r\nEndIf;\r\n\r\n#Return Code\r\nsProcessAction      = Expand( 'Process:%cThisProcName% has validated all the elements for %pDim% dimension and generated a csv report: %cFile%.' );\r\nsProcessReturnCode  = Expand( '%sProcessReturnCode% %sProcessAction%' );\r\nnProcessReturnCode  = 1;\r\nIF ( pLogoutput = 1 );\r\n  LogOutput('INFO', sProcessAction );\r\nENDIF;\r\n\r\n### End Epilog ###",
    "HasSecurityAccess": true,
    "MetadataProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n#################################################################################################\r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock Ver 4.0.0~~##\r\n#################################################################################################\r\n\r\n# Validates characters in elements\r\n\r\n# Increment nMeta\r\nnMeta           = nMeta + 1;\r\n\r\n# Output 1st line\r\nIF( nMeta = 1 );\r\n    sOutput     = 'Dimension:Hierarchy\"' |','| '\"Element\"'  |','| '\"Type\"' |','| '\"Comments';\r\n    TextOutput ( cFile , sOutput );\r\nEndIf;\r\n\r\n### Skip Control dimensions###\r\nIF(Subst(vDim , 1 , 1 ) @= '}' );\r\n    ItemSkip;\r\nENDIF;\r\n\r\n# Set Dim name & hierachy name\r\nIF( SCAN( ':' , vDim )=0 );\r\n    sDim        = vDim ;\r\n    sHier       = sDim ;\r\nELSE;\r\n    sDim        = SUBST( vDim, 1 , SCAN( ':' , vDim ) -1 );\r\n    sHier       = SUBST( vDim, SCAN( ':' , vDim ) +1, 99 );\r\nENDIF;\r\n\r\nnDimSize        = ElementCount( sDim , sHier );\r\nnCount          = 1;\r\nWhile( nCount <= nDimSize );\r\n    sEle        = ElementName( sDim , sHier , nCount );\r\n    sEleType    = ElementType( sDim , sHier , sEle );\r\n    sEleNew     = '';\r\n    nEleSiz     = Long(sEle);\r\n    nChar       = 1;\r\n    While( nChar <= nEleSiz & ElementIndex( sDim , sHier , sEle ) > 0 );\r\n        sChar       = NumberToString( nChar );\r\n        sEleChar    = Subst( sEle , nChar , 1 );\r\n        nCode       = CODE( sEle , nChar );\r\n        sCode       = NumberToString( nCode );\r\n        IF( vDim @= sDim );\r\n            IF( nChar=1 & pFirst=1 & (nCode=39 % nCode=45 % nCode=91 % nCode=34 % nCode=64 % nCode=33 % nCode=43 % nCode=123 % nCode=37));\r\n                sOutput = Expand('%vDim%\" , %sEle% , %sEleType% ,Has an illegal 1st character \"%sEleChar%\" with an AscII code of %sCode%.');\r\n                TextOutput ( cFile , sOutput );\r\n            EndIf;\r\n            IF( sEleChar@='/' % sEleChar@='|' % sEleChar@='\"' % sEleChar@='\\' % sEleChar@='>' %\r\n                sEleChar@='<' % sEleChar@=':' % sEleChar@='?' % sEleChar@='*');\r\n                sOutput = Expand('%vDim%\" , %sEle% , %sEleType% ,Has a forbidden character #%sChar% \"%sEleChar%\" with an AscII code of %sCode%.');\r\n                TextOutput ( cFile , sOutput );\r\n            ENDIF;\r\n        ELSEIF( ElementType( sDim, sHier, sEle)@='C' % pHier@<>'' );\r\n            IF( nChar=1 & pFirst=1 & (nCode=39 % nCode=45 % nCode=91 % nCode=34 % nCode=64 % nCode=33 % nCode=43 % nCode=123 % nCode=37));\r\n                sOutput = Expand('%vDim%\" , %sEle% , %sEleType% ,Has an illegal 1st character \"%sEleChar%\" with an AscII code of %sCode%.');\r\n                TextOutput ( cFile , sOutput );\r\n            EndIf;\r\n            IF( sEleChar@='/' % sEleChar@='|' % sEleChar@='\"' % sEleChar@='\\' % sEleChar@='>' %\r\n                sEleChar@='<' % sEleChar@=':' % sEleChar@='?' % sEleChar@='*');\r\n                sOutput = Expand('%vDim%\" , %sEle% , %sEleType% ,Has a forbidden character #%sChar% \"%sEleChar%\" with an AscII code of %sCode%.');\r\n                TextOutput ( cFile , sOutput );\r\n            ENDIF;\r\n        ENDIF;\r\n\r\n        nChar       = nChar + 1;\r\n    End;\r\n\r\n    nCount      = nCount + 1;\r\nEnd;\r\n\r\n### End MetaData ###",
    "Name": "}bedrock.hier.elements.validate",
    "Parameters": [
        {
            "Name": "pLogOutput",
            "Prompt": "OPTIONAL: Write parameters and action summary to server message log (Boolean True = 1)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pStrictErrorHandling",
            "Prompt": "OPTIONAL: On encountering any error exit with major error status by ProcessQuit after writing to the server message log (Boolean True = 1)",
            "Type": "Numeric",
            "Value": "0"
        },
        {
            "Name": "pDim",
            "Prompt": "OPTIONAL: Dimension name or list? (accepts wildcards). Will process ALL if = *",
            "Type": "String",
            "Value": ""
        },
        {
            "Name": "pHier",
            "Prompt": "OPTIONAL: Hierarchy name or list? (accepts wildcards). Will process ALL if = *",
            "Type": "String",
            "Value": "*"
        },
        {
            "Name": "pFirst",
            "Prompt": "OPTIONAL: 0 = Ignore 1st character requirements 1 = Validate 1st character more stringently than other characters (e.g. for MDX no \"\"+\"\" as 1st character)",
            "Type": "Numeric",
            "Value": "1"
        },
        {
            "Name": "pDelim",
            "Prompt": "OPTIONAL: Delimiter for dimension list (If blank or not passed then \"\"&\"\" will be used as default list delimiter)",
            "Type": "String",
            "Value": "&"
        }
    ],
    "PrologProcedure": "#Region CallThisProcess\r\n# A snippet of code provided as an example how to call this process should the developer be working on a system without access to an editor with auto-complete.\r\nIf( 1 = 0 );\r\n    ExecuteProcess( '}bedrock.hier.elements.validate', 'pLogOutput', pLogOutput,\r\n      'pStrictErrorHandling', pStrictErrorHandling,\r\n    \t'pDim', '', 'pHier', '*',\r\n    \t'pFirst', 1, 'pDelim', '&'\r\n\t);\r\nEndIf;\r\n#EndRegion CallThisProcess\r\n\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n#################################################################################################\r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock Ver 4.0~~##\r\n#################################################################################################\r\n\r\n#Region @DOC\r\n# Description:\r\n# This process will review all elements in selected dimensions (you can specify a single dimension,\r\n# multiple dimensions or wildcards to match dimensions) and hierarchies and will generate a `csv`\r\n# file listing all elements with unusual characters.\r\n# Control dimensions are ignored.\r\n\r\n# Note:\r\n# - pDim: Specify which dimensions to validate. When specifying a dimension name, wildcards can\r\n#   be specified by using the `*` and `?` characters. A list of dimensions can also be entered with\r\n#   a delimiter (e.g. `v*&plan*` will process all dimensions starting with `v` and `plan`). If\r\n#   * is entered then it ignores anything entered for hierarchy (pHier) and processes all dimensions\r\n# - pHier: Specify which hierarchies to validate. To validate ALL hierachies, enter *.\r\n#   When specifying a hierarchy name, wildcards can be specified by using the\r\n#   `*` and `?` characters. A list of hierachies can also be entered with a delimiter. If pHier\r\n#   has a value then it does not make sense that pDim can be set up as a list or with wildcards.\r\n# - pDelim: The delimiter is used when specifying multiple dimensions or multiple hierachies. The\r\n#   default delimiter is `&`. Any delimiter can be used by specifying a value for pDelim. Choose\r\n#   a delimiter that won't be used in either the wildcard search strings or dimension names.\r\n# - pFirst:\r\n#   - When set to `1`: all requirements for all characters are validated.\r\n#   - ELSE: ignores stringent requirements for 1st character.\r\n#EndRegion @DOC\r\n\r\n\r\n### Global Variables\r\nStringGlobalVariable ('sProcessReturnCode');\r\nNumericGlobalVariable('nProcessReturnCode');\r\nnProcessReturnCode = 0;\r\n\r\n### Constants ###\r\ncThisProcName     = GetProcessName();\r\ncUserName         = TM1User();\r\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\r\ncRandomInt        = NumberToString( INT( RAND( ) * 1000 ));\r\ncSubset           = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\r\ncMsgErrorLevel    = 'ERROR';\r\ncMsgErrorContent  = '%cThisProcName% : %sMessage% : %cUserName%';\r\ncLogInfo          = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%, pFirst:%pFirst%, pDelim:%pDelim%';\r\ncDim              = '}Dimensions';\r\ncFile             = GetProcessErrorFileDirectory | 'Element Issues.csv';\r\n\r\n# Variables\r\nnMeta             = 0;\r\n\r\n## LogOutput parameters\r\nIF ( pLogoutput = 1 );\r\n    LogOutput('INFO', Expand( cLogInfo ) );\r\nENDIF;\r\n\r\n### Validate Parameters ###\r\nnErrors = 0;\r\n\r\nIf( Scan( '*', pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0 & Scan( ':', pDim ) > 0 & pHier @= '' );\r\n    # A hierarchy has been passed as dimension. Handle the input error by splitting dim:hier into dimension & hierarchy\r\n    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\r\n    pDim        = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\r\nEndIf;\r\n\r\n# Validate dimension\r\nIf( Trim( pDim ) @= '' );\r\n    nErrors = 1;\r\n    sMessage = 'No dimension specified. Use * to process all dimensions';\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\n# Validate hierarchy\r\nIf( Trim( pHier ) @= '' );\r\n    ## use same name as Dimension. Since wildcards are allowed, this is managed inside the code below\r\nEndIf;\r\n\r\nIf( pDelim @= '' );\r\n    pDelim = '&';\r\nEndIf;\r\n\r\n## Validate dimension\r\nIF( Trim( pDim ) @= '*' );\r\n    sMDX                = Expand('{ TM1SUBSETALL( [}Dimensions] ) }');\r\nElseIf( Trim( pHier ) @= '*' );\r\n    IF( Scan( pDelim , pDim )>0 );\r\n        # delimiter in pDim. Seperate and add MDX for each part separately\r\n        sMDX            = '{ ';\r\n        sDims           = Trim( pDim );\r\n        nDelimiterIndex = 1;\r\n        While( nDelimiterIndex <> 0 );\r\n            nDelimiterIndex = Scan( pDelim, sDims );\r\n            If( nDelimiterIndex = 0 );\r\n                sDim            = sDims;\r\n            ELSE;\r\n                sDim            = Trim( SubSt( sDims, 1, nDelimiterIndex - 1 ) );\r\n                sDims           = Trim( Subst( sDims, nDelimiterIndex + Long(pDelim), Long( sDims ) ) );\r\n            ENDIF;\r\n            IF(DimensionExists(sDim)=1 );\r\n                sMDX            = Expand('{TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) ,\"%sDim%*\")}');\r\n            ELSEIF(Scan( '*', sDim )=0 & Scan( '?', sDim )=0 );\r\n                #nErrors = 1;\r\n                sMessage= Expand('Dimension %sDim% does not exist.');\r\n                LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n            ELSE;\r\n                sMDX            = sMDX | IF(Long(sMDX)>4,\r\n                                            Expand(',TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) ,\"%sDim%\")'),\r\n                                            Expand(' TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) ,\"%sDim%\")'));\r\n            ENDIF;\r\n        END;\r\n        sMDX                    = sMDX | ' }';\r\n    ELSE;\r\n        IF(DimensionExists(pDim)=1 );\r\n            sMDX                = Expand('{TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) ,\"%pDim%*\")}');\r\n        ELSEIF(Scan( '*', pDim )=0 & Scan( '?', pDim )=0 );\r\n            nErrors = 1;\r\n            sMessage= Expand('Dimension %pDim% does not exist.');\r\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n        ELSE;\r\n            sMDX                = Expand('{TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) ,\"%pDim%\")}');\r\n        ENDIF;\r\n    ENDIF;\r\n\r\nElseIf( HierarchyExists( pDim , pHier ) = 1 & Trim( pHier ) @<>'' );\r\n    sMDX = Expand('{TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) ,\"%pDim%:%pHier%\")}');\r\n\r\nElseIf( Scan( pDelim  , pHier )>0 % Scan( '*'     , pHier )>0 % Scan( '?'     , pHier )>0);\r\n    sMDX            = '{ ';\r\n    IF( Scan( pDelim  , pHier )>0 );\r\n        # delimiter in pHier. Seperate and add MDX for each part separately\r\n        sHiers           = Trim( pHier );\r\n        nDelimiterIndex = 1;\r\n        While( nDelimiterIndex <> 0 );\r\n            nDelimiterIndex = Scan( pDelim, sHiers );\r\n            If( nDelimiterIndex = 0 );\r\n                sHier            = sHiers;\r\n            ELSE;\r\n                sHier            = Trim( SubSt( sHiers, 1, nDelimiterIndex - 1 ) );\r\n                sHiers           = Trim( Subst( sHiers, nDelimiterIndex + Long(pDelim), Long( sHiers ) ) );\r\n            ENDIF;\r\n            IF(HierarchyExists( pDim, sHier )=1 );\r\n                sMDX            = sMDX | IF(Long(sMDX)>4,\r\n                                            Expand(',TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) ,\"%pDim%:%sHier%\")'),\r\n                                            Expand(' TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) ,\"%pDim%:%sHier%\")'));\r\n            ELSEIF(Scan( '*', sHier )=0 & Scan( '?', sHier )=0 );\r\n                nErrors = 1;\r\n                sMessage= Expand('Dimension:Hierarchy %pDim%:%sHier% does not exist.');\r\n                LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n            ELSE;\r\n                sMDX            = sMDX | IF(Long(sMDX)>4,\r\n                                            Expand(',TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) ,\"%pDim%:%sHier%\")'),\r\n                                            Expand(' TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) ,\"%pDim%:%sHier%\")'));\r\n            ENDIF;\r\n\r\n        END;\r\n        sMDX                    = sMDX | ' }';\r\n    ELSE;\r\n        # No delimiters but with wildcards in hierachy\r\n        IF(HierarchyExists( pDim, pHier )=1 );\r\n            sMDX                = Expand('{TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) ,\"%pDim%:%pHier%\")}');\r\n        ELSEIF(Scan( '*', pHier )=0 & Scan( '?', pHier )=0 );\r\n            nErrors = 1;\r\n            sMessage= Expand('Dimension:Hierarchy %pDim%:%pHier% does not exist.');\r\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n        ELSE;\r\n            sMDX                = Expand('{TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) ,\"%pDim%:%pHier%\")}');\r\n        ENDIF;\r\n\r\n    ENDIF;\r\n\r\nElseIf( Trim( pHier ) @='' );\r\n    ## Use main hierarchy for each dimension processed\r\n    pHier = Trim( pDim );\r\n    sMDX            = '{ ';\r\n    IF( Scan( pDelim  , pHier )>0 );\r\n        # delimiter in pHier. Seperate and add MDX for each part separately\r\n        sHiers           = Trim( pHier );\r\n        nDelimiterIndex = 1;\r\n        While( nDelimiterIndex <> 0 );\r\n            nDelimiterIndex = Scan( pDelim, sHiers );\r\n            If( nDelimiterIndex = 0 );\r\n                sHier            = sHiers;\r\n            ELSE;\r\n                sHier            = Trim( SubSt( sHiers, 1, nDelimiterIndex - 1 ) );\r\n                sHiers           = Trim( Subst( sHiers, nDelimiterIndex + Long(pDelim), Long( sHiers ) ) );\r\n            ENDIF;\r\n            IF(HierarchyExists( sHier, sHier )=1 );\r\n                sMDX            = sMDX | IF(Long(sMDX)>4,\r\n                                            Expand(',TM1FILTERBYPATTERN( EXCEPT( TM1SUBSETALL( [}Dimensions] ) , TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) , \"*:*\") ) ,\"%sHier%\")'),\r\n                                            Expand(' TM1FILTERBYPATTERN( EXCEPT( TM1SUBSETALL( [}Dimensions] ) , TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) , \"*:*\") ) ,\"%sHier%\")'));\r\n            ELSEIF(Scan( '*', sHier )=0 & Scan( '?', sHier )=0 );\r\n                nErrors = 1;\r\n                sMessage= Expand('Dimension:Hierarchy %sHier%:%sHier% does not exist.');\r\n                LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n            ELSE;\r\n                sMDX            = sMDX | IF(Long(sMDX)>4,\r\n                                            Expand(',TM1FILTERBYPATTERN( EXCEPT( TM1SUBSETALL( [}Dimensions] ) , TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) , \"*:*\") ) ,\"%sHier%\")'),\r\n                                            Expand(' TM1FILTERBYPATTERN( EXCEPT( TM1SUBSETALL( [}Dimensions] ) , TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) , \"*:*\") ) ,\"%sHier%\")'));\r\n            ENDIF;\r\n\r\n        END;\r\n        sMDX                    = sMDX | ' }';\r\n    ELSE;\r\n        # No delimiters but with wildcards in hierachy\r\n        IF(HierarchyExists( pDim, pHier )=1 );\r\n            sMDX                = Expand('{TM1FILTERBYPATTERN( EXCEPT( TM1SUBSETALL( [}Dimensions] ) , TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) , \"*:*\") ) ,\"%pDim%\")}');\r\n        ELSEIF(Scan( '*', pHier )=0 & Scan( '?', pHier )=0 );\r\n            nErrors = 1;\r\n            sMessage= Expand('Dimension:Hierarchy %pDim%:%pHier% does not exist.');\r\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n        ELSE;\r\n            sMDX                = Expand('{TM1FILTERBYPATTERN( EXCEPT( TM1SUBSETALL( [}Dimensions] ) , TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) , \"*:*\") ) ,\"%pDim%\")}');\r\n        ENDIF;\r\n\r\n    ENDIF;\r\n\r\nELSE;\r\n    nErrors = 1;\r\n    sMessage= Expand('Dimension:Hierarchy %pDim%:%pHier% does not exist.');\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\n### Check for errors before continuing\r\nIf( nErrors <> 0 );\r\n    DatasourceType = 'NULL';\r\n    ProcessBreak;\r\nEndIf;\r\n\r\n# Create temporary subset\r\nSubsetCreatebyMDX(cSubset, sMDX , 1 );\r\n\r\n### Set data source for process ###\r\nDatasourceType              = 'SUBSET';\r\nDatasourceNameForServer     = cDim;\r\nDatasourceNameForClient     = cDim;\r\nDatasourceDimensionSubset   = cSubset;\r\n\r\n### End Prolog ###",
    "UIData": "CubeAction=1511\fDataAction=1503\fCubeLogChanges=0\f",
    "Variables": [
        {
            "EndByte": 0,
            "Name": "vDim",
            "Position": 1,
            "StartByte": 0,
            "Type": "String"
        }
    ],
    "VariablesUIData": []
}